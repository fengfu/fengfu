<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="宁静·致远">
<meta property="og:url" content="http://fengfu.io/index.html">
<meta property="og:site_name" content="宁静·致远">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="宁静·致远">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://fengfu.io/"/>





  <title>宁静·致远</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">宁静·致远</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-rss">
          <a href="/atom.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            RSS
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengfu.io/2018/09/26/JVM致命错误日志/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="宁静·致远">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静·致远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/26/JVM致命错误日志/" itemprop="url">JVM致命错误日志</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-26T10:29:58+08:00">
                2018-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/09/26/JVM致命错误日志/" class="leancloud_visitors" data-flag-title="JVM致命错误日志">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>翻译:曲风富</p>
<p><em>译者注：本文翻译自Oracle官方文档，有一定英文能力者建议查看原文：</em><br><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html" target="_blank" rel="external">https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html</a></p>
<p>当JVM出现致命错误时，会生成一个包含有错误信息以及出错时系统状态的日志文件。</p>
<p>本附录包含以下内容：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html#gbwcy" target="_blank" rel="external">1 致命错误日志的位置</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html#gbmuz" target="_blank" rel="external">2 致命错误日志描述</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html#header" target="_blank" rel="external">3 头部格式</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html#gbvki" target="_blank" rel="external">4 线程部分格式</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html#gbvkd" target="_blank" rel="external">5 进程部分格式</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html#gbvla" target="_blank" rel="external">6 系统部分格式</a></li>
</ul>
<h2 id="C-1-致命错误日志的位置"><a href="#C-1-致命错误日志的位置" class="headerlink" title="C.1 致命错误日志的位置"></a>C.1 致命错误日志的位置</h2><p>产品标志-XX:ErrorFile=<em>file</em> 可用于指定文件的创建位置，其中<em>file</em>表示文件位置的完整路径。文件变量中的子字符串%%将转换为%，子字符串%p将转换为进程的进程ID。</p>
<p>在下面的示例中，错误日志文件将写入目录/var/log/java，并将命名为java_error{pid}.log。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -XX:ErrorFile=/var/log/java/java_error%p.log</div></pre></td></tr></table></figure></p>
<p>如果未指定-XX:ErrorFile=file标志，则默认情况下文件名为hs<em>err</em>{pid}.log，其中pid是进程的进程ID。</p>
<p>此外，如果未指定-XX:ErrorFile=file标志，系统将尝试在进程的工作目录中创建该文件。如果无法在工作目录中创建文件（空间不足，权限问题或其他问题），则会在操作系统的临时目录中创建该文件。在Solaris OS和Linux上，临时目录是/tmp。 在Windows上，临时目录由TMP环境变量的值指定; 如果未定义该环境变量，则使用TEMP环境变量的值。</p>
<h2 id="C-2-致命错误日志描述"><a href="#C-2-致命错误日志描述" class="headerlink" title="C.2 致命错误日志描述"></a>C.2 致命错误日志描述</h2><p>错误日志包含致命错误发生时获取的信息，包括以下可能的信息：</p>
<ul>
<li>引发致命错误的操作异常或信号</li>
<li>版本和配置信息</li>
<li>引发致命错误和线程堆栈跟踪的线程的详细信息</li>
<li>正在运行的线程列表及其状态</li>
<li>有关堆的摘要信息</li>
<li>已加载的本地库列表</li>
<li>命令行参数</li>
<li>环境变量</li>
<li>有关操作系统和CPU的详细信息</li>
</ul>
<p><em>注 - 在某些情况下，只有这些信息的子集输出到错误日志。这可能会发生在致命错误非常严重，以至于错误的处理程序无法恢复并报告所有细节。</em></p>
<p>错误日志是一个文本文件，包含以下部分：</p>
<ul>
<li>标题，提供crash的简要说明。<a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html#header" target="_blank" rel="external">3 Header Format</a></li>
<li>包含线程信息的部分。<a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html#gbvki" target="_blank" rel="external">4 Thread Section Format</a></li>
<li>包含进程信息的部分。<a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html#gbvkd" target="_blank" rel="external">5 Process Section Format</a></li>
<li>包含系统信息的部分。<a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html#gbvla" target="_blank" rel="external">6 System Section Format</a></li>
</ul>
<p><em>注 - 请注意，此处描述的致命错误日志的格式基于JDK7格式，可能与其他版本有所不同。</em></p>
<h2 id="C-3-头部格式"><a href="#C-3-头部格式" class="headerlink" title="C.3 头部格式"></a>C.3 头部格式</h2><p>每个致命错误日志文件开头的头部区域都包含问题的简要说明。这部分头部信息也打印到标准输出，可能会显示在应用程序的输出日志中。</p>
<p>头部信息包含指向HotSpot虚拟机错误报告页面的链接，用户可以在其中提交错误报告。</p>
<p>以下是crash日志的示例头部信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#</div><div class="line"># An unexpected error has been detected by Java Runtime Environment:</div><div class="line">#</div><div class="line">#  SIGSEGV (0xb) at pc=0x417789d7, pid=21139, tid=1024</div><div class="line">#</div><div class="line"># Java VM: Java HotSpot(TM) Client VM (1.6.0-rc-b63 mixed mode, sharing)</div><div class="line"># Problematic frame:</div><div class="line"># C  [libNativeSEGV.so+0x9d7]</div><div class="line">#</div><div class="line"># If you would like to submit a bug report, please visit:</div><div class="line">#   http://java.sun.com/webapps/bugreport/crash.jsp</div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>此示例显示VM在一个意外信号上crash。下一行描述了信号的类型，产生信号的程序计数器（pc），进程ID和线程ID，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#  SIGSEGV (0xb) at pc=0x417789d7, pid=21139, tid=1024</div><div class="line">      |      |           |             |         +--- thread id</div><div class="line">      |      |           |             +------------- process id</div><div class="line">      |      |           +--------------------------- program counter</div><div class="line">      |      |                                        (instruction pointer)</div><div class="line">      |      +--------------------------------------- signal number</div><div class="line">      +---------------------------------------------- signal name</div></pre></td></tr></table></figure></p>
<p>下一行包含VM版本（Client VM或Server VM），指示应用程序是以混合模式还是解释模式运行，以及是否启用了类文件共享的指示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># Java VM: Java HotSpot(TM) Client VM (1.6.0-rc-b63 mixed mode, sharing)</div></pre></td></tr></table></figure></p>
<p>下一个信息是导致crash的函数帧，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># Problematic frame:</div><div class="line"># C  [libNativeSEGV.so+0x9d7]</div><div class="line">  |              +-- Same as pc, but represented as library name and offset.</div><div class="line">  |                  For position-independent libraries (JVM and most shared</div><div class="line">  |                  libraries), it is possible to inspect the instructions</div><div class="line">  |                  that caused the crash without a debugger or core file</div><div class="line">  |                  by using a disassembler to dump instructions near the</div><div class="line">  |                  offset.</div><div class="line">  +----------------- Frame type</div></pre></td></tr></table></figure></p>
<p>在该示例中，C帧类型指示本机C帧。下表显示了可能的帧类型。</p>
<table>
<thead>
<tr>
<th><strong>帧类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>C</td>
<td>本地C帧</td>
</tr>
<tr>
<td>j</td>
<td>解释执行的Java帧</td>
</tr>
<tr>
<td>V</td>
<td>虚拟机帧</td>
</tr>
<tr>
<td>v</td>
<td>VM生成的stub帧</td>
</tr>
<tr>
<td>J</td>
<td>其他的帧类型，包含被编译过的Java帧</td>
</tr>
</tbody>
</table>
<p>内部错误将导致VM错误处理程序生成类似的错误转储。但是头部格式不尽相同。 示例中的内部错误是guarantee()失败，断言失败，ShouldNotReachHere()等。 以下是如何在头部信息中查找内部错误的示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#</div><div class="line"># An unexpected error has been detected by HotSpot Virtual Machine:</div><div class="line">#</div><div class="line"># Internal Error (4F533F4C494E55583F491418160E43505000F5), pid=10226, tid=16384</div><div class="line">#</div><div class="line"># Java VM: Java HotSpot(TM) Client VM (1.6.0-rc-b63 mixed mode)</div></pre></td></tr></table></figure></p>
<p>在上面的头部信息中，没有信号名称或信号编号。相反，第二行现在包含文本”内部错误”和长十六进制字符串。 此十六进制字符串对检测到错误的源模块和行号进行编码。 通常，此”错误字符串”仅对在HotSpot虚拟机上工作的工程师有用。</p>
<p>错误字符串对行号进行编码，因此随着每次代码更改和释放而更改。一个版本中某一个带有给定错误字符串的crash（例如1.6.0）可能与更新版本中的相同crash（例如1.6.0_01）不对应，即使他们的错误字符串相匹配。</p>
<p><em>注意 - 不要认为在一个与错误字符串相关的情况下工作的解决方案或解决方案将在与相同错误字符串相关的另一个情况下工作。 注意以下事实：</em></p>
<p><em>•具有相同根本原因的错误可能具有不同的错误字符串。</em></p>
<p><em>•具有相同错误字符的错误可能具有完全不同的根本原因。</em></p>
<p><em>因此，在排除错误时，不应将错误字符串用作唯一的标准。</em></p>
<h2 id="C-4-线程区域格式"><a href="#C-4-线程区域格式" class="headerlink" title="C.4 线程区域格式"></a>C.4 线程区域格式</h2><p>本节包含有关刚刚crash的线程的信息。如果多个线程同时crash，则只打印一个线程。</p>
<h3 id="C-4-1-线程信息"><a href="#C-4-1-线程信息" class="headerlink" title="C.4.1 线程信息"></a>C.4.1 线程信息</h3><p>线程部分的第一部分显示了引发致命错误的线程，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Current thread (0x0805ac88):  JavaThread &quot;main&quot; [_thread_in_native, id=21139]</div><div class="line">                    |             |         |            |          +-- ID</div><div class="line">                    |             |         |            +------------- state</div><div class="line">                    |             |         +-------------------------- name</div><div class="line">                    |             +------------------------------------ type</div><div class="line">                    +-------------------------------------------------- pointer</div></pre></td></tr></table></figure></p>
<p>线程指针是指向Java VM内部线程结构的指针，这通常没什么意义，除非你正在调试实时Java VM或核心文件。</p>
<p>以下列表显示了可能的线程类型。</p>
<ul>
<li>JavaThread</li>
<li>VMThread</li>
<li>CompilerThread</li>
<li>GCTaskThread</li>
<li>WatcherThread</li>
<li>ConcurrentMarkSweepThread</li>
</ul>
<p>下面的表格描述了重要的线程状态：</p>
<table>
<thead>
<tr>
<th><strong>线程状态</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>_thread_uninitialized</td>
<td>线程未创建。仅在内存损坏的情况下才会发生这种情况</td>
</tr>
<tr>
<td>_thread_new</td>
<td>已创建线程但尚未启动</td>
</tr>
<tr>
<td>_thread_in_native</td>
<td>线程正在运行本机代码。该错误可能是本机代码中的错误</td>
</tr>
<tr>
<td>_thread_in_vm</td>
<td>线程正在运行VM代码</td>
</tr>
<tr>
<td>_thread_in_Java</td>
<td>线程正在运行解释或编译的Java代码</td>
</tr>
<tr>
<td>_thread_blocked</td>
<td>线程被block</td>
</tr>
<tr>
<td>…_trans</td>
<td>如果上述任何状态后跟字符串_trans，则表示该线程正在更改为其他状态</td>
</tr>
</tbody>
</table>
<p>输出中的线程ID是本地线程标识符。</p>
<p>如果Java线程是守护线程，则在线程状态之前打印字符串守护程序。</p>
<h3 id="C-4-2-信号信息"><a href="#C-4-2-信号信息" class="headerlink" title="C.4.2 信号信息"></a>C.4.2 信号信息</h3><p>错误日志中的下一个信息描述了导致VM终止的意外信号。在Windows系统中，输出显示如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">siginfo: ExceptionCode=0xc0000005, reading address 0xd8ffecf1</div></pre></td></tr></table></figure></p>
<p>在上面的示例中，异常代码为0xc0000005（ACCESS_VIOLATION），当线程尝试读取地址0xd8ffecf1时发生异常。</p>
<p>在Solaris OS和Linux系统中，信号编号（si_signo）和信号代码（si_code）用于标识异常，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">siginfo:si_signo=11, si_errno=0, si_code=1, si_addr=0x00004321</div></pre></td></tr></table></figure></p>
<h3 id="C-4-3-寄存器上下文"><a href="#C-4-3-寄存器上下文" class="headerlink" title="C.4.3 寄存器上下文"></a>C.4.3 寄存器上下文</h3><p>错误日志中的下一个信息显示致命错误时的寄存器上下文。此输出的确切格式取决于处理器。以下示例显示了Intel（IA32）处理器的输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Registers:</div><div class="line">EAX=0x00004321, EBX=0x41779dc0, ECX=0x080b8d28, EDX=0x00000000</div><div class="line">ESP=0xbfffc1e0, EBP=0xbfffc1f8, ESI=0x4a6b9278, EDI=0x0805ac88</div><div class="line">EIP=0x417789d7, CR2=0x00004321, EFLAGS=0x00010216</div></pre></td></tr></table></figure></p>
<p>与日志中的指令信息结合使用时，寄存器值可能很有用，如下所述。</p>
<h3 id="C-4-4-机器指令"><a href="#C-4-4-机器指令" class="headerlink" title="C.4.4 机器指令"></a>C.4.4 机器指令</h3><p>在寄存器值之后，错误日志包含堆栈顶部，随后是系统crash时程序计数器（PC）附近的32字节指令（操作码）。可以使用反汇编程序对这些操作码进行解码，以生成crash位置周围的指令。请注意，IA32和AMD64指令的长度可变，因此在crashPC之前无法始终可靠地解码指令。</p>
<p><em>译者注：可以使用</em><a href="https://onlinedisassembler.com/odaweb/" target="_blank" rel="external"><em>https://onlinedisassembler.com/odaweb/</em></a><em>这种在线工具对指令进行反汇编，当然你也可以使用udis86(</em><a href="http://udis86.sourceforge.net/" target="_blank" rel="external"><em>http://udis86.sourceforge.net</em></a><em>)，前提是你需要安装gcc自行编译才能使用。</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Top of Stack: (sp=0xbfffc1e0)</div><div class="line">0xbfffc1e0:   00000000 00000000 0818d068 00000000</div><div class="line">0xbfffc1f0:   00000044 4a6b9278 bfffd208 41778a10</div><div class="line">0xbfffc200:   00004321 00000000 00000cd8 0818d328</div><div class="line">0xbfffc210:   00000000 00000000 00000004 00000003</div><div class="line">0xbfffc220:   00000000 4000c78c 00000004 00000000</div><div class="line">0xbfffc230:   00000000 00000000 00180003 00000000</div><div class="line">0xbfffc240:   42010322 417786ec 00000000 00000000</div><div class="line">0xbfffc250:   4177864c 40045250 400131e8 00000000</div><div class="line">Instructions: (pc=0x417789d7)</div><div class="line">0x417789c7:   ec 14 e8 72 ff ff ff 81 c3 f2 13 00 00 8b 45 08</div><div class="line">0x417789d7:   0f b6 00 88 45 fb 8d 83 6f ee ff ff 89 04 24 e8</div></pre></td></tr></table></figure></p>
<h3 id="C-4-5-线程栈"><a href="#C-4-5-线程栈" class="headerlink" title="C.4.5 线程栈"></a>C.4.5 线程栈</h3><p>在可能的情况下，错误日志中的下一个输出是线程堆栈。这包括基址和堆栈顶部的地址，当前堆栈指针以及线程可用的未使用堆栈的数量。在可能的情况下，遵循堆栈帧，最多打印100帧。 对于C/C++帧，也可以打印库名称。 重要的是要注意，在某些致命错误条件下，堆栈可能已损坏，在这种情况下，此详细信息可能不可用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Stack: [0x00040000,0x00080000),  sp=0x0007f9f8,  free space=254k</div><div class="line">Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)</div><div class="line">V  [jvm.dll+0x83d77]</div><div class="line">C  [App.dll+0x1047]</div><div class="line">j  Test.foo()V+0</div><div class="line">j  Test.main([Ljava/lang/String;)V+0</div><div class="line">v  ~StubRoutines::call_stub</div><div class="line">V  [jvm.dll+0x80f13]</div><div class="line">V  [jvm.dll+0xd3842]</div><div class="line">V  [jvm.dll+0x80de4]</div><div class="line">C  [java.exe+0x14c0]</div><div class="line">C  [java.exe+0x64cd]</div><div class="line">C  [kernel32.dll+0x214c7]</div><div class="line">Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)</div><div class="line">j  Test.foo()V+0</div><div class="line">j  Test.main([Ljava/lang/String;)V+0</div><div class="line">v  ~StubRoutines::call_stub</div></pre></td></tr></table></figure></p>
<p>日志包含了2个线程栈：</p>
<ul>
<li>第一个线程堆栈是Native帧，它打印显示所有函数调用的本地线程。但是，此线程堆栈不考虑运行时编译器内联的Java方法; 如果方法是内联的，它们似乎是父级堆栈框架的一部分。</li>
</ul>
<p>本地帧的线程堆栈中的信息提供有关crash原因的重要信息。通过从上到下分析列表中的库，通常可以确定哪个库可能导致问题并将其报告给负责该库的相应组织。</p>
<ul>
<li>第二个线程栈是Java帧，它打印包含内联方法的Java帧，跳过本地帧。根据crash情况，可能无法打印本地线程栈，但可能会打印Java帧。</li>
</ul>
<h3 id="C-4-6-进一步的细节"><a href="#C-4-6-进一步的细节" class="headerlink" title="C.4.6 进一步的细节"></a>C.4.6 进一步的细节</h3><p>如果错误发生在VM线程或编译器线程中，则可能会打印更多详细信息。例如，在VM线程的情况下，如果VM线程在致命错误时执行VM操作，则打印VM操作。 在下面的输出示例中，编译器线程引发了致命错误。 该任务是编译器任务，HotSpot Client VM正在编译方法hs101t004Thread.ackermann。</p>
<p>Current CompileTask:</p>
<p>HotSpot Client Compiler:754   b</p>
<p>nsk.jvmti.scenarios.hotswap.HS101.hs101t004Thread.ackermann(IJ)J (42 bytes)</p>
<p>对于HotSpot Server VM，编译器任务的输出略有不同，但也包括完整的类名和方法。</p>
<h2 id="C-5-进程区域格式"><a href="#C-5-进程区域格式" class="headerlink" title="C.5 进程区域格式"></a>C.5 进程区域格式</h2><p>进程部分在线程部分之后打印。它包含有关整个进程的信息，包括进程的线程列表和内存使用情况。</p>
<h3 id="C-5-1-线程列表"><a href="#C-5-1-线程列表" class="headerlink" title="C.5.1 线程列表"></a>C.5.1 线程列表</h3><p>线程列表包括VM知道的线程。 这包括所有Java线程和一些VM内部线程，但不包括未附加到VM的用户应用程序创建的任何本地线程。 输出格式如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">=&gt;0x0805ac88 JavaThread &quot;main&quot; [_thread_in_native, id=21139]</div><div class="line">|      |         |        |             |             +----- ID</div><div class="line">|      |         |        |             +------------------- state</div><div class="line">|      |         |        |                                  (JavaThread only)</div><div class="line">|      |         |        +--------------------------------- name</div><div class="line">|      |         +------------------------------------------ type</div><div class="line">|      +---------------------------------------------------- pointer</div><div class="line">+------------------------------------------------------ &quot;=&gt;&quot; current thread</div></pre></td></tr></table></figure></p>
<p>下面是一个输出示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Java Threads: ( =&gt; current thread )</div><div class="line">  0x080c8da0 JavaThread &quot;Low Memory Detector&quot; daemon [_thread_blocked, id=21147]</div><div class="line">  0x080c7988 JavaThread &quot;CompilerThread0&quot; daemon [_thread_blocked, id=21146]</div><div class="line">  0x080c6a48 JavaThread &quot;Signal Dispatcher&quot; daemon [_thread_blocked, id=21145]</div><div class="line">  0x080bb5f8 JavaThread &quot;Finalizer&quot; daemon [_thread_blocked, id=21144]</div><div class="line">  0x080ba940 JavaThread &quot;Reference Handler&quot; daemon [_thread_blocked, id=21143]</div><div class="line">=&gt;0x0805ac88 JavaThread &quot;main [_thread_in_native, id=21139]</div><div class="line">Other Threads:</div><div class="line">  0x080b6070 VMThread [id=21142]</div><div class="line">  0x080ca088 WatcherThread [id=21148]</div></pre></td></tr></table></figure></p>
<p>有关线程类型和线程状态的描述请见<a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html#gbvki" target="_blank" rel="external">C.4 Thread Section Format</a>.</p>
<h3 id="C-5-2-VM状态"><a href="#C-5-2-VM状态" class="headerlink" title="C.5.2 VM状态"></a>C.5.2 VM状态</h3><p>接下来的信息是VM状态，描述了整个虚拟机的状态。下面的表格描述了VM的一般状态。</p>
<table>
<thead>
<tr>
<th><strong>VM一般状态</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>not at a safepoint</td>
<td>正常执行</td>
</tr>
<tr>
<td>at safepoint</td>
<td>所有线程被阻塞在VM中以等待特殊VM操作完成</td>
</tr>
<tr>
<td>synchronizing</td>
<td>请求了一个特殊的VM操作，VM正在等待VM中所有的线程阻塞</td>
</tr>
</tbody>
</table>
<p>VM状态输出是错误日志中的单行输出，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VM state:not at safepoint (normal execution)</div></pre></td></tr></table></figure></p>
<h4 id="C-5-3-互斥锁和监视器"><a href="#C-5-3-互斥锁和监视器" class="headerlink" title="C.5.3 互斥锁和监视器"></a><strong>C.5.3 互斥锁和监视器</strong></h4><p>错误日志中的下一个信息是当前由线程拥有的互斥锁和监视器的列表。 这些互斥锁是VM内部锁，而不是与Java对象关联的监视器。 下面的示例显示了在保持VM锁定时发生crash时输出的外观。对于每个锁，日志包含锁的名称，其所有者以及VM内部互斥结构的地址及其操作系统锁。通常，此信息仅对非常熟悉HotSpot VM的用户有用。 所有者线程可以交叉引用到线程列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VM Mutex/Monitor currently owned by a thread:</div><div class="line"></div><div class="line">([mutex/lock_event])[0x007357b0/0x0000031c] Threads_lock - owner thread: 0x00996318</div><div class="line"></div><div class="line">[0x00735978/0x000002e0] Heap_lock - owner thread: 0x00736218</div></pre></td></tr></table></figure></p>
<h3 id="C-5-4-堆摘要"><a href="#C-5-4-堆摘要" class="headerlink" title="C.5.4 堆摘要"></a>C.5.4 堆摘要</h3><p>下一个信息是堆的摘要。 输出取决于垃圾收集（GC）配置。 在此示例中，使用串行收集器，禁用类数据共享，并且tenured generation为空。 这可能表示致命错误发生在早期或启动期间，并且GC尚未将任何对象提升为终身代。 以下是此输出的示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Heap</div><div class="line"> def new generation   total 576K, used 161K [0x46570000, 0x46610000, 0x46a50000)</div><div class="line">  eden space 512K,  31% used [0x46570000, 0x46598768, 0x465f0000)</div><div class="line">  from space 64K,   0% used [0x465f0000, 0x465f0000, 0x46600000)</div><div class="line">  to   space 64K,   0% used [0x46600000, 0x46600000, 0x46610000)</div><div class="line"> tenured generation   total 1408K, used 0K [0x46a50000, 0x46bb0000, 0x4a570000)</div><div class="line">   the space 1408K,   0% used [0x46a50000, 0x46a50000, 0x46a50200, 0x46bb0000)</div><div class="line"> compacting perm gen  total 8192K, used 1319K [0x4a570000, 0x4ad70000, 0x4e570000)</div><div class="line">   the space 8192K,  16% used [0x4a570000, 0x4a6b9d48, 0x4a6b9e00, 0x4ad70000)</div><div class="line">No shared spaces configured.</div></pre></td></tr></table></figure></p>
<h3 id="C-5-5-内存映射"><a href="#C-5-5-内存映射" class="headerlink" title="C.5.5 内存映射"></a>C.5.5 内存映射</h3><p>日志中的下一个信息是crash时的虚拟内存区域列表。对于大型应用程序，此列表可能很长。调试一些crash时，内存映射非常有用，因为它可以告诉你实际使用的库，它们在内存中的位置，以及堆，堆栈和保护页的位置。</p>
<p>内存映射的格式是特定于操作系统的。 在Solaris操作系统上，将打印基本地址和库名称。 在Linux系统上，打印进程内存映射（/proc/pid/maps）。 在Windows系统上，将打印每个库的基址和结束地址。 在Linux/x86上生成以下示例输出。 注意，为了简洁起见，示例中省略了大多数行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Dynamic libraries:</div><div class="line">08048000-08056000 r-xp 00000000 03:05 259171     /h/jdk6/bin/java</div><div class="line">08056000-08058000 rw-p 0000d000 03:05 259171     /h/jdk6/bin/java</div><div class="line">08058000-0818e000 rwxp 00000000 00:00 0</div><div class="line">40000000-40013000 r-xp 00000000 03:0a 400046     /lib/ld-2.2.5.so</div><div class="line">40013000-40014000 rw-p 00013000 03:0a 400046     /lib/ld-2.2.5.so</div><div class="line">40014000-40015000 r--p 00000000 00:00 0</div><div class="line">Lines omitted.</div><div class="line">4123d000-4125a000 rwxp 00001000 00:00 0</div><div class="line">4125a000-4125f000 rwxp 00000000 00:00 0</div><div class="line">4125f000-4127b000 rwxp 00023000 00:00 0</div><div class="line">4127b000-4127e000 ---p 00003000 00:00 0</div><div class="line">4127e000-412fb000 rwxp 00006000 00:00 0</div><div class="line">412fb000-412fe000 ---p 00083000 00:00 0</div><div class="line">412fe000-4137b000 rwxp 00086000 00:00 0</div><div class="line">Lines omitted.</div><div class="line">44600000-46570000 rwxp 00090000 00:00 0</div><div class="line">46570000-46610000 rwxp 00000000 00:00 0</div><div class="line">46610000-46a50000 rwxp 020a0000 00:00 0</div><div class="line">46a50000-46bb0000 rwxp 00000000 00:00 0</div><div class="line">46bb0000-4a570000 rwxp 02640000 00:00 0</div><div class="line">Lines omitted.</div></pre></td></tr></table></figure></p>
<p>上述内存映射中的行的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">40049000-4035c000 r-xp 00000000 03:05 824473      /jdk1.5/jre/lib/i386/client/libjvm.so</div><div class="line">|&lt;-------------&gt;|  ^      ^       ^     ^        |&lt;-----------------------------------&gt;|</div><div class="line">  Memory region    |      |       |     |                           |</div><div class="line">                   |      |       |     |                           |</div><div class="line">  Permission   --- +      |       |     |                           |</div><div class="line">    r: read               |       |     |                           |</div><div class="line">    w: write              |       |     |                           |</div><div class="line">    x: execute            |       |     |                           |</div><div class="line">    p: private            |       |     |                           |</div><div class="line">    s: share              |       |     |                           |</div><div class="line">                          |       |     |                           |</div><div class="line">  File offset   ----------+       |     |                           |</div><div class="line">                                  |     |                           |</div><div class="line">  Major ID and minor ID of -------+     |                           |</div><div class="line">  the device where the file             |                           |</div><div class="line">  is located (i.e. /dev/hda5)           |                           |</div><div class="line">                                        |                           |</div><div class="line">  inode number  ------------------------+                           |</div><div class="line">                                                                    |</div><div class="line">  File name  -------------------------------------------------------+</div></pre></td></tr></table></figure></p>
<p>在内存映射输出中，每个库都有两个虚拟内存区域：一个用于代码，另一个用于数据。 代码段的权限标记为r-xp（可读，可执行，私有），数据段的权限为rw-p（可读，可写，私有）。</p>
<p>Java堆已经包含在输出中的堆摘要中，但是验证为堆保留的实际内存区域是否与堆摘要中的值匹配以及属性是否设置为rwxp可能很有用。</p>
<p>线程堆栈通常在内存映射中显示为两个背对背区域，一个具有权限— p（保护页面），另一个具有权限rwxp（实际堆栈空间）。 此外，了解防护页面大小或堆栈大小很有用。 例如，在该存储器映射中，堆栈位于4127b000到412fb000。</p>
<p>在Windows系统上，内存映射输出是每个已加载模块的加载和结束地址，如下例所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Dynamic libraries:</div><div class="line">0x00400000 - 0x0040c000     c:\jdk6\bin\java.exe</div><div class="line">0x77f50000 - 0x77ff7000     C:\WINDOWS\System32\ntdll.dll</div><div class="line">0x77e60000 - 0x77f46000     C:\WINDOWS\system32\kernel32.dll</div><div class="line">0x77dd0000 - 0x77e5d000     C:\WINDOWS\system32\ADVAPI32.dll</div><div class="line">0x78000000 - 0x78087000     C:\WINDOWS\system32\RPCRT4.dll</div><div class="line">0x77c10000 - 0x77c63000     C:\WINDOWS\system32\MSVCRT.dll</div><div class="line">0x08000000 - 0x08183000     c:\jdk6\jre\bin\client\jvm.dll</div><div class="line">0x77d40000 - 0x77dcc000     C:\WINDOWS\system32\USER32.dll</div><div class="line">0x7e090000 - 0x7e0d1000     C:\WINDOWS\system32\GDI32.dll</div><div class="line">0x76b40000 - 0x76b6c000     C:\WINDOWS\System32\WINMM.dll</div><div class="line">0x6d2f0000 - 0x6d2f8000     c:\jdk6\jre\bin\hpi.dll</div><div class="line">0x76bf0000 - 0x76bfb000     C:\WINDOWS\System32\PSAPI.DLL</div><div class="line">0x6d680000 - 0x6d68c000     c:\jdk6\jre\bin\verify.dll</div><div class="line">0x6d370000 - 0x6d38d000     c:\jdk6\jre\bin\java.dll</div><div class="line">0x6d6a0000 - 0x6d6af000     c:\jdk6\jre\bin\zip.dll</div><div class="line">0x10000000 - 0x10032000     C:\bugs\crash2\App.dll</div></pre></td></tr></table></figure></p>
<h3 id="C-5-6-VM参数和环境变量"><a href="#C-5-6-VM参数和环境变量" class="headerlink" title="C.5.6 VM参数和环境变量"></a>C.5.6 VM参数和环境变量</h3><p>错误日志中的下一个信息是VM参数列表，后跟环境变量列表。 例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">VM Arguments:</div><div class="line">java_command: NativeSEGV 2</div><div class="line">Environment Variables:</div><div class="line">JAVA_HOME=/h/jdk</div><div class="line">PATH=/h/jdk/bin:.:/h/bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin:</div><div class="line">     /usr/dist/local/exe:/usr/dist/exe:/bin:/usr/sbin:/usr/ccs/bin:</div><div class="line">     /usr/ucb:/usr/bsd:/usr/etc:/etc:/usr/dt/bin:/usr/openwin/bin:</div><div class="line">     /usr/sbin:/sbin:/h:/net/prt-web/prt/bin</div><div class="line">USERNAME=user</div><div class="line">LD_LIBRARY_PATH=/h/jdk6/jre/lib/i386/client:/h/jdk6/jre/lib/i386:</div><div class="line">     /h/jdk6/jre/../lib/i386:/h/bugs/NativeSEGV</div><div class="line">SHELL=/bin/tcsh</div><div class="line">DISPLAY=:0.0</div><div class="line">HOSTTYPE=i386-linux</div><div class="line">OSTYPE=linux</div><div class="line">ARCH=Linux</div><div class="line">MACHTYPE=i386</div></pre></td></tr></table></figure></p>
<p>请注意，环境变量列表不是完整列表，而是适用于Java VM的环境变量的子集。</p>
<h3 id="C-5-7-信号处理程序"><a href="#C-5-7-信号处理程序" class="headerlink" title="C.5.7 信号处理程序"></a>C.5.7 信号处理程序</h3><p>在Solaris OS和Linux上，错误日志中的下一个信息是信号处理程序列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Signal Handlers:</div><div class="line">SIGSEGV: [libjvm.so+0x3aea90], sa_mask[0]=0xfffbfeff, sa_flags=0x10000004</div><div class="line">SIGBUS: [libjvm.so+0x3aea90], sa_mask[0]=0xfffbfeff, sa_flags=0x10000004</div><div class="line">SIGFPE: [libjvm.so+0x304e70], sa_mask[0]=0xfffbfeff, sa_flags=0x10000004</div><div class="line">SIGPIPE: [libjvm.so+0x304e70], sa_mask[0]=0xfffbfeff, sa_flags=0x10000004</div><div class="line">SIGILL: [libjvm.so+0x304e70], sa_mask[0]=0xfffbfeff, sa_flags=0x10000004</div><div class="line">SIGUSR1: SIG_DFL, sa_mask[0]=0x00000000, sa_flags=0x00000000</div><div class="line">SIGUSR2: [libjvm.so+0x306e80], sa_mask[0]=0x80000000, sa_flags=0x10000004</div><div class="line">SIGHUP: [libjvm.so+0x3068a0], sa_mask[0]=0xfffbfeff, sa_flags=0x10000004</div><div class="line">SIGINT: [libjvm.so+0x3068a0], sa_mask[0]=0xfffbfeff, sa_flags=0x10000004</div><div class="line">SIGQUIT: [libjvm.so+0x3068a0], sa_mask[0]=0xfffbfeff, sa_flags=0x10000004</div><div class="line">SIGTERM: [libjvm.so+0x3068a0], sa_mask[0]=0xfffbfeff, sa_flags=0x10000004</div><div class="line">SIGUSR2: [libjvm.so+0x306e80], sa_mask[0]=0x80000000, sa_flags=0x10000004</div></pre></td></tr></table></figure></p>
<h2 id="C-6-系统区域格式"><a href="#C-6-系统区域格式" class="headerlink" title="C.6 系统区域格式"></a>C.6 系统区域格式</h2><p>错误日志中的最后一部分是系统信息。 输出是特定于操作系统的，但通常包括操作系统版本，CPU信息和有关内存配置的摘要信息。</p>
<p>以下示例显示Solaris 9 OS系统上的输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">---------------  S Y S T E M  ---------------</div><div class="line">OS:                       Solaris 9 12/05 s9s_u5wos_08b SPARC</div><div class="line">           Copyright 2005 Sun Microsystems, Inc.  All Rights Reserved.</div><div class="line">                        Use is subject to license terms.</div><div class="line">                           Assembled 21 November 2005</div><div class="line">uname:SunOS 5.9 Generic_112233-10 sun4u  (T2 libthread)</div><div class="line">rlimit: STACK 8192k, CORE infinity, NOFILE 65536, AS infinity</div><div class="line">load average:0.41 0.14 0.09</div><div class="line">CPU:total 2 has_v8, has_v9, has_vis1, has_vis2, is_ultra3</div><div class="line"></div><div class="line">Memory: 8k page, physical 2097152k(1394472k free)</div><div class="line">vm_info: Java HotSpot(TM) Client VM (1.5-internal) for solaris-sparc,</div><div class="line"></div><div class="line">built on Aug 12 2005 10:22:32 by unknown with unknown Workshop:0x550</div></pre></td></tr></table></figure></p>
<p>在Solaris OS和Linux上，操作系统信息包含在文件/etc/*发行版中。此文件描述了运行应用程序的系统类型，在某些情况下，信息字符串可能包含修补程序级别。某些系统升级未反映在/etc/*发布文件中。在Linux系统上尤其如此，用户可以在其中重建系统的任何部分。</p>
<p>在Solaris OS上，uname系统调用用于获取内核的名称。 还会打印线程库（T1或T2）。</p>
<p>在Linux系统上，uname系统调用也用于获取内核名称。 还会打印libc版本和线程库类型。 一个例子如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">uname:Linux 2.4.18-3smp #1 SMP Thu Apr 18 07:27:31 EDT 2002 i686</div><div class="line"></div><div class="line">libc:glibc 2.2.5 stable linuxthreads (floating stack)</div><div class="line"></div><div class="line">    |&lt;- glibc version -&gt;|&lt;--  pthread type       --&gt;|</div></pre></td></tr></table></figure></p>
<p>在Linux上有三种可能的线程类型，即linuxthreads（固定栈），linuxthreads（浮动栈）和NPTL。它们通常安装在/lib，/lib/i686和/lib/tls中。</p>
<p>了解线程类型很有用。例如，如果crash似乎与pthread有关，那么你可以通过选择不同的pthread库来解决问题。可以通过设置LD_LIBRARY_PATH或LD_ASSUME_KERNEL来选择不同的pthread库（和libc）。</p>
<p>glibc版本通常不包括补丁级别。 rpm -q glibc命令可能会提供更详细的版本信息。</p>
<p>在Solaris OS和Linux上，下一个信息是rlimit信息。请注意，VM的默认栈大小通常小于系统限制，例子如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rlimit: STACK 8192k, CORE 0k, NPROC 4092, NOFILE 1024, AS infinity</div><div class="line">             |          |         |           |           virtual memory (-v)</div><div class="line">             |          |         |           +--- max open files (ulimit -n)</div><div class="line">             |          |         +----------- max user processes (ulimit -u)</div><div class="line">             |          +------------------------- core dump size (ulimit -c)</div><div class="line">             +---------------------------------------- stack size (ulimit -s)</div><div class="line">load average:0.04 0.05 0.02</div></pre></td></tr></table></figure></p>
<p>下一个信息指定VM在启动时标识的CPU体系结构和功能，如以下示例所示。</p>
<p>CPU:total 2 family 6, cmov, cx8, fxsr, mmx, sse | | |&lt;—– CPU features —-&gt;| | | | +— processor family (IA32 only): | 3 - i386 | 4 - i486 | 5 - Pentium | 6 - PentiumPro, PII, PIII | 15 - Pentium 4 +———— Total number of CPUs</p>
<p>下表显示了SPARC系统上可能的CPU功能。</p>
<h4 id="SPARC-Features"><a href="#SPARC-Features" class="headerlink" title="SPARC Features"></a>SPARC Features</h4><table>
<thead>
<tr>
<th><strong>SPARC Feature</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>has_v8</td>
<td>Supports v8 instructions.支持第8版指令</td>
</tr>
<tr>
<td>has_v9</td>
<td>Supports v9 instructions.支持第9版指令</td>
</tr>
<tr>
<td>has_vis1</td>
<td>Supports visualization instructions.支持可视化指令</td>
</tr>
<tr>
<td>has_vis2</td>
<td>Supports visualization instructions.支持可视化指令</td>
</tr>
<tr>
<td>is_ultra3</td>
<td>UltraSparc III.</td>
</tr>
<tr>
<td>no-muldiv</td>
<td>No hardware integer multiply and divide.没有硬件整数乘法和除法</td>
</tr>
<tr>
<td>no-fsmuld</td>
<td>No multiply-add and multiply-subtract instructions.没有乘加和乘减指令</td>
</tr>
</tbody>
</table>
<p>下表显示了Inter/IA32系统上可能的CPU功能。</p>
<h4 id="Intel-IA32-Features"><a href="#Intel-IA32-Features" class="headerlink" title="Intel/IA32 Features"></a>Intel/IA32 Features</h4><table>
<thead>
<tr>
<th><strong>Intel/IA32 Feature</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>cmov</td>
<td>Supports cmov instruction.支持cmov指令</td>
</tr>
<tr>
<td>cx8</td>
<td>Supports cmpxchg8b instruction.支持cmpxchg8b指令</td>
</tr>
<tr>
<td>fxsr</td>
<td>Supports fxsave and fxrstor.支持fssave和fxrstor</td>
</tr>
<tr>
<td>mmx</td>
<td>Supports MMX.支持MMX</td>
</tr>
<tr>
<td>sse</td>
<td>Supports SSE extensions.支持SSE扩展</td>
</tr>
<tr>
<td>sse2</td>
<td>Supports SSE2 extensions.支持SSE2扩展</td>
</tr>
<tr>
<td>ht</td>
<td>Supports Hyper-Threading Technology.支持超线程技术</td>
</tr>
</tbody>
</table>
<p>下表显示了AMD64/EM64T系统上可能的CPU功能。</p>
<h4 id="AMD64-EM64T-Features"><a href="#AMD64-EM64T-Features" class="headerlink" title="AMD64/EM64T Features"></a>AMD64/EM64T Features</h4><table>
<thead>
<tr>
<th><strong>AMD64/EM64T Feature</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>amd64</td>
<td>AMD Opteron, Athlon64, and so forth.AMD Opteron, Athlon64等</td>
</tr>
<tr>
<td>em64t</td>
<td>Intel EM64T processor.Inter EM64T处理器</td>
</tr>
<tr>
<td>3dnow</td>
<td>Supports 3DNow extension.支持3DNow扩展</td>
</tr>
<tr>
<td>ht</td>
<td>Supports Hyper-Threading Technology.支持超线程技术</td>
</tr>
</tbody>
</table>
<p>错误日志中下一个信息是内存信息，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">                                                        unused swap space</div><div class="line">                                total amount of swap space      |</div><div class="line">                      unused physical memory         |          |</div><div class="line">  total amount of physical memory     |              |          |</div><div class="line">       page size            |         |              |          |</div><div class="line">           v                v         v              v          v</div><div class="line">Memory: 4k page, physical 513604k(11228k free), swap 530104k(497504k free)</div></pre></td></tr></table></figure></p>
<p>某些系统要求交换空间至少是实际物理内存大小的两倍，而其他系统则没有任何此类要求。作为一般规则，如果物理内存和交换空间几乎都已满，则有充分的理由怀疑crash是由于内存不足造成的。</p>
<p>在Linux系统上，内核可以将大多数未使用的物理内存转换为文件缓存。当需要更多内存时，Linux内核会将缓存内存返回给应用程序。这由内核透明地处理，但它确实意味着当仍有足够的可用物理内存时，致命错误处理程序报告的未使用物理内存量可能接近于零。</p>
<p>错误日志的SYSTEM部分中的最终信息是vm_info，它是嵌入在libjvm.so/jvm.dll中的版本字符串。 每个Java VM都有自己唯一的vm_info字符串。 如果你对特定Java VM是否生成致命错误日志有疑问，请检查版本字符串。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengfu.io/2018/09/26/系统Crash问题排查/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="宁静·致远">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静·致远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/26/系统Crash问题排查/" itemprop="url">系统Crash问题排查</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-26T09:30:08+08:00">
                2018-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/09/26/系统Crash问题排查/" class="leancloud_visitors" data-flag-title="系统Crash问题排查">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>翻译：曲风富</p>
<p><em>译者注：本文翻译自Oracle官方文档，有一定英文能力者建议查看原文：</em><br><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/crashes.html" target="_blank" rel="external">https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/crashes.html</a></p>
<p>本章节提供针对系统crash诊断的某些特定过程的信息和指南。</p>
<p>崩溃或致命错误会导致进程异常退出。导致crash的原因有很多，比如HotSpot VM、系统库、Java SE库或API、应用本地代码甚至操作系统中的某个bug，都有可能会导致crash。外部因素，诸如系统资源耗尽也可能会导致crash。</p>
<p>由HotSpot VM或Java SE库中的代码中的bug引发的        比较少见。因此本章节将针对如何检查crash提供一些建议。在某些情况下，围绕一个crash现象努力直到bug被诊断出来并修复是有可能的。</p>
<p>通常分析crash的第一步是定位到致命错误的日志。这个日志是一个文本文件，是HotSpot VM在crash时生成的。如何定位到这个文件以及此日志的详细描述，请参见这篇文章：<a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html" target="_blank" rel="external">Appendix C, Fatal Error Log</a>。</p>
<h2 id="1-crash采样"><a href="#1-crash采样" class="headerlink" title="1 crash采样"></a>1 crash采样</h2><p>本节提供了一些演示如何使用error log去找到crash原因的例子。</p>
<h3 id="1-1-确定crash发生的位置"><a href="#1-1-确定crash发生的位置" class="headerlink" title="1.1 确定crash发生的位置"></a>1.1 确定crash发生的位置</h3><p>Crash日志的头部指出了有问题的帧。</p>
<p>如果帧类型是本地帧并且不是操作系统本地帧，那么说明问题可能出自本地库并且不是Java虚拟机导致。解决这种crash的第一步是查看crash发生处的本地帧的代码。根据本地库的代码，这里有3个选项：</p>
<ol>
<li>如果本地库由你的应用提供，那么请检查你的本地库的代码。-Xcheck:jni可以帮你很多本地bug。详情请见：<a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/clopts.html#gbmtq" target="_blank" rel="external">2.1 </a><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/clopts.html#gbmtq" target="_blank" rel="external">-Xcheck:jni</a><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/clopts.html#gbmtq" target="_blank" rel="external"> Option</a>；</li>
<li>如果你应用中使用的本地库由第三方提供，建议向第三方提供bug report，并提供致命错误日志；</li>
<li>如果本地库是JRE的一部分，那么请向Java社区提交bug report，并确保库的名称明确无误，以便bug report被分派给正确的开发人员。</li>
</ol>
<p>如果错误日志中的顶部帧信息显示是其他类型的帧，请向Java社区提交bug report、错误日志以及如何复现问题的相关信息。</p>
<p>另外，请参阅本章剩余的内容。</p>
<h2 id="1-2-本地代码中Crash"><a href="#1-2-本地代码中Crash" class="headerlink" title="1.2 本地代码中Crash"></a>1.2 本地代码中Crash</h2><p>如果致命错误日志显示crash发生在本地库，那么很有可能是本地代码或者JNI库代码中的bug导致。Crash当然也可能是其他的原因导致，但是对库、core文件、crash导出文件的分析是一个好的开端。例如，思考一下下面的从致命错误日志头部提取出来的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># An unexpected error has been detected by HotSpot Virtual Machine:</div><div class="line">#</div><div class="line">#  SIGSEGV (0xb) at pc=0x417789d7, pid=21139, tid=1024</div><div class="line">#</div><div class="line"># Java VM: Java HotSpot(TM) Server VM (6-beta2-b63 mixed mode)</div><div class="line"># Problematic frame:</div><div class="line"># C  [libApplication.so+0x9d7]</div></pre></td></tr></table></figure>
<p>在这个例子中，一个在libApplication.so库中执行的线程发生了SIGSEGV错误。</p>
<p>在某些场景中某个本地库中的bug显示在Java虚拟机中crash。请看下面的crash：一个Java线程在_thread_in_vm状态下失败(即它在Java VM代码中执行)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># An unexpected error has been detected by HotSpot Virtual Machine:</div><div class="line">#</div><div class="line">#  EXCEPTION_ACCESS_VIOLATION (0xc0000005) at pc=0x08083d77, pid=3700, tid=2896</div><div class="line">#</div><div class="line"># Java VM: Java HotSpot(TM) Client VM (1.5-internal mixed mode)</div><div class="line"># Problematic frame:</div><div class="line"># V  [jvm.dll+0x83d77]</div><div class="line"></div><div class="line">---------------  T H R E A D  ---------------</div><div class="line"></div><div class="line">Current thread (0x00036960):  JavaThread &amp;quot;main&amp;quot; [_thread_in_vm, id=2896]</div><div class="line"> :</div><div class="line">Stack: [0x00040000,0x00080000),  sp=0x0007f9f8,  free space=254k</div><div class="line">Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)</div><div class="line">V  [jvm.dll+0x83d77]</div><div class="line">C  [App.dll+0x1047]          &lt;========= C/native frame</div><div class="line">j  Test.foo()V+0</div><div class="line">j  Test.main([Ljava/lang/String;)V+0</div><div class="line">v  ~StubRoutines::call_stub</div><div class="line">V  [jvm.dll+0x80f13]</div><div class="line">V  [jvm.dll+0xd3842]</div><div class="line">V  [jvm.dll+0x80de4]</div><div class="line">V  [jvm.dll+0x87cd2]</div><div class="line">C  [java.exe+0x14c0]</div><div class="line">C  [java.exe+0x64cd]</div><div class="line">C  [kernel32.dll+0x214c7]</div><div class="line"> :</div></pre></td></tr></table></figure>
<p>在这个case中，栈跟踪显示一个在App.dll中的本地程序调用了VM(可能通过JNI)。</p>
<p>如果你遇到了一个在本地库中的crash(如上面所述的例子)，如果可能的话，你可以使用本地的调试程序链接到core文件或者crash导出文件。本地调试程序有dbx、gdb或windbg，因操作系统而异。</p>
<p>另一个方法是在启动时将-Xcheck:jni添加到启动命令行中(参见<a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/clopts.html#gbmtq" target="_blank" rel="external">B.2.1 </a><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/clopts.html#gbmtq" target="_blank" rel="external">-Xcheck:jni</a><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/clopts.html#gbmtq" target="_blank" rel="external"> Option</a>)。这个选项不保证发现所有的JNI代码中的问题，但它可以帮你定位到很多的问题。</p>
<p>如果crash的本地库是Java运行环境的一部分(如awt.dll, net.dll等)，那么很可能你遇到了一个Java库或API的bug。如果经过进一步分析之后你断定这是个Java库或API的bug，请收集尽可能多的数据并提交bug或寻求Java技术支持。详情参见<a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/bugreports.html" target="_blank" rel="external">Chapter 7, Submitting Bug Reports</a>。</p>
<h3 id="1-3-栈溢出导致Crash"><a href="#1-3-栈溢出导致Crash" class="headerlink" title="1.3 栈溢出导致Crash"></a>1.3 栈溢出导致Crash</h3><p>Java语言代码中的栈溢出(也叫爆栈)会导致线程抛出java.lang.StackOverflowError。换句话说，C和C++写入时达到了栈的末尾并且引发了栈溢出。这个致命错误导致了进程终止。</p>
<p>在HotSpot实现中，Java方法与C/C++本地代码共享栈帧，也就是用户本地代码和虚拟机本身。Java方法生成代码来检查栈空间有可用的到栈尾的固定距离，来确保本地代码在不超出栈空间的情况下能够被执行。这个到栈尾的距离被称为”Shadow Pages”。这个距离是可调节的，这样应用需要比默认值更大的距离时就可以增加Shadow page的尺寸。增大Shadow pages的选项是-XX:StackShadowpages=<em>n</em>，n的值要大于shadow pages在当前平台下的默认值。</p>
<p>如果你的应用出现了分段错误，而且没有生成core文件或error日志(见<a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/felog.html" target="_blank" rel="external">Appendix C, Fatal Error Log</a>)或在Windows系统中发现STACK_OVERFLOW_ERROR或”An irrecoverable stack overflow has occurred”消息，这说明StackShadowPages已经耗尽需要扩容。</p>
<p>如果你想要增大StackShadowPages 的值，你也需要使用-Xss参数增加默认线程栈大小。增加线程栈大小可能会导致能够创建的线程数的减少。默认线程栈大小根据平台差异从256K到1024K不等。</p>
<p>下面的代码片段来自于Windows系统的一个致命错误日志，其中的一个线程引发了本地代码中的栈溢出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># An unexpected error has been detected by HotSpot Virtual Machine:</div><div class="line">#</div><div class="line">#  EXCEPTION_STACK_OVERFLOW (0xc00000fd) at pc=0x10001011, pid=296, tid=2940</div><div class="line">#</div><div class="line"># Java VM: Java HotSpot(TM) Client VM (1.6-internal mixed mode, sharing)</div><div class="line"># Problematic frame:</div><div class="line"># C  [App.dll+0x1011]</div><div class="line">#</div><div class="line"></div><div class="line">---------------  T H R E A D  ---------------</div><div class="line"></div><div class="line">Current thread (0x000367c0):  JavaThread &amp;quot;main&amp;quot; [_thread_in_native, id=2940]</div><div class="line">:</div><div class="line">Stack: [0x00040000,0x00080000),  sp=0x00041000,  free space=4k</div><div class="line">Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)</div><div class="line">C  [App.dll+0x1011]</div><div class="line">C  [App.dll+0x1020]</div><div class="line">C  [App.dll+0x1020]</div><div class="line">:</div><div class="line">C  [App.dll+0x1020]</div><div class="line">C  [App.dll+0x1020]</div><div class="line">...&lt;more frames&gt;...</div><div class="line"></div><div class="line">Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)</div><div class="line">j  Test.foo()V+0</div><div class="line">j  Test.main([Ljava/lang/String;)V+0</div><div class="line">v  ~StubRoutines::call_stub</div></pre></td></tr></table></figure></p>
<p>下面是上面的日志包含的信息：</p>
<ul>
<li>异常是EXCEPTION_STACK_OVERFLOW；</li>
<li>线程的状态是_thread_in_native，说明线程正在执行本地或者JNI代码；</li>
<li>栈信息显示，栈的可用空间是4K(Windows中单页的大小)。另外，栈指针(Stack pointer, sp)在0x00041000的位置，已经很接近栈尾了(0x00040000)(译者注: java线程栈是从高地址往低地址方向走的)；</li>
<li>本地帧的输出显示一个递归的本地函数是这个case的问题；</li>
<li>标注…<more frames="">…表明还有更多的帧存在但没有被输出。最多可输出100帧。</more></li>
</ul>
<p><em>译者注：关于栈溢出的问题，感兴趣的同学可以进一步阅读这篇文章：</em><a href="https://www.jianshu.com/p/debef4f69a90" target="_blank" rel="external">https://www.jianshu.com/p/debef4f69a90</a>。</p>
<h3 id="1-4-HotSpot编译线程中Crash"><a href="#1-4-HotSpot编译线程中Crash" class="headerlink" title="1.4 HotSpot编译线程中Crash"></a>1.4 HotSpot编译线程中Crash</h3><p>如果错误日志中显示crash时当前Java线程的名称是CompilerThread0, CompilerThread1, 或AdapterCompiler，那么可能你遇到了一个编译bug。这种情况下你有必要临时性地切换编译器(例如把HotSpot Server VM替换成HotSpot Client VM，反之亦然)，或者将引发crash的方法从编译过程中排除。详情见：<a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/crashes.html#gbyzd" target="_blank" rel="external">4.2.1 Crash in HotSpot Compiler Thread or Compiled Code</a>。</p>
<h3 id="1-5-编译的代码中Crash"><a href="#1-5-编译的代码中Crash" class="headerlink" title="1.5 编译的代码中Crash"></a>1.5 编译的代码中Crash</h3><p>如果编译的代码中发生crash，那么你可能遇到了编译器bug导致了错误的代码生成的问题。你可以识别出一个在被编译的代码中出现的crash，如果有问题的帧被标注为代码J(代表被编译的Java帧)。下面是一个这样的crash例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># An unexpected error has been detected by HotSpot Virtual Machine:</div><div class="line">#</div><div class="line">#  SIGSEGV (0xb) at pc=0x0000002a99eb0c10, pid=6106, tid=278546</div><div class="line">#</div><div class="line"># Java VM: Java HotSpot(TM) 64-Bit Server VM (1.6.0-beta-b51 mixed mode)</div><div class="line"># Problematic frame:</div><div class="line"># J  org.foobar.Scanner.body()V</div><div class="line">#</div><div class="line">:</div><div class="line">Stack: [0x0000002aea560000,0x0000002aea660000),  sp=0x0000002aea65ddf0,</div><div class="line">  free space=1015k</div><div class="line">Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)</div><div class="line">J  org.foobar.Scanner.body()V</div><div class="line"></div><div class="line">[error occurred during error reporting, step 120, id 0xb]</div></pre></td></tr></table></figure></p>
<p>需要注意的是一个完整的线程栈无法提供。输出行”error occurred during error reporting”表示在尝试获得栈跟踪的时候出错了(本示例中可能是栈损坏)。</p>
<p>这种情况下你有必要临时性地切换编译器(例如把HotSpot Server VM替换成HotSpot Client VM，反之亦然)，或者将引发crash的方法从编译过程中排除。在本示例中，不太可能将编译器将64位Server VM切换，因为将其切换至32位Client VM不太可行。</p>
<h3 id="1-6-VMThread中Crash"><a href="#1-6-VMThread中Crash" class="headerlink" title="1.6 VMThread中Crash"></a>1.6 VMThread中Crash</h3><p>如果log输出显示当前线程是VMThread，那么请在日志中的THREAD区域寻找包含VM_Operation的行。VMThread是HotSpot虚拟机中一个特殊的线程。它向虚拟机中提交诸如GC这种特殊的任务。如果VM_Operation显示其操作是垃圾回收，那么很有可能你遇到了诸如堆损坏的问题。</p>
<p>Crash也有可能有GC问题引起，但这可以等价于一些其他问题(比如编译器或运行期bug)导致堆中的对象引用处于不连续或者不正确的状态。在这个场景中，尽可能多地收集与环境相关的信息，并尝试可能的替代方案。如果这个问题是GC相关，你可能需要临时性地修改GC配置作为替代方案。这方面的内容在<a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/crashes.html#gbyzq" target="_blank" rel="external">4.2.2 Crash During Garbage Collection</a>中有讨论。</p>
<h2 id="2-寻求替代方案"><a href="#2-寻求替代方案" class="headerlink" title="2 寻求替代方案"></a>2 寻求替代方案</h2><p>如果是重要的应用发生了crash，并且是由HotSpot VM中的bug引发，那么你应该快速寻找一个替代方案。本节的目标是给出一些可能的替代方案。如果crash的应用是部署在JDK最近的发布版本上，那么这个crash事件应该报告给Oracle。</p>
<p>如果关键应用程序发生崩溃，并且崩溃似乎是由HotSpot VM中的错误引起的，那么可能需要快速找到临时解决方法。 本节的目的是提出一些可能的解决方法。 如果使用最新版本的JDK部署的应用程序发生崩溃，则应始终向Oracle报告崩溃</p>
<p><em>注意 - 即使本节中的相关内容成功消除了崩溃，但是问题的解决方案不是固定的，而是临时解决方案。 寻求电话支持或提交包含了能说明问题的原始配置的BUG报告。</em></p>
<h3 id="2-1-在HotSpot编译线程或编译代码中crash"><a href="#2-1-在HotSpot编译线程或编译代码中crash" class="headerlink" title="2.1 在HotSpot编译线程或编译代码中crash"></a>2.1 在HotSpot编译线程或编译代码中crash</h3><p>如果致命错误日志显示crash发生在编译器线程中, 则可能是遇到了编译器 bug (但并非总是如此)。同样, 如果在编译后的代码中crash, 则可能是因为编译器生成了不正确的代码所致。</p>
<p>在HotSpot VM (-client选项) 的情况下, 编译器线程以 CompilerThread0 的形式出现在错误日志中。在HotSpot Server VM中, 则有多个编译器线程, 它们在错误日志文件中显示为 CompilerThread0、CompilerThread1 和 AdapterThread。</p>
<p>下面是 J2SE 5.0 开发过程中遇到和修复的编译器bug的错误日志片段。日志文件显示使用了HotSpot Server VM, 并且崩溃发生在 CompilerThread1 中。此外, 日志文件显示当前 CompileTask 是 java.lang.Thread.setPriority方法的编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># An unexpected error has been detected by HotSpot Virtual Machine:</div><div class="line">#</div><div class="line">:</div><div class="line"># Java VM: Java HotSpot(TM) Server VM (1.5-internal-debug mixed mode)</div><div class="line">:</div><div class="line">---------------  T H R E A D  ---------------</div><div class="line"></div><div class="line">Current thread (0x001e9350): JavaThread &quot;CompilerThread1&quot; daemon [_thread_in_vm, id=20]</div><div class="line"></div><div class="line">Stack: [0xb2500000,0xb2580000),  sp=0xb257e500,  free space=505k</div><div class="line"></div><div class="line">Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)</div><div class="line"></div><div class="line">V  [libjvm.so+0xc3b13c]</div><div class="line">:</div><div class="line"></div><div class="line">Current CompileTask:</div><div class="line">opto: 11      java.lang.Thread.setPriority(I)V (53 bytes)</div><div class="line"></div><div class="line">---------------  P R O C E S S  ---------------</div><div class="line"></div><div class="line">Java Threads: ( =&gt; current thread )</div><div class="line">  0x00229930 JavaThread &quot;Low Memory Detector&quot; daemon [_thread_blocked, id=21]</div><div class="line">=&gt;0x001e9350 JavaThread &quot;CompilerThread1&quot; daemon [_thread_in_vm, id=20]</div><div class="line"> :</div></pre></td></tr></table></figure></p>
<p>在这种情况下, 有两种潜在的变通方法：</p>
<ul>
<li>蛮力方法: 更改jvm配置, 以便使用-client选项运行应用程序以指定HotSpot Client VM;</li>
<li>假定bug仅在setPriority方法的编译过程中发生, 并将此方法从编译中排除。</li>
</ul>
<p>在某些环境中配置第一种方法（使用-client选项）可能很简单。在其他情况下，如果配置复杂或者无法轻松访问配置VM的命令行，则可能会更加困难。通常，从HotSpot Server VM切换到HotSpot Client VM也会降低应用程序的峰值性能。 根据环境的不同，在诊断和修复实际问题之前，这可能是可以接受的。</p>
<p>第二种方法（从编译中排除方法）需要在应用程序的工作目录中创建文件.hotspot_compiler。 以下是此文件的示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exclude    java/lang/Thread    setPriority</div></pre></td></tr></table></figure></p>
<p>通常，此文件的格式为exclude CLASS METHOD，其中CLASS是类（使用包名称完全限定），METHOD是方法的名称。构造方法指定为<init>，静态初始化程序指定为<clinit>。</clinit></init></p>
<p>_注意 - .HOTSPOT<em>COMPILER文件是一个不受支持的接口。 此处仅为了故障排除和查找临时解决方案而对其进行了文档记录。</em></p>
<p>重新启动应用程序后，编译器将不会尝试编译.hotspot_compiler文件中列出的任何排除方法。在某些情况下，这可以提供临时缓解，直到诊断出崩溃的根本原因并修复错误</p>
<p>为了验证HotSpot VM是否正确定位并处理了上述示例中显示的.hotspot_compiler文件，请在运行时查找以下日志信息。请注意，文件名分隔符是一个点，而不是斜杠。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">### Excluding compile:    java.lang.Thread::setPriority</div></pre></td></tr></table></figure></p>
<h3 id="2-2-GC时crash"><a href="#2-2-GC时crash" class="headerlink" title="2.2 GC时crash"></a>2.2 GC时crash</h3><p>如果在垃圾回收（GC）期间发生崩溃，则致命错误日志会报告VM_Operation正在进行中。出于本讨论的目的，假设大多数并发GC（-XX：+ UseConcMarkSweep）未使用。VM_Operation显示在日志的THREAD部分中，表示以下情况之一：</p>
<ul>
<li>用于分配的生成集合</li>
<li>全集代收藏</li>
<li>并行gc分配失败</li>
<li>并行gc未能永久分配</li>
<li>并行gc系统gc</li>
</ul>
<p>很可能日志中报告的当前线程是VMThread。 这是用于在HotSpot VM中执行特殊任务的特殊线程。 致命错误日志的以下片段显示了串行垃圾收集器中崩溃的示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">---------------  T H R E A D  ---------------</div><div class="line"></div><div class="line">Current thread (0x002cb720):  VMThread [id=3252]</div><div class="line"></div><div class="line">siginfo: ExceptionCode=0xc0000005, reading address 0x00000000</div><div class="line"></div><div class="line">Registers:</div><div class="line">EAX=0x0000000a, EBX=0x00000001, ECX=0x00289530, EDX=0x00000000</div><div class="line">ESP=0x02aefc2c, EBP=0x02aefc44, ESI=0x00289530, EDI=0x00289530</div><div class="line">EIP=0x0806d17a, EFLAGS=0x00010246</div><div class="line"></div><div class="line">Top of Stack: (sp=0x02aefc2c)</div><div class="line">0x02aefc2c:   00289530 081641e8 00000001 0806e4b8</div><div class="line">0x02aefc3c:   00000001 00000000 02aefc9c 0806e4c5</div><div class="line">0x02aefc4c:   081641e8 081641c8 00000001 00289530</div><div class="line">0x02aefc5c:   00000000 00000000 00000001 00000001</div><div class="line">0x02aefc6c:   00000000 00000000 00000000 08072a9e</div><div class="line">0x02aefc7c:   00000000 00000000 00000000 00035378</div><div class="line">0x02aefc8c:   00035378 00280d88 00280d88 147fee00</div><div class="line">0x02aefc9c:   02aefce8 0806e0f5 00000001 00289530</div><div class="line">Instructions: (pc=0x0806d17a)</div><div class="line">0x0806d16a:   15 08 83 3d c0 be 15 08 05 53 56 57 8b f1 75 0f</div><div class="line">0x0806d17a:   0f be 05 00 00 00 00 83 c0 05 a3 c0 be 15 08 8b</div><div class="line"></div><div class="line">Stack: [0x02ab0000,0x02af0000),  sp=0x02aefc2c,  free space=255k</div><div class="line"></div><div class="line">Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)</div><div class="line">V  [jvm.dll+0x6d17a]</div><div class="line">V  [jvm.dll+0x6e4c5]</div><div class="line">V  [jvm.dll+0x6e0f5]</div><div class="line">V  [jvm.dll+0x71771]</div><div class="line">V  [jvm.dll+0xfd1d3]</div><div class="line">V  [jvm.dll+0x6cd99]</div><div class="line">V  [jvm.dll+0x504bf]</div><div class="line">V  [jvm.dll+0x6cf4b]</div><div class="line">V  [jvm.dll+0x1175d5]</div><div class="line">V  [jvm.dll+0x1170a0]</div><div class="line">V  [jvm.dll+0x11728f]</div><div class="line">V  [jvm.dll+0x116fd5]</div><div class="line">C  [MSVCRT.dll+0x27fb8]</div><div class="line">C  [kernel32.dll+0x1d33b]</div><div class="line"></div><div class="line">VM_Operation (0x0373f71c): generation collection for allocation, mode:</div><div class="line"></div><div class="line"> safepoint, requested by thread 0x02db7108</div></pre></td></tr></table></figure></p>
<p><em>注意 - 垃圾收集期间的crash并不意味着这是垃圾收集过程中的一个BUG。它还可能指向编译器或运行时错误或其他一些问题。</em></p>
<p>如果在垃圾回收期间遇到重复崩溃，您可以尝试以下变通方法：</p>
<ul>
<li>切换GC配置。 例如，如果您使用的是串行收集器，请尝试使用吞吐量收集器，反之亦然；</li>
<li>如果您使用的是HotSpot Server VM，请尝试使用HotSpot Client VM。</li>
</ul>
<p>如果您不确定正在使用哪个垃圾收集器，则可以使用Solaris OS和Linux上的jmap实用程序（请参阅<a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/tooldescr.html#gbdid" target="_blank" rel="external">2.7 </a><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/tooldescr.html#gbdid" target="_blank" rel="external">jmap</a><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/tooldescr.html#gbdid" target="_blank" rel="external"> Utility</a>）从核心文件获取堆信息（如果核心文件可用）。 通常，如果未在命令行中指定GC配置，则将在Windows上使用串行收集器。 在Solaris OS和Linux上，它取决于计算机配置。 如果机器至少有2GB内存且至少有2个处理器，则将使用吞吐量收集器（并行GC）。 对于较小的机器，串行收集器是默认的。选择串行收集器的选项是-XX:+UseSerialGC和选择吞吐量收集器的选项是-XX:+UseParallelGC。 如果作为解决方法，您从吞吐量收集器切换到串行收集器，那么您可能会在多处理器系统上遇到性能下降。 在诊断和解决根问题之前，这可能是可以接受的。</p>
<h2 id="2-3-Class数据共享时crash"><a href="#2-3-Class数据共享时crash" class="headerlink" title="2.3 Class数据共享时crash"></a>2.3 Class数据共享时crash</h2><p>类数据共享是J2SE 5.0中的一项新功能。 使用Sun提供的安装程序在32位平台上安装JRE时，安装程序会将一组类从系统JAR文件加载到专用内部表示形式，并将该表示形式转储到名为共享存档的文件中。 启动VM时，共享存档将进行内存映射。这样可以节省类加载，并允许在多个VM实例之间共享与类关联的大部分元数据。 在J2SE 5.0中，仅在使用HotSpot Client VM时才启用类数据共享。 此外，只有串行垃圾收集器才支持共享。</p>
<p>致命错误日志在日志标题中打印版本字符串。 如果启用了共享，则由文本共享指示，如以下示例所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># An unexpected error has been detected by HotSpot Virtual Machine:</div><div class="line">#</div><div class="line">#  EXCEPTION_ACCESS_VIOLATION (0xc0000005) at pc=0x08083d77, pid=3572, tid=784</div><div class="line">#</div><div class="line"># Java VM: Java HotSpot(TM) Client VM (1.5-internal mixed mode, sharing)</div><div class="line"># Problematic frame:</div><div class="line"># V  [jvm.dll+0x83d77]</div></pre></td></tr></table></figure></p>
<p>可以通过在命令行上提供-Xshare:off选项来禁用共享。 如果在禁用共享的情况下无法复制崩溃但可以在启用共享的情况下复制崩溃，则可能是您遇到此功能中的错误。在这种情况下，尽可能多地收集信息并提交错误报告。</p>
<h2 id="3-微软C-版本的考虑"><a href="#3-微软C-版本的考虑" class="headerlink" title="3 微软C++版本的考虑"></a>3 微软C++版本的考虑</h2><p>JDK 7软件是在Windows上使用Microsoft Visual Studio 2010专业版为32位和64位平台构建的。如果遇到Java 应用程序崩溃, 并且你有使用不同版本的编译器编译的本地或JNI库, 则必须考虑运行时之间的兼容性问题。具体地说, 只有在处理多个运行时时遵循Microsoft准则时, 才会支持你的环境。例如, 如果你使用一个运行时分配内存, 则必须使用同一运行时释放它。如果使用不同的库释放资源, 而不是分配资源时所使用的库, 则可能会出现不可预知的行为或崩溃。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengfu.io/2018/08/20/JToolkit-Java问题排查工具箱/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="宁静·致远">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静·致远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/JToolkit-Java问题排查工具箱/" itemprop="url">JToolkit:Java问题排查工具箱</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T17:51:40+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/08/20/JToolkit-Java问题排查工具箱/" class="leancloud_visitors" data-flag-title="JToolkit:Java问题排查工具箱">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于JToolkit"><a href="#关于JToolkit" class="headerlink" title="关于JToolkit"></a>关于JToolkit</h1><p><img src="https://farm2.staticflickr.com/1818/43432185524_a2f20ef41e_o.png" alt="JToolkit"><br>JToolkit是一个Java问题排查的工具集，通过集成各种Linux命令、Shell脚本、Java命令，以及各种第三方好用的工具，通过傻瓜式的界面和方便快捷的操作来帮助我们快速定位问题。目前已经集成了唯品会的 <a href="https://github.com/vipshop/vjtools/tree/master/vjtop" target="_blank" rel="external">VjTop</a>、<a href="https://github.com/jvm-profiling-tools/async-profiler" target="_blank" rel="external">Async-Profiler</a>。</p>
<h1 id="包含的功能"><a href="#包含的功能" class="headerlink" title="包含的功能"></a>包含的功能</h1><h2 id="1-CPU-LOAD问题分析"><a href="#1-CPU-LOAD问题分析" class="headerlink" title="1.CPU/LOAD问题分析"></a>1.CPU/LOAD问题分析</h2><ol>
<li>显示Java线程栈的CPU时间占比</li>
<li>线程CPU时间占比排行(VJTop)</li>
<li>生成火焰图(10分钟)</li>
<li>生成飞行记录JFR(10分钟)</li>
</ol>
<h2 id="2-GC问题分析"><a href="#2-GC问题分析" class="headerlink" title="2.GC问题分析"></a>2.GC问题分析</h2><ol>
<li>FullGC时间久</li>
<li>FullGC不断</li>
<li>FullGC频繁</li>
<li>YoungGC时间久</li>
<li>远程分析gc.log</li>
</ol>
<h2 id="3-Swap问题"><a href="#3-Swap问题" class="headerlink" title="3.Swap问题"></a>3.Swap问题</h2><ol>
<li>统计各进程Swap使用情况</li>
<li>关闭Swap</li>
</ol>
<h2 id="4-内存问题"><a href="#4-内存问题" class="headerlink" title="4.内存问题"></a>4.内存问题</h2><ol>
<li>堆内存使用情况</li>
<li>对象实例统计Top10</li>
<li>dump堆内存</li>
</ol>
<h2 id="5-JVM参数"><a href="#5-JVM参数" class="headerlink" title="5.JVM参数"></a>5.JVM参数</h2><ol>
<li>JVM参数检查</li>
<li>JVM参数生成</li>
</ol>
<h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><h2 id="1-copy脚本"><a href="#1-copy脚本" class="headerlink" title="1.copy脚本"></a>1.copy脚本</h2><p>在有写入权限的目录下执行以下脚本即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir jtoolkit &amp;&amp; cd jtoolkit &amp;&amp; wget --no-cache --no-check-certificate https://raw.githubusercontent.com/fengfu/jtoolkit/master/jtoolkit.sh &amp;&amp; source jtoolkit.sh</div></pre></td></tr></table></figure></p>
<h2 id="2-运行SecureCRT-Script"><a href="#2-运行SecureCRT-Script" class="headerlink" title="2.运行SecureCRT Script"></a>2.运行SecureCRT Script</h2><p>使用SecureCRT的同学可以下载<a href="http://fengfu.io/attach/run_jtoolkit.py">run_jtoolkit.py</a>文件到自己的机器上，通过[Script]-[Run]功能运行此下载的文件。</p>
<p>另外，某些脚本需要sudo权限，所以请确保您在运行的服务器上已经申请到了sudo权限。</p>
<h1 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h1><p>欢迎移步<a href="https://github.com/fengfu/jtoolkit/issues" target="_blank" rel="external">https://github.com/fengfu/jtoolkit/issues</a> 拍砖~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengfu.io/2018/06/27/重计算型应用的性能优化实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="宁静·致远">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静·致远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/27/重计算型应用的性能优化实践/" itemprop="url">重计算型应用的性能优化实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-27T20:23:47+08:00">
                2018-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/06/27/重计算型应用的性能优化实践/" class="leancloud_visitors" data-flag-title="重计算型应用的性能优化实践">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="系统介绍"><a href="#系统介绍" class="headerlink" title="系统介绍"></a>系统介绍</h1><p>ATPCO系统是Qunar国际机票的运价系统，它通过美国ATPCO公司接收全球近500家航空公司的运价、规则数据进行计算，为上层的机票搜索系统提供运价搜索服务。系统的基础数据主要分为运价、规则、航路等数据，其中运价数据有9000万条，规则数据有1.2亿条，平均每条运价关联20条规则数据。规则数据分为Record 0/1/2/3/6/8六大类，其中Record3数据又包含Category1~Category50几十种子规则，以及Table 900系列的若干表、Category 10下面的各种子表。所以业务规则复杂，数据量大是这个系统的一大特点。</p>
<p>ATPCO系统的另外一个特点是计算量大。我们以北京-香港，2018年7月1日的单程搜索为例来粗略估算一下搜索发生时系统的计算量：</p>
<ol>
<li>航路数量（中转点，如上海、厦门等）：5</li>
<li>运价数量：500</li>
<li>航班数量：20</li>
<li>舱位数量：10</li>
<li>舱位规则：2</li>
</ol>
<p>上述因素之间是叉乘的关系，所以总的计算量=5<em>500</em>20<em>10</em>2=1000000。也就是单次搜索产生的计算量是100万，而且这只是单程的部分计算，还没有考虑addon、两次中转……。在这种情况的，即便我们使用了24核的物理机并发计算，系统的压力依然很大。下图是我们用vmstat命令查看到的CPU运行队列的情况，也可以看到在处理请求时，CPU的运行队列都超过了CPU Processor数量。<br><img src="https://farm2.staticflickr.com/1801/29186903928_b456246c61_o.png" alt="计算压力大"></p>
<p>所以，系统上线初期，系统响应比较慢，单程平均响应时间500ms，往返多达1500ms，部分往返搜索甚至超时。</p>
<h1 id="问题分析及应对策略"><a href="#问题分析及应对策略" class="headerlink" title="问题分析及应对策略"></a>问题分析及应对策略</h1><p>  在积累了一段时间的运行数据的基础上，结合业务的特点，我们对系统性能较低的原因进行分析，总结有以下几点：</p>
<ol>
<li>代码存在瓶颈：如锁等待（如早期QMonitor中的synchronized）、代码效率低（如频繁从InfoCenter中获取机场信息）等；</li>
<li>计算量太大：一次搜索的计算量太大，线程超时严重，尤其是往返的计算；</li>
<li>部分计算流程不合理：如有些互相没有依赖的逻辑串行处理、CPU核心忙闲不均拖慢整体响应时间；</li>
<li><p>其他因素：GC停顿、外部依赖性能低</p>
<p>针对上述的问题，我们采用了不同的方案来解决。当然从事后诸葛亮的角度来总结，我们借鉴了2个法则的思想来进行系统性能的提升：针对问题1和问题2，我们可以使用利特尔法则解决；针对问题3，可以利用阿姆达尔定律来解决。</p>
</li>
</ol>
<h1 id="利特尔法则实践"><a href="#利特尔法则实践" class="headerlink" title="利特尔法则实践"></a>利特尔法则实践</h1><p><img src="https://farm1.staticflickr.com/842/29186903118_3f75fe5e44_o.png" alt="利特尔法则"></p>
<p>利特尔法则由麻省理工大学斯隆商学院（MIT Sloan School of Management）的教授John Little于1961年所提出与证明，其英文名称为：Little’s Law。利特尔法则是一个有关提前期与在制品关系的简单数学公式，这一法则为精益生产的改善方向指明了道路。如何有效地缩短生产周期呢？道理很简单：一个方向是提高单位效率，另一个方向就是降低任务数量。</p>
<p>  所以基于利特尔法则，我们对系统优化的工作就沿着2个方向前进：</p>
<ol>
<li>提高代码性能，这里是我们努力的主要方向；</li>
<li>减少计算量：也就是剪枝。</li>
</ol>
<h2 id="提高代码性能"><a href="#提高代码性能" class="headerlink" title="提高代码性能"></a>提高代码性能</h2><p>  要提高代码性能，首要的工作就是找到代码中耗时比较久的地方，也就是“热点”。这里我们使用了JMC(Java Mission Control)来查找热点。通过热点分析，我们做了以下4个方面的改进：</p>
<h3 id="减少字符串使用"><a href="#减少字符串使用" class="headerlink" title="减少字符串使用"></a>减少字符串使用</h3><p>因为需要降低内存占用的缘故，系统中将部分的字符串转成了int/long在堆内存储，这同时也带来了一个好处就是提高了字符串的操作效率，毕竟相比String，int/long的执行效率要高一些。当然String转int/long这种方式比较适合大量存储且不需要频繁转换的场景，所以要慎用。</p>
<h3 id="减少-避免低性能的使用方式"><a href="#减少-避免低性能的使用方式" class="headerlink" title="减少/避免低性能的使用方式"></a>减少/避免低性能的使用方式</h3><p>为提升性能，代码中尽量避免低性能的使用方式。比如String.split方法，因为支持正则的缘故而性能偏低，而我们的场景中很少使用正则，所以我们就换成了Guava Splitter；比如尽量避免使用BigDecimal这种为保证精度而牺牲一定性能的类，如果必须使用，那么也优先使用BigDecimal.valueOf方法而不是new BigDecimal()这种方式；再比如要求集合、StringBuilder在使用前必须指定初始化容量，避免扩容造成的内存浪费，从而减少GC时间；</p>
<h3 id="减少IO阻塞、锁等待"><a href="#减少IO阻塞、锁等待" class="headerlink" title="减少IO阻塞、锁等待"></a>减少IO阻塞、锁等待</h3><p>IO阻塞、锁等待是系统性能提升的大敌。对于减少IO阻塞，一个典型的例子就是减少日志的打印以及调整日志组件的配置。虽然我们的系统中使用了异步方式打印日志，但当日志量比较大的时候，依然可能引起日志的阻塞。所以我们的策略是减少不必要的日志打印。同时，为避免logback阻塞主线程，我们将其neverBlock属性设置为true，允许丢失一部分非关键日志，但换来的好处就是不会因为日志打印而阻塞主线程。</p>
<p>另外，通过热点查找，我们还定位到了当时使用的监控组件存在锁等待的问题，并推动相关团队进行了改进。</p>
<h3 id="提高缓存效率"><a href="#提高缓存效率" class="headerlink" title="提高缓存效率"></a>提高缓存效率</h3><p>由于系统大量使用了缓存，在进行优化的过程中，我们一度发现使用的Guava Cache也成了热点，于是我们也寻求了解决方案。通过搜索引擎和github，我们发现Caffeine宣称拥有比Guava Cache高几倍的读写效率，于是我们进行了测试和试用，发现在我们的应用场景下（读多写少），Caffeine的性能确实要好于Guava Cache。所以我们最终采用Caffeine作为了本地缓存方案。对于Caffeine Cache，感兴趣的同学可以通过文末给出的链接进行了解。</p>
<p><img src="https://farm1.staticflickr.com/915/29186902638_e35dfe8085.jpg" alt="写性能比较"></p>
<p><img src="https://farm2.staticflickr.com/1830/29186902838_5cc48606ed.jpg" alt="读性能比较"></p>
<h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>在对代码性能进行充分压榨后，我们依然无法解决往返计算时间太长甚至超时的问题，原因在于往返的去程、回程航班组合存在笛卡尔积的缘故，导致往返的计算量比单程要多2个数量级。</p>
<p>在无法对程序性能做进一步榨取的情况下，我们开始考虑在庞大的计算量中进行取舍。前面我们提到了，初期的系统对往返去程、回程的航班组合比较粗放，采取笛卡尔积的方式，如下图：</p>
<p><img src="https://farm2.staticflickr.com/1765/29186900328_4fd30c972b_o.png" alt="笛卡尔积"></p>
<p>这样带来的结果就是航班组合数量非常庞大，系统处理不过来。所以我们将去程、回程航班以价格进行排序，在去程航班的基础上选取回程航班，如下图所示：</p>
<p><img src="https://farm2.staticflickr.com/1830/43009227712_95539402cc_o.png" alt="航班组合优化"></p>
<p>通过这样的优化，往返搜索需要处理的航班组合数量减少了50%以上，搜索超时的量也减少了30%以上。</p>
<p>当然，在剪枝的层面上的优化，我们还是比较保守的，毕竟这需要强大的业务及分析能力做后盾才有能力取得比较好的成果。在剪枝策略上，携程的引擎团队做得比我们要激进得多，但效果也好很多。他们将航班组合剪枝到了我们的20%，但对业务的影响小到可以忽略。因此在这一点上，我们需要向他们好好学习。</p>
<h1 id="阿姆达尔定律实践"><a href="#阿姆达尔定律实践" class="headerlink" title="阿姆达尔定律实践"></a>阿姆达尔定律实践</h1><p>阿姆达尔定律（英语：Amdahl’s law，Amdahl’s argument），一个计算机科学界的经验法则，因吉恩·阿姆达尔(Gene Amdahl)而得名。它代表了处理器平行运算之后效率提升的能力。譬如说，你的程序50%是串行的，其他一半可以并行，那么，最大的加速比就是2。不管你用多少处理器并行，这个加速比不可能提高。在这种情况下，改进串行算法可能比多核处理器并行更有效。<br>撇开上面那些文绉绉的话，在这个方向上，我们做的优化就是：</p>
<ol>
<li>提高并发效率</li>
<li>并行处理</li>
</ol>
<h2 id="提高并发效率"><a href="#提高并发效率" class="headerlink" title="提高并发效率"></a>提高并发效率</h2><p>在提高并发效率方面，值得一提的一点就是：针对计算量比较大的逻辑，将普通的线程池改成了ForkJoinPool。事情的起因还是在提升往返计算性能的过程中，我们通过mpstat命令查看线上服务器CPU Processor的使用率，发现各CPU Processor忙闲不均，如下图：</p>
<p><img src="https://farm2.staticflickr.com/1807/43009228562_658764a33b_z.jpg" alt="CPU处理器使用率不均匀"></p>
<p>这种现象引起了我们的警觉，我们意识到在忙闲不均的情况下，运行压力最大的线程将拖慢整个请求的处理速度。因此我们将计算量比较大的线程池改成了ForkJoinPool，依赖它的Work-Stealing机制来确保各线程都有任务可以执行，避免出现忙闲不均的情况。<br>通过这个优化，往返搜索的超时率进一步降低，同时服务器CPU Processor使用率也变得更加均衡，下面这张图就是优化后再通过mpstat查看到CPU核心使用率的情况。<br><img src="https://farm1.staticflickr.com/915/29186901308_7fd3b61017_z.jpg" alt="优化后的CPU使用率"><br>不管ForkJoinPool也好，还是Java8中出现的stream（默认基于ForkJoinPool）也好，都是有自己适合的场景，不是什么情况都适合的。Work-Stealing的适用场景是不同的任务的耗时相差比较大，即某些任务需要运行较长时间，而某些任务会很快的运行完成，这种情况下用 Work-Stealing很合适；但是如果任务的耗时很平均，则此时 Work-Stealing 并不适合，因为窃取任务时不同线程需要抢占锁，这可能会造成额外的时间消耗，而且每个线程维护双端队列也会造成更大的内存消耗。所以 ForkJoinPool 并不是 ThreadPoolExecutor 的替代品，而是作为对 ThreadPoolExecutor 的补充。</p>
<h2 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h2><p>在并行处理方面，我们将互相独立的计算类型（Specified fare/Constructed fare/End-on-end）拆分到不同的机器上进行处理，以减轻单台机器的计算压力，同时也能通过并行来进一步提高处理系统的处理能力。当然，这方面我们要面对的挑战就是系统的逻辑将变得更加复杂，毕竟任务调度的效率也将影响整个搜索的效率。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述内容就是我们在对系统优化过程中提炼的一些值得一提的点，因为篇幅的限制，还有一些较为底层的优化在这里无法展开来分享，这里讲考虑后续通过小专题的方式继续分享。针对本文的内容或相关的领域，也欢迎大家提出宝贵的意见和建议，谢谢。</p>
<p>相关链接：</p>
<ol>
<li>Caffeine github：<a href="https://github.com/ben-manes/caffeine" target="_blank" rel="external">https://github.com/ben-manes/caffeine</a></li>
<li>Caffeine原理：<a href="https://segmentfault.com/a/1190000008751999" target="_blank" rel="external">https://segmentfault.com/a/1190000008751999</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengfu.io/2018/05/04/结束是为了更好的开始/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="宁静·致远">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静·致远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/结束是为了更好的开始/" itemprop="url">结束是为了更好的开始</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-04T19:22:31+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/05/04/结束是为了更好的开始/" class="leancloud_visitors" data-flag-title="结束是为了更好的开始">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章是在回北京的飞机上写的开头，原文标题是《我亲手关闭了我创建的系统》，但觉得有点悲情，正好今天是耳总在公司的last day，索性改成了现在的标题。文章内容有点乱，看不懂的人您就当碎碎念吧。看懂的人，就跟我一起缅怀那段时光吧。<br>另外，文章的标题有点悲情，但不是想通过它去博取眼球或者哗众取宠，只是想通过这篇文章，来表达自己对这个系统的复杂情感，也向过去和现在为这块业务战斗过的同事们致敬。</p>
<p>文中提到的这个系统创建于2015年，是属于我们这个行业比较基础的系统。在整个业务线复杂的业务场景中，这个系统规模不算大，但就它的历程来讲，还是比较富有戏剧色彩的。<br>之所以说富有戏剧色彩，是因为它是两个团队“竞争”下的产物。之所以说是竞争，是因为当时这块业务由两个团队并行研发，并行接入。为什么会有这样的局面，我至今无从揣测高层的想法。也许老板们是想确保项目的成功，多一个团队参与能增大项目成功的概率，毕竟那是2015年整个事业部最重要的项目之一。也许老板们是想让两个团队合作，一起确保项目的成功。然而，这只是也许，事实就是：两个团队在做相同的事情，于是大家之间的“竞争”也就开始了，以前和谐的关系瞬间也不存在了……</p>
<p>为了确保项目的成功，我动员了团队所有的精兵强将参与到项目中，十几个人在一个会议室中封闭了8个月的时间。项目开始的头三个月，团队实行类似于996的作息时间。但就实际时间来讲，几乎每天是到半夜的。在那段时间里，每个人都扛着巨大的压力在工作，毕竟在系统没上线之前，你得到的信任和支持是有限的。期间，也有同学因为感受不到信任而愤然离开，也有人因为不愿趟这个浑水选择了置身事外，但参与到这个项目中的人都付出了最大的努力。也就是在那段时间，我的痛风第二次发作，瘸着一条腿，7月份整整一个月没休息过一天，居然也挺过来了。</p>
<p>在所有人的努力下，系统一期于7月初成功上线。上线之初，所支撑的业务就有了很大的增长，令大家备受鼓舞，更加信心百倍地在小黑屋里封闭着，直到年底。当然，这期间发生了一件震动互联网界的事情，就是公司被兼并了。由于这个业务与控股公司业务存在高度重叠，所以整个团队的前景也蒙上了一层阴影。兼并之后的整合如期而至，我们的系统整合很快也展开了。当然，最开始的时候，控股方的老板是希望停掉我们的系统的，但在经过充分的沟通之后，对方发现了我们系统的可取之处，于是系统得以继续保留。最终的模式变为双方系统互相补充，皆大欢喜。在这期间，双方的团队围绕这块业务进行了深入的沟通和合作，光QQ群里面的成员就多达几十人。</p>
<p>时光荏苒，转眼来到了2018年。由于购买的数据到期，加之数据成本比较高的缘故，是否继续购买数据，成了摆在我们面前的一个难题。从情感层面而言，团队是希望自己辛苦搭建的系统能够继续运转下去的。但是从事情本身来说，在两边的系统业务效果几乎没有差异的情况下，花费大几百万维持系统的运转是一件不划算的事情。在经过慎重的数据对比和评估之后，我们决定，在数据到期之时，关闭我们自己的系统，全面接入控股公司的系统。虽有不舍，但在大趋势面前，我们能做的，就是顺势而为。</p>
<p>回顾围绕这个系统所度过的3年的时间，虽然结局不是那么美好，但一路走来，扪心自问，自己是否有遗憾？我的答案是没有的，因为在这个过程中，自己已经尽了最大努力去做好每件事情，因此，已无遗憾……</p>
<p>写到这里，我们的这个系统的故事也就结束了。当然，结束是为了更好的开始，写到这里叫未完待续……</p>
<p>另外，这里必须要提一下当时与我们竞争的团队。那是一支非常优秀的团队，尤其是虾和岑喆，都是能力非常强的。只是很遗憾因为那段特殊的日子里，我们无法以一种更好的方式进行合作。之后的很多时候，我不止一次做过情景假设，如果让我再选择一次，我会怎么做？我想我会放下戒备心理，选择大家一起合作来把事情做好，只是这只能是假设了……虾、岑喆，如果你们能够看到这篇文章，请收下我的敬意和歉意。</p>
<p>在这里，也向一起战斗过的战友致敬，耿大爷、63、虹姐、苏林、马教授、小轲轲、朱大爷、maomao、跃嘉、子龙、昆哥、小杰、耳总、亚南、国英、永杰、鑫爷，你们是最棒的。那些还留在公司的同学们，愿我们能珍惜在一起的时光，开心快乐；那些已经离开的小伙伴们，世界不大不小，希望以后还能相见；如果不能，在这里愿你一切安好……</p>
<p>To 耳总：说到付出的牺牲，也许你是首当其冲的。当你一个人守护着老系统，无法接触新业务的孤独感，那一坨屎一样的代码一定是让你备受煎熬，以至于你今天都不能释怀。但不可否认的是，正因为你作为坚强后盾，才解了我们的后顾之忧。当然后续你依然为新业务作出了巨大的贡献，你自己也得到了极大的成长，我想这一切，已经值了。今天是你的last day，我们一天来到公司入职，如今各奔东西，虽有不舍，但天下没有不散的筵席。就像我在朋友圈中说的，来时你是青葱少年，去时已能披荆斩棘。这4年的时间，你不负众人，不负光阴。海阔凭鱼跃，天高任鸟飞，一路走好！</p>
<p><img src="https://farm1.staticflickr.com/825/40077554700_559e132900_o.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengfu.io/2018/03/26/Caffeine-比Guava-Cache更好的缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="宁静·致远">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静·致远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/Caffeine-比Guava-Cache更好的缓存/" itemprop="url">Caffeine-比Guava Cache更好的缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T17:09:15+08:00">
                2018-03-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/03/26/Caffeine-比Guava-Cache更好的缓存/" class="leancloud_visitors" data-flag-title="Caffeine-比Guava Cache更好的缓存">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说起Guava Cache，很多人都不会陌生，它是Google Guava工具包中的一个非常方便易用的本地化缓存实现，基于LRU算法实现，支持多种缓存过期策略。由于Guava的大量使用，Guava Cache也得到了大量的应用。但是，Guava Cache的性能一定是最好的吗？也许，曾经，它的性能是非常不错的。但所谓长江后浪推前浪，总会有更加优秀的技术出现。今天，我就来介绍一个比Guava Cache性能更高的缓存框架：Caffeine。</p>
<p>下面的内容是转载的一篇译文，如果需要查看译文原文，请点击<a href="https://segmentfault.com/a/1190000008751999" target="_blank" rel="external">这里</a>,英语好的同学也可以直接查看<a href="http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html" target="_blank" rel="external">英文原作</a>。</p>
<p>==========以下是原文内容==========</p>
<p>缓存是提升性能的通用方法，现在大多数的缓存实现都使用了经典的技术。这篇文章中，我们会发掘<a href="https://github.com/ben-manes/caffeine" target="_blank" rel="external">Caffeine</a>中的现代的实现方法。Caffeine是一个开源的Java缓存库，它能提供高命中率和出色的并发能力。期望读者们能被这些想法激发，进而将它们应用到任何你喜欢的编程语言中。</p>
<h2 id="驱逐策略"><a href="#驱逐策略" class="headerlink" title="驱逐策略"></a>驱逐策略</h2><p>缓存的驱逐策略是为了预测哪些数据在短期内最可能被再次用到，从而提升缓存的命中率。由于简洁的实现、高效的运行时表现以及在常规的使用场景下有不错的命中率，LRU（Least Recently Used）策略或许是最流行的驱逐策略。但LRU通过历史数据来预测未来是局限的，它会认为最后到来的数据是最可能被再次访问的，从而给与它最高的优先级。</p>
<p>现代缓存扩展了对历史数据的使用，结合就近程度（recency）和访问频次（frequency）来更好的预测数据。其中一种保留历史信息的方式是使用popularity sketch（一种压缩、概率性的数据结构）来从一大堆访问事件中定位频繁的访问者。可以参考<a href="http://dimacs.rutgers.edu/~graham/pubs/papers/cmsoft.pdf" target="_blank" rel="external">CountMin Sketch</a>算法，它由计数矩阵和多个哈希方法实现。发生一次读取时，矩阵中每行对应的计数器增加计数，估算频率时，取数据对应是所有行中计数的最小值。这个方法让我们从空间、效率、以及适配矩阵的长宽引起的哈希碰撞的错误率上做权衡。</p>
<p><img src="https://sfault-image.b0.upaiyun.com/198/843/1988435212-58d64be00bb9d_articlex" alt="CountMin Sketch"></p>
<p><a href="https://arxiv.org/pdf/1512.00727.pdf" target="_blank" rel="external">Window TinyLFU</a>（W-TinyLFU）算法将sketch作为过滤器，当新来的数据比要驱逐的数据高频时，这个数据才会被缓存接纳。这个许可窗口给予每个数据项积累热度的机会，而不是立即过滤掉。这避免了持续的未命中，特别是在突然流量暴涨的的场景中，一些短暂的重复流量就不会被长期保留。为了刷新历史数据，一个时间衰减进程被周期性或增量的执行，给所有计数器减半。</p>
<p><img src="https://sfault-image.b0.upaiyun.com/274/307/2743073853-58d64be0088fe_articlex" alt="Window TinyLFU"></p>
<p>对于长期保留的数据，W-TinyLFU使用了分段LRU（Segmented LRU，缩写SLRU）策略。起初，一个数据项存储被存储在试用段（probationary segment）中，在后续被访问到时，它会被提升到保护段（protected segment）中（保护段占总容量的80%）。保护段满后，有的数据会被淘汰回试用段，这也可能级联的触发试用段的淘汰。这套机制确保了访问间隔小的热数据被保存下来，而被重复访问少的冷数据则被回收。</p>
<p><img src="https://sfault-image.b0.upaiyun.com/571/159/571159220-58d64be031155_articlex" alt=""></p>
<p>如图中数据库和搜索场景的结果展示，通过考虑就近程度和频率能大大提升LRU的表现。一些高级的策略，像ARC，LIRS和W-TinyLFU都提供了接近最理想的命中率。想看更多的场景测试，请查看相应的论文，也可以在使用simulator来测试自己的场景。</p>
<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>过期的实现里，往往每个数据项拥有不同的过期时间。因为容量的限制，过期后数据需要被懒淘汰，否则这些已过期的脏数据会污染到整个缓存。一般缓存中会启用专有的清扫线程周期性的遍历清理缓存。这个策略相比在每次读写操作时按照过期时间排序的优先队列来清理过期缓存要好，因为后台线程隐藏了的过期数据清除的时间开销。</p>
<p>鉴于大多数场景里不同数据项使用的都是固定的过期时长，Caffien采用了统一过期时间的方式。这个限制让用O（1）的有序队列组织数据成为可能。针对数据的写后过期，维护了一个写入顺序队列，针对读后过期，维护了一个读取顺序队列。缓存能复用驱逐策略下的队列以及下面将要介绍的并发机制，让过期的数据项在缓存的维护阶段被抛弃掉。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>由于在大多数的缓存策略中，数据的读取都会伴随对缓存状态的写操作，并发的缓存读取被视为一个难点问题。传统的解决方式是用同步锁。这可以通过将缓存的数据划成多个分区来进行锁拆分优化。不幸的是热点数据所持有的锁会比其他数据更常的被占有，在这种场景下锁拆分的性能提升也就没那么好了。当单个锁的竞争成为瓶颈后，接下来的经典的优化方式是只更新单个数据的元数据信息，以及使用<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.110.8469&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">随机采样</a>、<a href="https://en.wikipedia.org/wiki/Page_replacement_algorithm#Second-chance" target="_blank" rel="external">基于FIFO</a>的驱逐策略来减少数据操作。这些策略会带来高性能的读和低性能的写，同时在选择驱逐对象时也比较困难。</p>
<p>另一种<a href="http://web.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-09-1.pdf" target="_blank" rel="external">可行方案</a>来自于数据库理论，通过提交日志的方式来扩展写的性能。写入操作先记入日志中，随后异步的批量执行，而不是立即写入到数据结构中。这种思想可以应用到缓存中，执行哈希表的操作，将操作记录到缓冲区，然后在合适的时机执行缓冲区中的内容。这个策略依然需要同步锁或者tryLock，不同的是把对锁的竞争转移到对缓冲区的追加写上。</p>
<p>在Caffeine中，有一组缓冲区被用来记录读写。一次访问首先会被因线程而异的哈希到stripped ring buffer上，当检测到竞争时，缓冲区会自动扩容。一个ring buffer容量满载后，会触发异步的执行操作，而后续的对该ring buffer的写入会被丢弃，直到这个ring buffer可被使用。虽然因为ring buffer容量满而无法被记录该访问，但缓存值依然会返回给调用方。这种策略信息的丢失不会带来大的影响，因为W-TinyLFU能识别出我们希望保存的热点数据。通过使用因线程而异的哈希算法替代在数据项的键上做哈希，缓存避免了瞬时的热点key的竞争问题。</p>
<p><img src="https://sfault-image.b0.upaiyun.com/270/327/2703271825-58d64be011a4f_articlex" alt=""></p>
<p>写数据时，采用更传统的并发队列，每次变更会引起一次立即的执行。虽然数据的损失是不可接受的，但我们仍然有很多方法可以来优化写缓冲区。所有类型的缓冲区都被多个的线程写入，但却通过单个线程来执行。这种多生产者/单个消费者的模式允许了更简单、高效的算法来实现。</p>
<p>缓冲区和细粒度的写带来了单个数据项的操作乱序的竞态条件。插入、读取、更新、删除都可能被各种顺序的重放，如果这个策略控制的不合适，则可能引起悬垂索引。解决方案是通过状态机来定义单个数据项的生命周期。</p>
<p><img src="https://sfault-image.b0.upaiyun.com/270/327/2703271825-58d64be011a4f_articlex" alt=""></p>
<p>在<a href="https://github.com/ben-manes/caffeine/wiki/Benchmarks#read-100-1" target="_blank" rel="external">基准测试</a>中，缓冲区随着哈希表的增长而增长，它的的使用相对更节省资源。读的性能随着CPU的核数线性增长，是哈希表吞吐量的33%。写入有10%的性能损耗，这是因为更新哈希表时的竞争是最主要的开销。</p>
<p><img src="https://sfault-image.b0.upaiyun.com/250/918/2509180021-58d64be00f7f4_articlex" alt=""></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>还有许多实用的话题没有被覆盖到。包括最小化内存的技巧，当复杂度上升时保证质量的测试技术以及确定优化是否值得的性能分析方法。这些都是缓存的实践者需要关注的点，因为一旦这些被忽视，就很难重拾掌控缓存带来的复杂度的信心。</p>
<p>Caffeine的设计实现来自于大量的洞见和许多贡献者的共同努力。它这些年的演化离不开一些人的帮助：Charles Fry, Adam Zell, Gil Einziger, Roy Friedman, Kevin Bourrillion, Bob Lee, Doug Lea, Josh Bloch, Bob Lane, Nitsan Wakart, Thomas Müeller, Dominic Tootell, Louis Wasserman, and Vladimir Blagojevic. Thanks to Nitsan Wakart, Adam Zell, Roy Friedman, and Will Chu for their feedback on drafts of this article.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengfu.io/2018/03/15/一起因限流引发的故障/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="宁静·致远">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静·致远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/15/一起因限流引发的故障/" itemprop="url">一起因限流引发的故障</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-15T20:56:05+08:00">
                2018-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/03/15/一起因限流引发的故障/" class="leancloud_visitors" data-flag-title="一起因限流引发的故障">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>限流是保证系统高可用性的一项很重要的举措，但是任何事情都有利弊，限流措施如果使用不当，有可能会引起比较大的问题，反而导致系统可用性降低。</p>
<h2 id="2-详细经过"><a href="#2-详细经过" class="headerlink" title="2.详细经过"></a>2.详细经过</h2><p>上周，我们负责的一个入口系统的几台服务器突然收到大量的线程池满的告警，根据以往的经验，初步判断是上游请求量激增导致的。通过监控也印证了我们的判断，因为激增的流量比较大，为保护集群，避免出现雪崩，我们开启了限流措施。本来这是保证集群可用性的一种常见措施，但因为其中某些环节做得不够细致，导致了后面故障的发生。</p>
<p>开启了限流措施之后，我们很快就收到了另外一个监控(搜索结果为空率)的告警。此监控是反映系统返回结果为空的比例的，当这个比例超过设定的阈值就会告警。当时这个告警飙升到了40%多，这个比例是非常恐怖的，意味着接近一半的搜索没有结果了。当时我们立刻断定是限流的影响，为了保护集群，同时不影响用户体验，我们将限流阈值调高，这时搜索为空率监控开始下降。</p>
<p>5分钟后，上游系统同事反馈系统请求量在下降，我们自己的监控也有所体现，为了避免伤害用户，我们关掉了限流，于是故障恢复。</p>
<h2 id="3-故障分析"><a href="#3-故障分析" class="headerlink" title="3.故障分析"></a>3.故障分析</h2><h3 id="3-1-Hash策略不合理"><a href="#3-1-Hash策略不合理" class="headerlink" title="3.1 Hash策略不合理"></a>3.1 Hash策略不合理</h3><p>事后分析原因，发现是平台上有个代理商发布了一个错误的航线价格，这个价格非常低，导致大量的用户前来搜索和购买。由于我们的集群是根据航线+日期进行hash，导致短时间内，特定的几台机器收到了大量的请求，导致机器负载过高，最终不可用。如果能够让集群的请求分布更加均匀，那么也不会导致雪崩的风险而不得不限流。</p>
<h3 id="3-2-限流措施不合理"><a href="#3-2-限流措施不合理" class="headerlink" title="3.2 限流措施不合理"></a>3.2 限流措施不合理</h3><p>故障以前系统的限流措施是：被限流后，请求立即返回为空的结果。但这里更加合理的措施是：如果被限流，让请求在队列里面等待一会再尝试请求。这样能够达到削峰的效果，让请求更加平滑，同时也降低对用户体验的伤害。</p>
<h3 id="3-3-请求合并不合理"><a href="#3-3-请求合并不合理" class="headerlink" title="3.3 请求合并不合理"></a>3.3 请求合并不合理</h3><p>为减轻对后端系统的压力，我们系统中保留了本地缓存，这样能够针对相同的请求使用缓存，也能提高缓存的利用率。但因为系统单次请求的结果集比较大，为降低对本地缓存的占用，我们并未将最终结果进行缓存，而是缓存了初始结果，这样就意味着在利用缓存的时候，还需要在本地经过一些计算才能返回结果，这无疑增加了系统的压力。</p>
<p>所以后续我们可以做进一步优化，在一个时间片内，如果存在相同的请求，如果结果还没有计算出来，就等结果计算出来再返回；如果结果已经计算出来并在缓存中有效，直接返回结果即可。这样也能进一步降低系统的负载。</p>
<h3 id="3-4-限流粒度太粗"><a href="#3-4-限流粒度太粗" class="headerlink" title="3.4 限流粒度太粗"></a>3.4 限流粒度太粗</h3><p>故障以前系统是对所有请求进行限流，但故障时，只是某条航线收到了大量的请求，其余航线请求是正常的。开启限流之后，虽然大量的问题航线请求被限制住了，但同时也限制了正常的用户请求。所以在限流的粒度上，我们还可以做得更加细致。当然这里有个前提，就是我们需要在第一时间知道哪条航线请求量飙升，这样才能有针对性地进行限流。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>高可用是一个很大的话题，就其中的限流措施来说，也可以做得非常细致。这里只是针对本次故障做一个简单的总结，对此如果你有任何意见或建议，还望不吝赐教。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengfu.io/2018/02/28/服务化架构-服务的熔断/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="宁静·致远">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静·致远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/28/服务化架构-服务的熔断/" itemprop="url">服务化架构-服务的熔断</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-28T20:20:23+08:00">
                2018-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/02/28/服务化架构-服务的熔断/" class="leancloud_visitors" data-flag-title="服务化架构-服务的熔断">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是熔断"><a href="#什么是熔断" class="headerlink" title="什么是熔断"></a>什么是熔断</h2><p>软件行业中的很多技术都是借鉴于工业的，熔断也不例外。熔断机制类似于工厂的保险丝/盒，当电流过大时，为了保护电器不受损，将电路熔断或者跳闸，断电后人工更换保险丝或者合闸。当然，在软件系统里面的熔断机制，其实可以实现自动熔断和恢复。</p>
<h2 id="为什么要熔断"><a href="#为什么要熔断" class="headerlink" title="为什么要熔断"></a>为什么要熔断</h2><p>有人可能要问了，软件系统如果健壮性做得很好，需要熔断吗？<br>前面我们说过，熔断是针对下游的系统来说的。举个栗子，如果下游C系统出问题了，服务100%超时，这时候你可以先不去请求C了，直到C恢复再去请求。有人说我去请求了也没关系吧，反正请求和不请求都是失败，我干嘛要把事情搞复杂了？我又不知道C什么时候能恢复，权当去测试C的可用性了呗。</p>
<p>嗯，你说得有道理，不过需要每个请求都要去测试吗？当然没必要，而且很多时候下游系统的超时有可能会拖垮你的系统。纳尼？这又是为啥？</p>
<p>我们继续举例子，如果你的系统与C系统是通过同步的方式交互，那么意味着在C返回结果前，你的系统的工作线程是要阻塞在那里的，这也就会导致你的系统吞吐量的降低，毕竟线程是不能无限创建的。</p>
<h2 id="熔断的实现"><a href="#熔断的实现" class="headerlink" title="熔断的实现"></a>熔断的实现</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>熔断的实现思路很简单，简而言之就是失败率统计，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p>
<h3 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h3><p>熔断器工作过程中，有3个状态：闭合、打开、半开。</p>
<ul>
<li><p>闭合（Closed）状态：我们需要一个调用失败的计数器，如果调用失败，则使失败次数加 1。如果最近失败次数超过了在给定时间内允许失败的阈值，则切换到断开 (Open) 状态。此时开启了一个超时时钟，当该时钟超过了该时间，则切换到半断开（Half-Open）状态。该超时时间的设定是给了系统一次机会来修正导致调用失败的错误，以回到正常工作的状态。在 Closed 状态下，错误计数器是基于时间的。在特定的时间间隔内会自动重置。这能够防止由于某次的偶然错误导致熔断器进入断开状态。也可以基于连续失败的次数。</p>
</li>
<li><p>打开 (Open) 状态：在该状态下，对应用程序的请求会立即返回错误响应，而不调用后端的服务。这样也许比较粗暴，有些时候，我们可以 cache 住上次成功请求，直接返回缓存（当然，这个缓存放在本地内存就好了），如果没有缓存再返回错误（缓存的机制最好用在全站一样的数据，而不是用在不同的用户间不同的数据，因为后者需要缓存的数据有可能会很多）。</p>
</li>
<li><p>半开（Half-Open）状态：允许应用程序一定数量的请求去调用服务。如果这些请求对服务的调用成功，那么可以认为之前导致调用失败的错误已经修正，此时熔断器切换到闭合状态 (并且将错误计数器重置)。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4098122-55290c8ca6729751.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>如果这一定数量的请求有调用失败的情况，则认为导致之前调用失败的问题仍然存在，熔断器切回到断开状态，然后重置计时器来给系统一定的时间来修正错误。半断开状态能够有效防止正在恢复中的服务被突然而来的大量请求再次拖垮。</p>
<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>在业界，一说到熔断器，很多人很容易就会联想到Netflix开源的<a href="https://github.com/Netflix/Hystrix" target="_blank" rel="external">Hystrix</a>。是的Hyxtrix是一个非常优秀的保证系统高可用的组件，其中的熔断、舱壁(bulkhead)实现都能够帮助我们提高系统的可用性。</p>
<h2 id="熔断的其他注意事项"><a href="#熔断的其他注意事项" class="headerlink" title="熔断的其他注意事项"></a>熔断的其他注意事项</h2><p>在实现熔断器模式的时候，以下这些因素需可能需要考虑。</p>
<ul>
<li><p>避免侵入代码：熔断器应该作为一种比较基础的服务组件存在于系统中，尽量避免对业务代码的侵入，从而提高系统的可维护性。所以通用、可配置化是熔断组件的基本要求。</p>
</li>
<li><p>状态监控：熔断器处于打开、半开状态时，应该能够在第一时间通知维护人员，让相关人员及时获知熔断器的状态，并根据其他信息决定下一步采取的措施。</p>
</li>
<li><p>日志记录：熔断器应该能够记录所有失败的请求，以及一些可能会尝试成功的请求，使得管理员能够监控使用熔断器保护的服务的执行情况。</p>
</li>
<li><p>性能考虑：熔断器的实现不应该阻塞并发的请求或者增加每次请求调用的负担。尤其是其中的对调用结果的统计，一般来说会成为一个共享的数据结构，这个会导致有锁的情况。在这种情况下，最好使用一些无锁的数据结构，或是 atomic 的原子操作。这样会带来更好的性能。</p>
</li>
<li><p>错误区分。要能够区分出正常的调用失败和熔断失败，这样能够针对不同的失败制定不同的策略。比如对于正常的调用失败，可以采取重试机制；而对于熔断失败，那么快速失败即可。</p>
</li>
<li><p>服务测试。在断开状态下，熔断器可以采用定期地 ping 一下远程的服务的健康检查接口，来判断服务是否恢复，而不是使用计时器来自动切换到半开状态。这样做的一个好处是，在服务恢复的情况下，不需要真实的用户流量就可以把状态从半开状态切回关闭状态。否则在半开状态下，即便服务已恢复了，也需要用户真实的请求来恢复，这会影响用户的真实请求。</p>
</li>
<li><p>手动重置：在系统中对于失败操作的恢复时间是很难确定的，提供一个手动重置功能能够使得管理员可以手动地强制将熔断器切换到闭合状态。同样的，如果受熔断器保护的服务暂时不可用的话，管理员能够强制将熔断器设置为断开状态。</p>
</li>
<li><p>熔断隔离：对于不同的服务，要设置不同的熔断器，使他们相互隔离，避免互相影响。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengfu.io/2018/02/03/服务化架构-服务的限流与熔断/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="宁静·致远">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静·致远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/03/服务化架构-服务的限流与熔断/" itemprop="url">服务化架构-服务的限流与熔断</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T20:23:23+08:00">
                2018-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/02/03/服务化架构-服务的限流与熔断/" class="leancloud_visitors" data-flag-title="服务化架构-服务的限流与熔断">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>服务的限流、熔断是保证系统高可用的两个非常重要的举措，但有人会把限流和熔断的概念混淆，在这里做一个简单的区分。</p>
<p>为了方便说明，我们先做一个情景设定：有3个系统，A、B、C，他们之间的调用关系是这样的：A-&gt;B-&gt;C，也就是说，A是B的上游，C是B的下游。这里针对B系统做限流、熔断的说明。</p>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>限流是针对上游系统的请求来说的，对于B来说，如果上游A的请求量过大，那么就需要对A做限流，来保护自己不被流量冲垮。<br>关于限流，请看这篇文章：<a href="http://fengfu.io/2017/04/22/%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%9E%B6%E6%9E%84-%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%99%90%E6%B5%81/">《服务的限流》</a></p>
<h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><p>熔断是针对下游的系统来说的。举个栗子，如果下游C系统出问题了，服务100%超时，这时候你可以先不去请求C了，直到C恢复再去请求。这种措施就叫熔断。<br>关于熔断，请看这篇文章：<a href="http://fengfu.io/2018/02/28/%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%9E%B6%E6%9E%84-%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%86%94%E6%96%AD/">《服务的熔断》</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengfu.io/2018/01/02/StringBuilder你应该知道的几件事情/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="宁静·致远">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静·致远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/02/StringBuilder你应该知道的几件事情/" itemprop="url">StringBuilder你应该知道的几件事情</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-02T20:33:21+08:00">
                2018-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/01/02/StringBuilder你应该知道的几件事情/" class="leancloud_visitors" data-flag-title="StringBuilder你应该知道的几件事情">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>字符串拼接是我们在编写程序时经常要写的代码，在很多的系统中，字符串相关的处理甚至占用了系统非常多的资源，尤其是内存。因此，在一些高性能的场景中，字符串拼接使用方式不合理，往往会导致无谓的内存开销，增加GC压力。</p>
<p>有些同学会直接使用”+”的方式进行字符串拼接，在Jdk7u40之前，这种方式我们是不推荐使用的，因为String是不可变对象，每次对String的”+”操作都会产生一个新的String对象，尤其是在对多个String进行拼接处理的时候，从而导致内存的浪费。但在Jdk7u40之后，-XX:+OptimizeStringConcat被默认打开，这样Jdk在进行Jit编译的时候，会自动将”+”形式的字符串拼接优化成StringBuilder append的方式。</p>
<p>但是，让编译器帮你优化这种方式你就可以高枕无忧了吗？答案是否定的，请看下面的内容。</p>
<h2 id="1-new-StringBuilder-合理吗？"><a href="#1-new-StringBuilder-合理吗？" class="headerlink" title="1.new StringBuilder()合理吗？"></a>1.new StringBuilder()合理吗？</h2><p>很多时候我们使用new StringBuilder()来初始化实例，但这种方式是否合理呢？</p>
<p>通过阅读StringBuilder的源码我们可以看到，StringBuilder的内部存储是使用char[]来实现的，char[]的初始容量是16。在进行append时，首先会检查char[]容量是否够用，如果不够，则会创建一个新的char[]，容量为原来容量的2倍，原来的char[]则会丢弃。看到这里，细心的同学可能会想了，这不是浪费了吗？是的，这就是不设置初始容量所带来的弊端，会导致一定的内存浪费。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String a1 = &quot;1234567890&quot;;//length 10</div><div class="line">String a2 = &quot;0123456789&quot;;//length 10</div><div class="line">String a3 = &quot;123456789&quot;;//length 9</div><div class="line">String a4 = &quot;987654321&quot;;//length 9</div><div class="line"></div><div class="line">String a5 = new StringBuilder().append(a1).append(a2).append(a3).append(a4).toString();</div></pre></td></tr></table></figure>
<p>上面这段代码的执行共创建了几个char[]呢？答案是4个，详细过程看下面的描述。</p>
<ol>
<li><p>new StringBuilder()的时候，如果我们不指定StringBuilder的容量，那么会按照默认值是16创建第一个数组，我们命名为C1。在append(a1)的时候，容量是够用的；</p>
</li>
<li><p>在append(a2)的时候，C1容量不够了需要扩容，于是创建一个容量为以前2倍的数组C2，并将旧的数组C1的内容以及a2的内容按顺序copy到新数组C2中，这时候C2的大小是32；</p>
</li>
<li><p>在append(a3)的时候，C2的容量是够用的，所以直接将a3的内容copy进C2；</p>
</li>
<li><p>在append(a4)的时候，C2的容量也不够用了，于是再创建一个容量为C2两倍的数组C3，并将旧的数组C2的内容以及a4的内容按顺序copy到新数组C3中，这时候C3的大小是64；</p>
</li>
<li><p>在toString的时候，是调用的new String(value, 0, count)。这样并不是将C3的内容直接转换成String，而是会copy出一个副本C4再根据C4创建出一个String来；这一点，建议大家仔细去看看StringBuilder的toString代码，你会发现更多的真相……</p>
</li>
</ol>
<p><img src="https://farm5.staticflickr.com/4690/39073757202_23dcf8ee35_b.jpg" alt=""></p>
<p>看完上面的描述，你会觉得这个过程中浪费了多少内存呢？最起码C1、C2是没用了的，也就是说浪费掉了48byte的空间。那如果你最初根据预估的字符串大小，设置了StringBuilder初始容量为38，那么就不会存在这样的浪费了，同时也会省去StringBuilder扩容的时间。</p>
<p>所以，在使用StringBuilder的时候，还是估算一下字符串大小，乖乖的设置一个初始容量吧。</p>
<h2 id="2-不要重复创建StringBuilder"><a href="#2-不要重复创建StringBuilder" class="headerlink" title="2.不要重复创建StringBuilder"></a>2.不要重复创建StringBuilder</h2><p>这里说的重复是指在循环中重复new StringBuilder实例。前面我们也说过，StringBuilder的扩容和toString()方法会造成大量的char[]浪费，如果你在一个循环里面创建了很多StringBuilder实例，那么可以想象浪费的内存有多大……所以在一个循环里面复用StringBuilder比较好的方式是调用StringBuilder.setLength(0)重置指针进行复用，这样最起码就能避免再次扩容的内存消耗了。</p>
<h2 id="3-StringBuilder-toString-造成的内存浪费"><a href="#3-StringBuilder-toString-造成的内存浪费" class="headerlink" title="3.StringBuilder.toString()造成的内存浪费"></a>3.StringBuilder.toString()造成的内存浪费</h2><p>前面我们也提到过，每次StringBuilder.toString的时候，会copy一个char[]生成一个String对象，这样就相当于白白浪费了StringBuilder里面的数组。当然这里可以采用一些黑科技来避免这种浪费，比如用Unsafe这种黑科技，绕过构造函数直接给String的char[]属性赋值，示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Unsafe unsafe =</div><div class="line">long fieldOffset = Unsafe.getUnsafe();</div><div class="line">unsafe.objectFieldOffset(String.class.getDeclaredField(&quot;value&quot;));</div><div class="line">String ret = new String();</div><div class="line"></div><div class="line">unsafe.putObjectVolatile(ret, fieldOffset, char[]);//char[]为StringBuilder中的char[]</div></pre></td></tr></table></figure></p>
<p>这种方式虽然能够避免内存浪费，但也存在一定的风险，所以使用的时候还是要慎重。</p>
<h2 id="4-StringBuilder-vs-StringBuffer"><a href="#4-StringBuilder-vs-StringBuffer" class="headerlink" title="4.StringBuilder vs StringBuffer"></a>4.StringBuilder vs StringBuffer</h2><p>StringBuffer与StringBuilder都是继承于AbstractStringBuilder，唯一的区别就是StringBuffer的函数上都有synchronized关键字。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="宁静·致远" />
          <p class="site-author-name" itemprop="name">宁静·致远</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">54</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">宁静·致远</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("pq7j7M6jaVzlRAhO3VhuFy1O-gzGzoHsz", "Fqlk4xsApzNKqC5HV87nMkix");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
