
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>宁静·致远</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="宁静·致远">
<meta property="og:url" content="http://fengfu.io/index.html">
<meta property="og:site_name" content="宁静·致远">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="宁静·致远">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="宁静·致远" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">宁静·致远</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="fengfu.io">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-晋级Review归来话代码有毒" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/27/晋级Review归来话代码有毒/" class="article-date">
  <time datetime="2016-10-27T07:36:55.000Z" itemprop="datePublished">2016-10-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/27/晋级Review归来话代码有毒/">晋级Review归来话代码有毒</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这几天做应届生的转正定级答辩，结束后小黑哥在朋友圈里面发了下面一幅图：</p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2qDgda71M.eBjSZPiXXawfpXa_!!2657627814.jpg" alt=""></p>
<p>并在评论里面说了一句话：网络不超时，堆外不清理，异步不回调，异常不监控。</p>
<p>上面的中毒情况总结得非常不错，这让我想起了《唐伯虎点秋香》里面的一段情节：</p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2Poz0aHaI.eBjy1XdXXcoqXXa_!!2657627814.jpg" alt=""></p>
<p>华夫人对唐伯虎说：一日丧命散是用七种不同的毒虫再加上那鹤顶红提炼七七四十九天而成的，无色无味，杀人于无影无踪。吃了我们一日丧命散的人，一天之内会武功全失，经脉逆流，胡思乱想而至走火入魔，最后啊，会血管爆裂而死。</p>
<p>借着这个情节和小黑哥的中毒，来总结一下代码里面的七种毒虫吧。</p>
<p><img src="https://img.alicdn.com/imgextra/i1/2657627814/TB2Qegea71M.eBjSZPiXXawfpXa_!!2657627814.jpg" alt=""></p>
<h1 id="1-资源不限制"><a href="#1-资源不限制" class="headerlink" title="1.资源不限制"></a>1.资源不限制</h1><p>这是很多码农容易中的毒，典型的症状是：</p>
<h2 id="1-1-缓存不设置最大数量限制"><a href="#1-1-缓存不设置最大数量限制" class="headerlink" title="1.1 缓存不设置最大数量限制"></a>1.1 缓存不设置最大数量限制</h2><p>比如我们使用map实现了一个cache，但是没有设置cache的大小，久而久之你可以想象一下这个cache最终会膨胀到什么程度。当然有同学可能会说我使用的是Guava cache，可以设置数量限制。well done，你再回去看看你的full gc是不是比较频繁，没准是因为这个值太大导致的哟~</p>
<h2 id="1-2-线程池不设置队列大小"><a href="#1-2-线程池不设置队列大小" class="headerlink" title="1.2 线程池不设置队列大小"></a>1.2 线程池不设置队列大小</h2><p>比如我们使用newFixedThreadPool，但是我们没有设置队列的大小，而悲催的是，在java中，线程池队列的默认大小是Integer.MAX_VALUE，我想你自己也能清楚这种情况下会发生什么问题。<br>再比如Executors.newCachedThreadPool，这个接口很多人会用到，但很多用的人都没有仔细想过会不会在某种情况下这里创建出巨多的线程。</p>
<h1 id="2-网络不超时"><a href="#2-网络不超时" class="headerlink" title="2.网络不超时"></a>2.网络不超时</h1><p>在服务化设计大行其道的今天，我们很多的服务调用都是通过网络调用进行的。设想一下，如果我们调用的某个服务性能低下或者网络异常，长时间没有返回结果，那么作为调用端你应该怎么办？做缩脖子老等吗？</p>
<p>在review代码的时候，这种情况尤其常见，尤其是使用httpclient的时候。</p>
<h1 id="3-自我不保护"><a href="#3-自我不保护" class="headerlink" title="3.自我不保护"></a>3.自我不保护</h1><p>这种情况尤其常见于对外提供接口的情况。对于调用方传过来的参数，我们没有做严格的有效性检查或者限制，最终导致不符合要求的数据将程序搞挂。比如我们提供了一个用户信息批量查询的接口，参数是一个数组。结果是某个调用方传了有1000个元素的数组过来，最终可能直接导致程序内存溢出……这种情况我们能去怪罪调用方吗？严格来说，我们不能，在这里可以借鉴一句经典的话：不要相信前端传来的任何数据。我想对于接口也是一样：不要相信调用端传来的任何数据。</p>
<p>还有一种情况就是系统处理能力的保护，最典型的就是QPS。如果我们的系统能够承受的QPS是100，那么如果QPS超过这个数值，我们该怎么办？我想很多人心里已经有了答案了。</p>
<h1 id="4-连接不关闭"><a href="#4-连接不关闭" class="headerlink" title="4.连接不关闭"></a>4.连接不关闭</h1><p>这里其实是有两点要强调，连接和流。</p>
<h2 id="4-1-连接不关闭"><a href="#4-1-连接不关闭" class="headerlink" title="4.1 连接不关闭"></a>4.1 连接不关闭</h2><p>说到连接，这里所说的是网络连接。我们都知道，网络资源是一种受限资源，无限制的网络连接会给自身及对方系统带来很大的压力，因此我们会使用连接池或其他连接复用技术来降低系统压力，以此提高效率。但是如果我们忘记了关闭连接的话，就会对对端系统带来隐患。比如数据库连接，如果忘记关闭，会造成数据库服务器连接资源耗尽最终导致拒绝服务。当然有同学说，现在很多服务器都有超时检查机制，长时间不活动的连接会自动清除。那么你想过没有，如果连接被服务器断开，这种情况下客户端是感知不到的。只有你下次使用的时候才发现连接已经不可用了。</p>
<h2 id="4-2-流不关闭"><a href="#4-2-流不关闭" class="headerlink" title="4.2 流不关闭"></a>4.2 流不关闭</h2><p>流的问题很好理解，我们读写文件、网络传输，很多很多场景需要使用流，而在操作系统层面，对文件、网络的操作都是有限制的。在使用流的时候，我们首先需要进行open，最后close。如果我们忘记了close，那么系统就不会释放对此资源的占用，最终超出系统限制而导致后续的操作失败，最典型的错误就是too many open files。</p>
<h1 id="5-异步不回调"><a href="#5-异步不回调" class="headerlink" title="5.异步不回调"></a>5.异步不回调</h1><p>在分布式服务架构中，很多的服务为了提高并发处理能力，使用了异步机制。异步的好处是消费端可以不必一直等待服务端的结果，而将资源交给其他的逻辑处理。当服务端有结果返回时，通过回调机制调用消费端的逻辑进行后续的处理。但是在实际的使用过程中，发现很多人还是使用同步的方式来调用异步方法，比如：</p>
<pre><code>fooService.findFoo(fooId); //fooService.findFoo方法支持异步
Future&lt;Foo&gt; fooFuture = RpcContext.getContext().getFuture(); 

Foo foo = fooFuture.get(); // 如果foo已返回，直接拿到返回值，否则线程wait住，等待foo返回后，线程会被notify唤醒
</code></pre><p>我们知道Future对象具有如下的特性：</p>
<ol>
<li>异步执行，可用 get 方法获取执行结果；</li>
<li>如果计算还没完成，get 方法是会阻塞的，如果完成了，是可以多次获取并立即得到结果的；</li>
<li>如果计算还没完成，是可以取消计算的；</li>
<li>可以查询计算的执行状态</li>
</ol>
<p>所以上述的代码问题主要出现在第3行，如果fooService.findFoo方法还没有返回值，那么fooFuture.get()方法会被阻塞直到结果返回，这样就失去了异步调用的优势了。</p>
<p>那么针对上面的代码，正确的写法应该是通过回调机制做数据返回时的处理：</p>
<pre><code>fooService.findFoo(fooId);  

ResponseFuture future = ((FutureAdapter)RpcContext.getContext().getFuture()).getFuture();
future.setCallback(new ResponseCallback(){
    public void done(Object response){
       //调用正常的时候执行
    }

    public void caught(Throwable exception){
      //调用异常的时候执行
    }
});
</code></pre><p>当然，上面的方式只是举了个栗子，具体情况需要根据不同的RPC框架去做处理。这里推荐Google guava concurrent包里面的接口和工具类，比如ListenableFuture、Futures等，具体实例网上有很多的说明，请大家自行安利，这里就不做赘述了。</p>
<h1 id="6-异常不监控"><a href="#6-异常不监控" class="headerlink" title="6.异常不监控"></a>6.异常不监控</h1><p>当系统抛出异常被捕获后，很多同学只是通过日志记录了一下异常信息，但是并没有通过监控系统记录异常。这样带来的隐患就是我们没法在第一时间感知系统异常，只能是影响到其他监控了才会有所体现，但这样就只能靠运气了。如果被影响的监控比较敏感，或许很快就会有告警；但是如果被影响的监控不敏感，或者压根没开告警，那么你就呵呵了……</p>
<h1 id="7-堆外不清理"><a href="#7-堆外不清理" class="headerlink" title="7.堆外不清理"></a>7.堆外不清理</h1><p>在某些业务场景下，我们可能需要使用DirectByteBuffer分配字节缓冲区，或者使用MappedByteBuffer做内存映射，那么我们不可避免地需要使用堆外内存。DirectByteBuffer对象在创建过程中会先通过Unsafe接口直接通过os::malloc来分配内存，然后将内存的起始地址和大小存到DirectByteBuffer对象里，这样就可以直接操作这些内存。我们dump内存时可能会发现DirectByteBuffer对象很小，但是其实它后面可能关联了一个非常大的堆外内存，因此我们通常称之为“冰山对象”。这些内存只有在DirectByteBuffer回收掉之后才有机会被回收，因此如果这些对象大部分都移到了old，但是一直没有触发CMS GC或者Full GC，那么悲剧将会发生，因为你的物理内存被他们耗尽了，因此为了避免这种悲剧的发生，通过-XX:MaxDirectMemorySize来指定最大的堆外内存大小，当使用达到了阈值的时候将调用System.gc来做一次full gc，以此来回收掉没有被使用的堆外内存。</p>
<p>另外，当前我们的使用的服务框架、第三方组件，很多都是基于netty、mina这种NIO框架实现网络调用，而这些NIO框架基本都在使用堆外内存。而我们知道，堆外内存是无法通过JVM的垃圾回收器回收的，只能通过System.gc()来回收。但是很多同学在设置JVM参数的时候，往往选择拷贝已有的配置，而忽略了一个很重要的参数DisableExplicitGC，这个参数的意思是禁用显式GC，也就是使System.gc()失效。如果我们在jvm参数中配置了-XX:+DisableExplicitGC，那么带来的后果就是进入到老年代的堆外内存无法被回收掉，最终导致OOM。</p>
<p>至此，一日丧命散的其中毒虫就介绍完了。如果想要活得久，请远离这七条毒虫，哈哈。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/10/27/晋级Review归来话代码有毒/" data-id="ciutny7pf000m5cusi47np0yk" class="article-share-link" data-share="baidu" data-title="晋级Review归来话代码有毒">分享到</a>
      

      
        <a href="http://fengfu.io/2016/10/27/晋级Review归来话代码有毒/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂谈/">杂谈</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-让你变成优秀程序员的几个小习惯" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/24/让你变成优秀程序员的几个小习惯/" class="article-date">
  <time datetime="2016-10-24T11:39:22.000Z" itemprop="datePublished">2016-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/24/让你变成优秀程序员的几个小习惯/">让你变成优秀程序员的几个小习惯(转)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>译文链接：<a href="http://www.codeceo.com/article/habits-to-be-better-programmer.html" target="_blank" rel="external">http://www.codeceo.com/article/habits-to-be-better-programmer.html</a></p>
<p>英文原文：<a href="https://www.quora.com/What-little-habits-made-you-a-better-software-engineer?srid=ieH" target="_blank" rel="external">What little habits made you a better software engineer?</a></p>
<p>翻译作者：<a href="http://www.codeceo.com/" target="_blank" rel="external">码农网</a> – 小峰</p>
<p>作者Jeff Standen，有着21+年经验的软件开发者。</p>
<p><strong>首先开发spike解决方案</strong>——这是我早期敏捷/极限编程所养成的习惯之一。spike解决方案是一次性原型，可以帮助你在投入大量时间和精力之前验证你是否走对路。</p>
<p>区别就在于原型，因为你遵循这样一个规则，在你完成研究之后，你最终会扔掉“spike”代码。所以允许你偷工减料，迅速行动，因为它不会出现在产品或代码审查中。</p>
<p>此方法有助于迅速发现设计的哪些部位尚不明确，而不必过早地尝试架构或设计决策。</p>
<p><strong>致力于小而连贯代码块的版本控制</strong>——通过类似CVS/Subversion，每次提交都直接发送到服务器。做部分文件的提交并不简单。</p>
<p>随着Git的出现，只提交较大文件的若干行代码变得很容易，并且可以在push到远程代码仓库之前先本地rebase/merge提交。</p>
<p>有一次，我在工作于更大功能的时候，采用了小型增量提交，我的工作效率直线上升。这样做能够清空我的大脑以便于面对更重要的事情。</p>
<p><strong>经常写代码</strong>——最近，我正工作于：一个基于Web的企业协作和自动化平台（PHP / MySQL），一个基于云的实时指标聚合器和使用循环哈希（Node.js/ Redis）的API，一个面向iOS app商店（Swift/ SpriteKit）的棋盘游戏，专门的基于URL的cronjob可替代基于web的SaaS服务（JAVA），等等。</p>
<p>用过大量框架和语言有助于我的抽象和算法思维。</p>
<p>我从工具，如Eclipse RCP、Tapestry和Hibernate中学到了很多伟大的经验教训，并用到我的PHP项目里。尤其是在2000年初，在有Java特征的企业生态系统用于PHP存在之前。我从Unity3d/C＃学到了很多关于网络和面向消息的架构。</p>
<p>如果我只坚持单一平台和社区的话，就永远不会知道这些概念。</p>
<p><strong>编写简单的代码</strong>——我以前习惯于写复杂的代码以作为对自己的挑战。而现在的挑战是要编写优雅且简单的代码——到一种每个人都觉得他们也能做到的地步（即使他们不能）。简单代码通常来自于若干次复杂代码的迭代。</p>
<p>引用Antoine de Saint Exupéry的话就是：“不是没有什么可添加，而是没有什么可消减的时候，才算是达到了完美。”</p>
<p>这也使得我们在长时间休止之后返回项目，以及鼓励其他人参与进来变得容易多了。</p>
<p><strong>最后优化</strong>——我们很容易掉入试图比用户或计算机更聪明，并且预优化各种边缘情况的陷阱。关注帕累托法则（80％的效果来自于20％的工作）。写代码，运行代码，当必要的时候专注于最大的瓶颈。这也支持保持代码库的简单。</p>
<p>说“不要首先优化代码”并不意味着“编写粗糙的代码”。代码总是应该精益和优雅，没有必要画蛇添足，不要将一整天的时间用在挤压剩下的10％，但其实已经能够工作良好的一些东西上。不但工作效率会下降，而且还会引进更多复杂性，解决方案变得不那么可归纳，等等。</p>
<p><strong>着眼于“最重要的事情优先”</strong>——总是有一些项目领域比其他的更有趣或更具挑战性。工作于那些有趣的东西总是比工作于那些必要的东西更有诱惑。</p>
<p>在攻克重要部分时，将有趣部分作为一种调剂，也就是说，两者都做一点也是可以。</p>
<p>因此，光从这一点上说，将大的问题分解成小问题的理念是不言自明的。每个人都懂。所以，我会通过计分若干“quick wins”来开启我的一天，这能让我更有冲劲和更专注（“quick wins”可以是任何东西，包括有趣又小型的挑战），然后我会首先冲向“最重要的事情”。</p>
<p><strong>了解全栈</strong>——当我刚开始干这一行的时候，没有什么比等别人做完他们那部分东西，然后我才能继续我那部分工作更糟糕的了（设计师，后端人员，前端人员，数据库人员，服务器人员，等等）。</p>
<p>于是，当我2000年创办自己的软件开发公司的时候，我做了一个明智的决定，那就是涉猎全栈。我知道我不可能擅长所有东西，也不可能是最后唯一对所有一切负责的人，但我想要做终端到终端的原型，因为我没有耐心看过程。</p>
<p>每当我需要的东西触碰到我不懂的领域时，我会研究它。于是乎，我学会了服务器管理，数据库管理，设计，前端/后端开发，云架构等。</p>
<p>通过了解其他领域是做什么的，我才能写出包含它们需要的代码。</p>
<p>当然，其中的一些要点似乎并不是所谓的“小习惯”，但我向你保证，它们是小变化历经20年时间导致的结果。重要的行为变化并没有意义，更多的是关于我是如何频繁地练习这门技术（在过去10年时间中每年大概4000-5000个小时）。</p>
<p>所以，我的做法更像是去回答这个问题：“什么样的小习惯会导致更糟糕的软件和低效的生产力？”，然后反过来。</p>
<h1 id="作者Ed-Prentice，软件工程师"><a href="#作者Ed-Prentice，软件工程师" class="headerlink" title="作者Ed Prentice，软件工程师"></a>作者Ed Prentice，软件工程师</h1><p>时间是宝贵的，所以要尽可能地节省时间。尽可能自动化。一旦时间成为一种商品，那么你可以实现下一个伟大的创新。</p>
<p>使用功能强大的IDE（如vim），并将其配置能为你做尽可能多的事情。力争单个命令Build/Test/Deploy/Run。</p>
<p>如果你发现自己常做某件事情，那么可以让它们在一个按键下发生，或者一次点击下发生。或者更好的是，让它们自动发生。</p>
<p>了解键盘快捷键和UNIX命令行。几乎所有的IDE都可以让你运行复杂的编译命令，甚至任意的终端命令——不但强大，并且可以为你节省大量的时间。</p>
<p>提问题，然后提更多的问题。如果有什么你不明白的事情发生了，那就问为什么。然后走开，研究替代方案，并提出来。一直问问题直到你可以详细地给下一个问为什么的开发人员解释。我时常感到奇怪为什么会有这么多开发人员不知道为什么，仅仅是因为觉得“它总是/曾是这样”。</p>
<p>通过提供更好的替代解决方案挑战现状——并且制定步骤实现。如果你的测试不完整，或每天/每周运行一次——那么成为本地的Continuous Integration大师——目的是为了有利于你的团队，并实现它。一旦你使用它并且它可以帮助你更好工作的话，那么让你的团队也使用它。</p>
<p>不要只是挑战别人，挑战自己。从来没有写过web应用程序？那么写一个。从未用过Python？用Python劫持无人飞行器。</p>
<p>拥有一些东西。创造一些东西。没有必是非要做技术项目，可以是一个事件，例如聚会或编程马拉松，也可以是一个游戏，一个网站，一个博客。</p>
<p>教一些东西。Java，公开演讲，写作，下棋，vim，网球。</p>
<p>成为一个杰出的人。拿到一个垃圾类/组件？修复好它。编写代码的正确途径。不在代码中走捷径。做出明智的决策，向你周围的人说明为什么你要做这个决定的利弊。总是改善代码。制定不需要花费1小时的待办事项表？Just Do It。</p>
<p>浏览你熟悉的Stack Exchange的话题——例如你喜欢的语言。当你发现什么新的东西的时候，尽快末位淘汰相关知识。知道C语言？什么是分支预测？这篇文章会告诉你——你要做的就是学习。</p>
<p>浏览你不熟悉的Stack Exchange的话题——好好学习，天天向上。</p>
<p>学会沟通。书面文字，呈现展示，解决问题，小却激烈的小项目，大型团队，小型团队。</p>
<p>文档化你的所有过程。你可以回头查阅你为什么做这些事情，以及依赖原先的解决方案去解决碰到的相似问题。这还有助于捕捉你可能会忘记的思维过程和关键的信息片段。我经常通过日志来回顾前几天的工作。</p>
<p>在你写之前文档化你的代码。使用系统图，类层次结构，流程图表，以展示说明你的代码将如何工作。如果有人提出建议——是的，他们会提出来的——那么你可以进行修改，这比已经写好了代码再去修改要容易得多。这是另一个我很少看到有人会做但却有着最负面影响的事情。</p>
<p>特定化。为新的东西制作图表，向大家展示。收集尽可能多的细节。确保每个人同意这个图表。如果有人提出了建议，那就补充/添加更正到图表。保持图表更新。</p>
<p>知道潜意思的偏见和男性特权。了解你是哪种MBTI和人格类型，并且更重要的是，要知道如何与其他性格类型更好地互动。了解情商。每个人都是不一样的，你需要知道如何与他们进行最有效和最有建设性的交互。</p>
<p>定期为团队做一些事情。带饼干。教魔术。培育一点文化，并鼓励其他人也这样做。赞美其他人的贡献。一支有凝聚力的团队是很难被击败的。</p>
<p>学习如何与人合作。我个人非常喜欢《The Pragmatic Programmer》的“stone snop”。</p>
<p>理解和使用别人的代码。如果你正在实现自己的XML解析器或或csv阅读器或git hook，那么你就是在重新发明轮子。</p>
<p>一旦你写了代码，并且它是有效的，通过测试的，那么回过头去整理一下吧。重新运行测试。再整理。每个类都应该有单一的职责，每个函数都应该只做一件事情。在大多数情况下，函数应该小于20行代码的长度。使用自文档的函数名和变量名。花时间整理你的代码以后将会10倍地回报给你和你的团队。</p>
<p>参与其中。承担责任。如果事情有不对的地方，那就解决它。如果最后期限临近了又想出了一个解决方案，那让其他人尽快知道。任何人都可以做到这一点，即使是最初级的开发人员。这要求对项目的蓝图，方向和截止期限有着大局观的认识——参与进来。保存好每天的工作内容！</p>
<p>和团队分享学到的经验教训（在适当的时候）。指出Java中finally块内部抛出异常的时候发生了什么？和大家一起分享。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/10/24/让你变成优秀程序员的几个小习惯/" data-id="ciutny7oj00085cususs3eyrh" class="article-share-link" data-share="baidu" data-title="让你变成优秀程序员的几个小习惯(转)">分享到</a>
      

      
        <a href="http://fengfu.io/2016/10/24/让你变成优秀程序员的几个小习惯/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂谈/">杂谈</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-接口文档参考模板" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/23/接口文档参考模板/" class="article-date">
  <time datetime="2016-08-23T01:50:26.000Z" itemprop="datePublished">2016-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/23/接口文档参考模板/">接口文档参考模板</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>虽然提供了在线接口参数的查看，但在和客户端对接过程中，我们作为后台开发，还是需要人工提供接口文档给客户端的，这里提供一个接口文档编写的模板，以供参考，并且以我们熟悉的?service=User.GetBaseInfo为例说明如何编写高效的文档。  </p>
<p> <em>温馨提示：斜体字表示是注释说明</em>。  </p>
<p>##功能说明<br><em>对接口功能的简单说明。</em><br>获取用户的基本信息。</p>
<p>##接口URL<br><em>请求的相对链接和当前接口级参数，通常为?service=XXX.XXX + 公共接口参数。</em><br>/demo/?service=User.GetBaseInfo  </p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a><a href="http://phalapi.oschina.mopaas.com/Public/demo/checkApiParams.php?service=User.GetBaseInfo" target="_blank" rel="external">参数说明</a></h2><p><em>对当前接口级参数的说明，建议使用在线接口参数查询工具，但以下的参数说明也是需要的。</em>  </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>名字</th>
<th>是否必须</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>userId</td>
<td>用户ID</td>
<td>是</td>
<td>表示用户的ID</td>
<td>&amp;user_iduser_id=1</td>
</tr>
</tbody>
</table>
<p>##返回参数<br><em>对当前接口级返回参数的说明，即对{“ret”:返回状态码,”data”:”应该业务数据”,”msg”:”错误提示”}中的data部分进行说明。</em>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#10;    &#34;ret&#34;: 200,&#10;    &#34;data&#34;: &#123;&#10;        &#34;code&#34;: 0,  //code=0&#34920;&#31034;&#27491;&#30830;&#33719;&#21462;&#29992;&#25143;&#20449;&#24687;&#65292;code=1&#26102;&#34920;&#31034;&#29992;&#25143;&#19981;&#23384;&#22312;&#10;        &#34;msg&#34;: &#34;&#34;,   //&#19994;&#21153;&#25552;&#31034;&#25991;&#26696;&#10;        &#34;info&#34;: &#123;  //&#20165;&#24403;code=0&#30340;&#24773;&#20917;&#19979;&#38750;&#31354;&#19988;&#26377;&#29992;&#25143;&#20449;&#24687;&#10;            &#34;id&#34;: &#34;1&#34;,  //&#29992;&#25143;ID   &#10;            &#34;name&#34;: &#34;dogstar&#34;,  //&#29992;&#25143;&#21517;&#10;            &#34;from&#34;: &#34;oschina&#34;  //&#29992;&#25143;&#26469;&#28304;&#10;        &#125;&#10;    &#125;,&#10;    &#34;msg&#34;: &#34;&#34;&#10;&#125;&#10;```  &#9;  &#10;&#10;  &#10;##&#31034;&#20363;&#10; _&#33267;&#23569;&#24212;&#21253;&#25324;&#25104;&#21151;&#31034;&#20363;&#65292;&#22833;&#36133;&#31034;&#20363;&#21487;&#36873;_     &#10;  &#10;###&#25104;&#21151;&#31034;&#20363;&#10;&#35831;&#27714;&#65306;</span><br></pre></td></tr></table></figure>
<p><a href="http://phalapi.oschina.mopaas.com/Public/demo/?service=User.GetBaseInfo&amp;user_iduser_id=1" target="_blank" rel="external">http://phalapi.oschina.mopaas.com/Public/demo/?service=User.GetBaseInfo&amp;user_iduser_id=1</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#36820;&#22238;&#65306;</span><br></pre></td></tr></table></figure></p>
<p>{<br>    “ret”: 200,<br>    “data”: {<br>        “code”: 0,<br>        “msg”: “”,<br>        “info”: {<br>            “id”: “1”,<br>            “name”: “dogstar”,<br>            “from”: “oschina”<br>        }<br>    },<br>    “msg”: “”<br>}<br>```</p>
<hr>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/08/23/接口文档参考模板/" data-id="ciutny7pl000o5cusa4y84wpa" class="article-share-link" data-share="baidu" data-title="接口文档参考模板">分享到</a>
      

      
        <a href="http://fengfu.io/2016/08/23/接口文档参考模板/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂谈/">杂谈</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-晋级Review归来话答辩" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/22/晋级Review归来话答辩/" class="article-date">
  <time datetime="2016-08-22T01:50:26.000Z" itemprop="datePublished">2016-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/22/晋级Review归来话答辩/">晋级Review归来话答辩</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>每半年一次的晋级季结束了，这次自己团队的同学有参加晋级的，需要帮他们过PPT以及预演，同时也参加了其他同学的晋级答辩。在这过程中发现了很多问题，觉得有必要写出来总结一下了，以帮助同学们写好PPT和做好答辩工作。</p>
<h1 id="PPT中的常见问题"><a href="#PPT中的常见问题" class="headerlink" title="PPT中的常见问题"></a>PPT中的常见问题</h1><h2 id="1-没有大纲"><a href="#1-没有大纲" class="headerlink" title="1.没有大纲"></a>1.没有大纲</h2><p>写PPT跟上学的时候写作文有点类似，我们需要先把大纲列出来，否则写出来的内容就容易有缺失，内容也不连贯。这样的PPT在讲的时候也会让你很纠结，听众更难受。</p>
<h2 id="2-前后不连贯"><a href="#2-前后不连贯" class="headerlink" title="2.前后不连贯"></a>2.前后不连贯</h2><p>一个好的PPT，前后之间应该有关联，不应该彼此孤立。很多时候，我们需要通过前面的片子来引出后面的内容，也就是俗话说的“抛砖引玉”。典型的场景比如：通过项目特点/难点，引出后面的挑战/遇到的问题，最后引出如何解决。这样下来，整个PPT就会顺畅很多。</p>
<h2 id="3-重要内容有遗漏"><a href="#3-重要内容有遗漏" class="headerlink" title="3.重要内容有遗漏"></a>3.重要内容有遗漏</h2><p>此处说的重要内容是指契合公司文化的内容，比如去哪儿来说，推崇工程师文化，那么你平时的工作中，通过工具提升工作效率，或者开发一些组件这样的事情就比较值得拿出来说。但是有些人可能觉得这些事情不重要而忽略，那么就是一种损失。</p>
<p>其实任何工作都是这样，你如果只是做好本职工作（自扫门前雪），这本身就是一个基本要求，你做好是应该的。但是如果你对自己要求高一些，站在整个团队的角度，或者站在整个公司的角度看待问题或者做一些事情，那么这个事情的高度就会更高一些，做出的成绩可能也会更大。所以从这一点来讲，作为工程师，在做事的态度和方式上，也应该立足高远才好。</p>
<h2 id="4-文字太多"><a href="#4-文字太多" class="headerlink" title="4.文字太多"></a>4.文字太多</h2><p>一页PPT最好不要超过30字，这是一个基本原则，希望能够尽量遵守。因为人是视觉动物，当看到密密麻麻的字的时候，首先会选择放弃。我们来看一下下面这张PPT，看到的第一眼你是什么感觉？<br><img src="https://img.alicdn.com/imgextra/i2/2657627814/TB2BPAMaxmJ.eBjy0FhXXbBdFXa_!!2657627814.png" alt=""></p>
<p>再来看这张：</p>
<p><img src="https://img.alicdn.com/imgextra/i4/2657627814/TB2ta.PaCqJ.eBjy1zbXXbx8FXa_!!2657627814.png" alt=""></p>
<p>相比上一张，是不是清爽了很多？</p>
<p>另外，关于PPT的文字，给大家的建议是用微软雅黑，微软雅黑无论在表现汉字还是字母数字都比较圆润，看起来比较舒服。尽量不要用宋体，因为宋体边缘较窄，会给人带来视觉上的沉重感。</p>
<h2 id="5-没有图表"><a href="#5-没有图表" class="headerlink" title="5.没有图表"></a>5.没有图表</h2><p>俗话说，一图胜千言。作为工程师，我们可以通过架构图来描述对系统的理解，通过流程图来描述对业务/流程的理解，通过类图来描述代码实现。通过监控图/表格来描述结果，这样你的PPT内容就会更加丰满，形式也更加漂亮。</p>
<h2 id="6-动画太过花哨"><a href="#6-动画太过花哨" class="headerlink" title="6.动画太过花哨"></a>6.动画太过花哨</h2><p>既然我们是工程师，不是视觉设计师，所以那些花哨的动画就免了吧，毕竟这不是我们的专长，简单的淡出效果就挺好了。当然，如果你想要用动画来描述一些状态流转之类的，那么你可以去花点时间。</p>
<h1 id="答辩时的常见问题"><a href="#答辩时的常见问题" class="headerlink" title="答辩时的常见问题"></a>答辩时的常见问题</h1><h2 id="1-没有事先调试好投影"><a href="#1-没有事先调试好投影" class="headerlink" title="1.没有事先调试好投影"></a>1.没有事先调试好投影</h2><p>经常看见有的同学到答辩的时候才去调试投影仪，出了问题之后不得不借别人的电脑。这种事情以后还是要避免，其实只要提前做一下调试就可以了，花不了几分钟时间，但最起码可以避免现场糗个大的。</p>
<h2 id="2-PPT没有预演，直接开讲"><a href="#2-PPT没有预演，直接开讲" class="headerlink" title="2.PPT没有预演，直接开讲"></a>2.PPT没有预演，直接开讲</h2><p>这也是很多人容易犯的错误。我们在写PPT的时候，可能会觉得思如泉涌，PPT很顺畅就做完了。但其实做完了是一回事，你能顺畅地讲出来又是一回事了，可能那时候你会发现自己的PPT怎么做的那么烂，连舌头都不灵活了…… 所以最好的方式是：写完PPT之后先给自己讲两遍，自己讲顺畅了再去给别人讲。</p>
<h2 id="3-没有自我介绍"><a href="#3-没有自我介绍" class="headerlink" title="3.没有自我介绍"></a>3.没有自我介绍</h2><p>陌生人见面总是要打个招呼，做个自我介绍吧，有些同学一上来就直奔主题，一来容易搞得自己紧张，二来显得有点不礼貌。</p>
<h2 id="4-紧张"><a href="#4-紧张" class="headerlink" title="4.紧张"></a>4.紧张</h2><p>这是很多人都会出现的问题，有的人紧张的连声调都变了。针对这个问题，我的建议是：1.开始讲PPT前，先做一个深呼吸；2. 站着讲。站着讲的一个好处是，你可以通过肢体动作调节自己的情绪和节奏。</p>
<h2 id="5-代码没好好准备"><a href="#5-代码没好好准备" class="headerlink" title="5.代码没好好准备"></a>5.代码没好好准备</h2><p>很多同学只重视PPT，却没有认真准备代码，结果review代码的时候被虐，当然最终的结局也就不乐观。</p>
<p>最后，给大家推荐一本书，《<a href="https://item.jd.com/11697566.html" target="_blank" rel="external">乔布斯的魔力演讲</a>》，相信这本书可以帮助你提高PPT及演讲能力。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/08/22/晋级Review归来话答辩/" data-id="ciutny7pa000k5cus6tkykjvi" class="article-share-link" data-share="baidu" data-title="晋级Review归来话答辩">分享到</a>
      

      
        <a href="http://fengfu.io/2016/08/22/晋级Review归来话答辩/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂谈/">杂谈</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记-微服务设计-建模" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/12/读书笔记-微服务设计-建模/" class="article-date">
  <time datetime="2016-08-12T12:52:17.000Z" itemprop="datePublished">2016-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/12/读书笔记-微服务设计-建模/">读书笔记:微服务设计-建模</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-什么样的服务是好服务"><a href="#1-什么样的服务是好服务" class="headerlink" title="1.什么样的服务是好服务"></a>1.什么样的服务是好服务</h1><h2 id="1-高内聚"><a href="#1-高内聚" class="headerlink" title="1.高内聚"></a>1.高内聚</h2><p>  说到高内聚，还是得提一下单一职责原则(Single Responsibility Principle)。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障，而避免出现这一问题的方法便是遵循单一职责原则。<br>  那如何来做到服务的高内聚呢？首先要确定问题域的边界，其次将相同边界的相关行为放在一个地方。</p>
<h2 id="2-低耦合"><a href="#2-低耦合" class="headerlink" title="2.低耦合"></a>2.低耦合</h2><p>  使用微服务最重要的一点是：能够独立修改及部署单个服务而不需要修改系统的其他部分。</p>
<h1 id="2-限界上下文"><a href="#2-限界上下文" class="headerlink" title="2.限界上下文"></a>2.限界上下文</h1><p>  限界上下文(bounded context)这个概念来自于Eric Evans的《领域驱动设计》一书，Eric认为：一个给定的领域包含多个限界上下文，每个限界上下文中的东西分成2个部分，一部分不需要与外界通信，另一部分则需要。每个上下文都有明确的接口，该接口决定了它会暴露哪些模型给其他的上下文。当然本文作者更喜欢这个定义：一个由显示边界限定的特定职责。如果你想要从一个限界上下文中获取信息，或者向其发起请求，需要使用模型和它的显示边界进行通信。</p>
<p>  应该共享特定的模型，而不应该共享内部表示，这样就可以避免潜在的紧耦合风险。</p>
<p>  一般来讲，微服务应该清晰地和限界上下文相对应。</p>
<h1 id="3-业务功能"><a href="#3-业务功能" class="headerlink" title="3.业务功能"></a>3.业务功能</h1><p>  在思考组织内的限界上下文时，不应该从共享数据的角度来考虑，应该从这些上下文能够提供的功能来考虑。首先要问自己：这个上下文是做什么用的，然后再考虑它需要什么样的数据。</p>
<p>  建模服务时，应该将这些功能作为关键操作提供给其协作者。</p>
<h1 id="4-逐步划分上下文"><a href="#4-逐步划分上下文" class="headerlink" title="4.逐步划分上下文"></a>4.逐步划分上下文</h1><p>  先识别粗粒度上下文，然后当发现合适的缝隙后，再进一步划分出那些嵌套的上下文。</p>
<p>  对于嵌套上下文，一种方式是嵌套上下文不直接对外可见，另外一种方式是限界上下文被提升到顶层上下文的层次。这两种方式都具有其合理性，具体还要看组织机构的划分。比如服务A、服务B、服务C分别由不同团队维护，那么可能大家倾向于成为顶层上下文；如果由一个团队维护，那么嵌套架构会更合理。另外，从测试的角度，嵌套式上下文更便于测试，毕竟它对外暴露的服务更少。</p>
<p>另外一本书推荐：Vaughn Vernon的<a href="http://item.jd.com/11423256.html" target="_blank" rel="external">《实现领域驱动设计》</a>，这本书貌似卖得更好。</p>
<p><em>图片说明：稻城-亚丁</em></p>
<p>稻城—亚丁因其独特而原始的自然环境、美丽风景被誉为“最后的香格里拉”，景点分为稻城和亚丁两部分，有雪山、冰川、峡谷、森林、草甸、湖泊等景观。除了珍珠海、牛奶海等冰川湖泊，稻城最令人向往的是驰名藏区的雪域神峰——稻城神峰，它由仙乃日、央迈勇、夏诺多吉三座神山组成，均位于亚丁自然保护区。人们把仙乃日比作大佛、把央迈勇比作少女，将夏诺多吉当作少年，三座神山就像三尊圣灵，这里也就成了藏民心中朝圣的圣地。</p>
<p><img src="https://img.alicdn.com/imgextra/i1/2657627814/TB29IAuXaryQeBjSszdXXaL.XXa_!!2657627814.jpg" alt="稻城-亚丁"></p>
<p><img src="https://img.alicdn.com/imgextra/i4/2657627814/TB24zkuXabyQeBjy1XbXXa9yXXa_!!2657627814.jpg" alt="稻城-亚丁"></p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2GWAvXhHxQeBjy1zjXXa5YVXa_!!2657627814.jpg" alt="稻城-亚丁"></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/08/12/读书笔记-微服务设计-建模/" data-id="ciutny7og00065cusvyedc4u5" class="article-share-link" data-share="baidu" data-title="读书笔记:微服务设计-建模">分享到</a>
      

      
        <a href="http://fengfu.io/2016/08/12/读书笔记-微服务设计-建模/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微服务/">微服务</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-关键业务系统的JVM启动参数推荐2-0版-转" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/07/关键业务系统的JVM启动参数推荐2-0版-转/" class="article-date">
  <time datetime="2016-08-07T02:20:22.000Z" itemprop="datePublished">2016-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/07/关键业务系统的JVM启动参数推荐2-0版-转/">关键业务系统的JVM启动参数推荐2.0版[转]</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>注：本文转自SpringSide的作者江南白衣的博客“<a href="http://calvin1978.blogcn.com/articles/jvmoption-2.html" target="_blank" rel="external">关键业务系统的JVM启动参数推荐 2.0版</a>”，如需转载，请尊重作者权利，注明原文出处，谢谢。</p>
<p>在关键的业务系统里，除了继续追求技术人员最爱的高吞吐与低延时之外，系统的稳定性与出现问题时排查的便捷性也很重要。</p>
<p>这是本文的一个原则，后面也会一次又一次的强调，所以与网上其他的文章略有不同，请调优高手和运维老大们多指引。</p>
<p>更新记录：</p>
<p>2.0版，增加 -XX:+PerfDisableSharedMem，GC日志指向/dev/shm，避免IO造成的JVM停顿。</p>
<h1 id="前言1，资料"><a href="#前言1，资料" class="headerlink" title="前言1，资料"></a>前言1，资料</h1><p>学习开源项目的启动脚本是个不错的主意，比如<a href="https://github.com/apache/cassandra/blob/trunk/conf/cassandra-env.sh" target="_blank" rel="external">Cassandra</a>家的， 附送一篇<a href="https://tobert.github.io/pages/als-cassandra-21-tuning-guide.html" target="_blank" rel="external">解释它的文章</a>。</p>
<p><a href="http://hllvm.group.iteye.com/group/topic/27945" target="_blank" rel="external">JVM调优的”标准参数”的各种陷阱</a> R大的文章，在JDK6时写的，期待更新。</p>
<p>偶然翻到Linkedin工程师的<a href="http://www.importnew.com/11336.html" target="_blank" rel="external">一篇文章</a>。</p>
<p>更偶然翻到的<a href="http://www.techpaste.com/2012/02/java-command-line-options-jvm-performance-improvement/" target="_blank" rel="external">一份不错的参数列表</a>。</p>
<h1 id="前言2，-XX-PrintFlagsFinal打印参数值"><a href="#前言2，-XX-PrintFlagsFinal打印参数值" class="headerlink" title="前言2， -XX:+PrintFlagsFinal打印参数值"></a>前言2， -XX:+PrintFlagsFinal打印参数值</h1><p>当你在网上兴冲冲找到一个可优化的参数时，先用-XX: +PrintFlagsFinal看看，它可能已经默认打开了，再找到一个，还是默认打开了…</p>
<p>JDK7与JDK8，甚至JDK7中的不同版本，有些参数值都不一样，所以不要轻信网上任何文章，一切以生产环境同版本的JDK打出来的为准。</p>
<p>经常以类似下面的语句去查看参数，偷懒不起应用，用-version代替。有些参数设置后会影响其他参数，所以查看时也把它带上。</p>
<pre><code>java -server -Xmx1024m -Xms1024m -XX:+UseConcMarkSweepGC -XX:+PrintFlagsFinal -version| grep ParallelGCThreads
</code></pre><h1 id="前言3，关于默认值"><a href="#前言3，关于默认值" class="headerlink" title="前言3，关于默认值"></a>前言3，关于默认值</h1><p>JDK8会默认打开-XX:+TieredCompilation多层编译，而JDK7则不会。JDK7u40以后的版本会默认打开-XX:+OptimizeStringConcat优化字符串拼接，而之前的则不打开。</p>
<p>对于这些参数，我的建议是顺势而为，JDK在那个版本默认打开不打开总有它的理由。安全第一，没有很好的因由，不要随便因为网上某篇文章的推荐(包括你现在在读的这篇)就去设置。</p>
<h1 id="1-性能篇"><a href="#1-性能篇" class="headerlink" title="1. 性能篇"></a>1. 性能篇</h1><p>先写一些不那么常见的，后面再来老生常谈。</p>
<h2 id="1-1-取消偏向锁-XX-UseBiasedLocking"><a href="#1-1-取消偏向锁-XX-UseBiasedLocking" class="headerlink" title="1.1 取消偏向锁 -XX:-UseBiasedLocking"></a>1.1 取消偏向锁 -XX:-UseBiasedLocking</h2><p>JDK1.6开始默认打开的偏向锁，在没有竞争的情况下，会取消线程同步的原语，比如那个所有方法都挂着synchronized关键字的StringBuffer，如果始终只有一条线程在访问它，就略过同步操作以获得性能提升。</p>
<p>但一旦有第二条线程访问这把锁，JVM就要撤销偏向锁恢复到未锁定线程的状态，用”-XX:+PrintSafepointStatistics -XX :P rintSafepointStatisticsCount=1” 可以看到不少RevokeBiasd的纪录，像GC一样，会Stop The World的干活，虽然只是很短很短的停顿，但对于多线程并发的应用，取消掉它反而有性能的提升和延时的极微的缩短，所以Cassandra就取消了它。</p>
<h2 id="1-2-启动时访问并置零内存页面-XX-AlwaysPreTouch"><a href="#1-2-启动时访问并置零内存页面-XX-AlwaysPreTouch" class="headerlink" title="1.2 启动时访问并置零内存页面-XX:+AlwaysPreTouch"></a>1.2 启动时访问并置零内存页面-XX:+AlwaysPreTouch</h2><p>启动时就把参数里说好了的内存全部舔一遍，可能令得启动时慢上一点，但后面访问时会更流畅，比如页面会连续分配，比如不会在晋升新生代到老生代时才去申请页面使得GC停顿时间加长。不过这选项对32G之类的大堆才会更有感觉一点。</p>
<h2 id="1-3-Djava-security-egd-file-dev-urandom"><a href="#1-3-Djava-security-egd-file-dev-urandom" class="headerlink" title="1.3 -Djava.security.egd=file:/dev/./urandom"></a>1.3 -Djava.security.egd=file:/dev/./urandom</h2><p>UUID.randomUUID() 有时候会很慢，Thread Dump一看居然被锁住了，原因是里面用了SecureRandom，要等待机器产生新的噪音(比如机器里的某个文件发生了变化)才肯产生新的随机数。因此最好让熵池里没有新的噪音因子时重用当前的因子。详见 <a href="http://blog.csdn.net/xiaoxinyu316/article/details/39064003" target="_blank" rel="external">JVM上的随机数与熵池策略</a></p>
<h2 id="1-4-XX-AutoBoxCacheMax-20000"><a href="#1-4-XX-AutoBoxCacheMax-20000" class="headerlink" title="1.4 -XX:AutoBoxCacheMax=20000"></a>1.4 -XX:AutoBoxCacheMax=20000</h2><p>Integer i = 3;这语句有着 int自动装箱成Integer的过程，JDK默认只缓存 -128 ~ +127的int 和 long，超出范围的数字就要即时构建新的Integer对象。设为20000后，我们应用的QPS从48,000提升到50,000，足足4%的影响。详见<a href="http://blog.csdn.net/chengzhezhijian/article/details/9628251" target="_blank" rel="external">Java Integer(-128~127)值的==和equals比较产生的思考</a></p>
<h2 id="1-5-XX-PerfDisableSharedMem"><a href="#1-5-XX-PerfDisableSharedMem" class="headerlink" title="1.5 -XX:+PerfDisableSharedMem"></a>1.5 -XX:+PerfDisableSharedMem</h2><p>Cassandra家的一个参数，一直没留意，直到发生高IO时的JVM停顿。原来每次进入安全点（比如GC）, JVM都会默默的在/tmp/hperf 目录写上一点statistics数据，如果刚好遇到PageCache刷盘，把文件阻塞了，就不能结束这个Stop the World的安全点了。用此参数可以禁止JVM写statistics数据，代价是VisualVM和jstat用不了，只能用JMX取数据，但在生产环境本来就不需要VisaulVM。详见<a href="http://calvin1978.blogcn.com/articles/%20http://www.evanjones.ca/jvm-mmap-pause.html" target="_blank" rel="external">The Four Month Bug: JVM statistics cause garbage collection pauses</a></p>
<h2 id="1-6-不建议的参数"><a href="#1-6-不建议的参数" class="headerlink" title="1.6 不建议的参数"></a>1.6 不建议的参数</h2><p>-XX:+AggressiveOpts是一些还没默认打开的优化参数集合, -XX:AutoBoxCacheMax是其中的一项。但如前所述，关键系统里不建议打开。虽然通过-XX:+AggressiveOpts 与 -XX:-AggressiveOpts 的对比，目前才改变了三个参数，但为免以后某个版本的JDK里默默改变更多激进的配置，还是不要了。</p>
<p>Linkined那种黑科技，先要解锁VMOptions才能配置的就更不用说了，比如</p>
<pre><code>-XX:+UnlockDiagnosticVMOptions -XX: ParGCCardsPerStrideChunk=32768
</code></pre><p>JIT Compile相关的参数，函数调用多少次之后开始编译的阀值，内联函数大小的阀值等等，不要乱改了。</p>
<p>-XX:+UseFastAccessorMethods，据说在多层编译下还慢了，所以是默认关闭的。</p>
<h2 id="1-7-server"><a href="#1-7-server" class="headerlink" title="1.7 -server"></a>1.7 -server</h2><p>-server 与 -client的JVM默认参数完全不一样，虽然在Linux 64位JVM里默认会被认成server模式，但还是顺手写上吧。</p>
<h2 id="1-8-GC策略"><a href="#1-8-GC策略" class="headerlink" title="1.8 GC策略"></a>1.8 GC策略</h2><p>为了稳健，还是8G以下的堆还是CMS好了，G1的细节实现起来难度太大，从理论提出到现在都做了六七年了。</p>
<p>CMS真正可设的东西也不多，详见<a href="http://ifeve.com/useful-jvm-flags-part-7-cms-collector/" target="_blank" rel="external">JVM实用参数（七）CMS收集器</a></p>
<pre><code>-XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly
</code></pre><p>因为我们的监控系统会通过JMX监控内存达到90%的状况（留点处理的时间），所以设置让它75%就开始跑了，早点开始也能避免Full GC等意外情况(概念重申，这种主动的CMS GC，和JVM的老生代、永久代、堆外内存完全不能分配内存了而强制Full GC是不同的概念)。为了让这个设置生效，还要设置-XX:+UseCMSInitiatingOccupancyOnly，否则75只被用来做开始的参考值，后面还是JVM自己算。</p>
<p>-XX:MaxTenuringThreshold=2，这是GC里改动效果最明显的一个参数了。对象在Survivor区熬过多少次Young GC后晋升到年老代，JDK7里看起来默认是6，跑起来好像变成了15。</p>
<p>Young GC是最大的应用停顿来源，而新生代里GC后存活对象的多少又直接影响停顿的时间，所以如果清楚Young GC的执行频率和应用里大部分临时对象的最长生命周期，可以把它设的更短一点，让其实不是临时对象的新生代长期对象赶紧晋升到年老代，别呆着。</p>
<p>用-XX:+PrintTenuringDistribution观察下，如果后面几代都差不多，就可以设小，比如JMeter里是2。而我们的两个系统里一个设了2，一个设了6。</p>
<p>-XX:+ExplicitGCInvokesConcurrent， 但不要-XX:+DisableExplicitGC， 比如<a href="http://calvin1978.blogcn.com/articles/directbytebuffer.html" target="_blank" rel="external">Netty之堆外内存扫盲篇</a>，可见禁了system.gc() 未必是好事，只要自己的代码里没有调它，也没用什么特别烂的类库，真有人调了总有调的原因。-XX+ExplicitGCInvokesConcurrent 则在full gc时，并不全程停顿，依然只在ygc和两个remark阶段停顿，详见<a href="http://lovestblog.cn/blog/2015/05/07/system-gc/" target="_blank" rel="external">JVM源码分析之SystemGC完全解读</a></p>
<p>-XX: ParallelRefProcEnabled , 默认为false，并行的处理Reference对象，如WeakReference，除非在GC log里出现Reference处理时间较长的日志，否则效果不会很明显，但我们总是要JVM尽量的并行，所以设了也就设了。</p>
<h2 id="1-9-GC里不建议设的参数"><a href="#1-9-GC里不建议设的参数" class="headerlink" title="1.9 GC里不建议设的参数"></a>1.9 GC里不建议设的参数</h2><p>-XX:+CMSClassUnloadingEnabled，在CMS中清理永久代中的过期的Class而不等到Full GC，JDK7默认关闭而JDK8打开。看自己情况，比如有没有运行动态语言脚本如Groovy产生大量的临时类。它会增加CMS remark的暂停时间，所以如果新类加载并不频繁，这个参数还是不开的好。</p>
<p>用了CMS，新生代收集默认就是-XX:+UseParNewGC，不用自己设。</p>
<p>并发收集线程数，ParallelGCThreads＝8+( Processor - 8 ) ( 5/8 )， ConcGCThreads = (ParallelGCThreads + 3)/4，比如双CPU，六核，超线程就是24个处理器，小于8个处理器时ParallelGCThreads按处理器数量，大于时按上述公式ParallelGCThreads＝18， ConcGCThreads＝5。这线程数调整了变化也不大，还是别乱动了。</p>
<p>-XX:+CMSScavengeBeforeRemark，默认为关闭，在CMS remark前，先执行一次minor GC将新生代清掉，这样从老生代的对象引用到的新生代对象的个数就少了，停止全世界的CMS remark阶段就短一些。如果看到GC日志里remark阶段的时间超长，可以打开此项看看有没有效果，否则还是不要打开了，白白多了次GC。</p>
<p>-XX:CMSFullGCsBeforeCompaction，默认为0，即每次full gc都对老生代进行碎片整理压缩。Full GC 不同于 前面设置的75%老生代时触发的CMS GC，只在System.gc()，老生代达到100%，老生代碎片过大无法分配空间给新晋升的大对象这些特殊情况里发生，所以设为每次都进行碎片整理是合适的，详见此贴里R大的解释。</p>
<h2 id="1-10-内存大小的设置"><a href="#1-10-内存大小的设置" class="headerlink" title="1.10 内存大小的设置"></a>1.10 内存大小的设置</h2><p>这些关于大小的参数，给人感觉是最踏实可控的。</p>
<p>其实JVM除了显式设置的-Xmx堆内存，还有一堆其他占内存的地方(堆外内存，线程栈，永久代，二进制代码cache)，在容量规划的时候要留意。</p>
<p>关键业务系统的服务器上内存一般都是够的，所以尽管设得宽松点。</p>
<p>-Xmx, -Xms, 堆内存大小，2～4G均可，再大了GC时间会拖长。</p>
<p>-Xmn or -XX:NewSize and -XX:MaxNewSize or -XX:NewRatio， JDK默认新生代占堆大小的1/3， 个人喜欢把对半分， 增大新生代的大小，能减少GC的频率（但也会加大每次GC的停顿时间），主要是看老生代里没多少长期对象的话，占2/3太多了。可以用-Xmn 直接赋值(等于-XX:NewSize and -XX:MaxNewSize同值的缩写)，或把NewRatio设为1来对半分(但如果想设置新生代比老生代大就只能用-Xmn)。</p>
<p>-XX: PermSize=128m -XX:MaxPermSize=512m （JDK7）现在的应用有Hibernate/Spring这些闹腾的家伙AOP之后类都比较多，可以一开始就把初始值从64M设到128M，并设一个更大的Max值以求保险。</p>
<p>-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m（JDK8），JDK8的永生代几乎可用完机器的所有内存，同样设一个128M的初始值，512M的最大值保护一下。</p>
<h2 id="1-11-其他内存大小等可选设置"><a href="#1-11-其他内存大小等可选设置" class="headerlink" title="1.11 其他内存大小等可选设置"></a>1.11 其他内存大小等可选设置</h2><p>-XX:SurvivorRatio 新生代中每个存活区的大小，默认为8，即1/10的新生代 1/(SurvivorRatio+2)，有人喜欢设小点省点给新生代，但要避免太小使得存活区放不下临时对象而要晋升到老生代，还是从GC Log里看实际情况了。</p>
<p>-Xss 在堆之外，线程占用栈内存，默认每条线程为1M（以前是256K）。除了方法调用出参入参的栈，逃逸分析后也会把只在该线程里可见的对象直接分配在线程栈里，而不是公共的Heap里，也就减少了新生代的GC频率。有人喜欢设小点节约内存开更多线程，但反正内存够也就不必要设小，有人喜欢再设大点。</p>
<p>-XX:MaxDirectMemorySize，堆外内存/直接内存的大小，默认为Heap区总内存减去一个Survivor区的大小，详见<a href="http://calvin1978.blogcn.com/articles/directbytebuffer.html" target="_blank" rel="external">Netty之堆外内存扫盲篇</a>。</p>
<p>-XX:ReservedCodeCacheSize， JIT编译后二进制代码的存放区，满了之后就不再编译。JDK7默认不开多层编译48M，开了96M，而JDK8默认开多层编译256M。可以在JMX里看看CodeCache的大小，JDK7下的48M一般够了，也可以把它设大点，反正内存多。</p>
<h1 id="2-监控篇"><a href="#2-监控篇" class="headerlink" title="2. 监控篇"></a>2. 监控篇</h1><p>JVM输出的各种日志，如果未指定路径，通常会生成到运行应用的相同目录，为了避免有时候在不同的地方执行启动脚本，一般将日志路径集中设到一个固定的地方。</p>
<h2 id="2-1-XX-PrintCommandLineFlags"><a href="#2-1-XX-PrintCommandLineFlags" class="headerlink" title="2.1 -XX:+PrintCommandLineFlags"></a>2.1 -XX:+PrintCommandLineFlags</h2><p>运维有时会对启动参数做一些临时的更改，将每次启动的参数输出到stdout，将来有据可查。<br>打印出来的是命令行里设置了的参数以及因为这些参数隐式影响的参数，比如开了CMS后，-XX:+UseParNewGC也被自动打开。</p>
<h2 id="2-2-XX-OmitStackTraceInFastThrow"><a href="#2-2-XX-OmitStackTraceInFastThrow" class="headerlink" title="2.2 -XX:-OmitStackTraceInFastThrow"></a>2.2 -XX:-OmitStackTraceInFastThrow</h2><p>为异常设置StackTrace是个昂贵的操作，所以当应用在相同地方抛出相同的异常N次(两万?)之后，JVM会对某些特定异常如NPE，数组越界等进行优化，不再带上异常栈。此时，你可能会看到日志里一条条Null Point Exception，而真正输出完整栈的日志早被滚动到不知哪里去了，也就完全不知道这NPE发生在什么地方，欲哭无泪。 所以，将它禁止吧。</p>
<h2 id="2-3-coredump与-XX-ErrorFile"><a href="#2-3-coredump与-XX-ErrorFile" class="headerlink" title="2.3 coredump与 -XX:ErrorFile"></a>2.3 coredump与 -XX:ErrorFile</h2><p>JVM crash时，hotspot 会生成一个error文件，提供JVM状态信息的细节。如前所述，将其输出到固定目录，避免到时会到处找这文件。文件名中的%p会被自动替换为应用的PID</p>
<pre><code>-XX:ErrorFile=${MYLOGDIR}/hs_err_%p.log
</code></pre><p>当然，更好的做法是生成coredump，从CoreDump能够转出Heap Dump 和 Thread Dump 还有crash的地方，非常实用。</p>
<p>在启动脚本里加上 ulimit -c unlimited或其他的设置方式，如果有root权限，用一下一下输出目录更好</p>
<pre><code>echo &quot;/{MYLOGDIR}/coredump.%p&quot; &gt; /proc/sys/kernel/core_pattern
</code></pre><p>什么？你不知道这东西什么用？看来你是没遇过JVM Segment Fault的幸福人。</p>
<h2 id="2-4-XX-HeapDumpOnOutOfMemoryError"><a href="#2-4-XX-HeapDumpOnOutOfMemoryError" class="headerlink" title="2.4 -XX:+HeapDumpOnOutOfMemoryError"></a>2.4 -XX:+HeapDumpOnOutOfMemoryError</h2><p>在Out Of Memory，JVM快死快死掉的时候，输出Heap Dump到指定文件。不然开发很多时候还真不知道怎么重现错误。</p>
<p>路径只指向目录，JVM会保持文件名的唯一性，叫java_pid${pid}.hprof。如果指向文件，而文件已存在，反而不能写入。</p>
<pre><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${LOGDIR}/
</code></pre><h2 id="2-5-GC日志"><a href="#2-5-GC日志" class="headerlink" title="2.5 GC日志"></a>2.5 GC日志</h2><pre><code>-Xloggc:/dev/shm/gc-myapplication.log -XX:+PrintGCDateStamps -XX:+PrintGCDetails
</code></pre><p>详见<a href="http://ifeve.com/useful-jvm-flags-part-8-gc-logging/" target="_blank" rel="external">JVM实用参数（八）GC日志</a>，有人担心写GC日志会影响性能，但测试下来实在没什么影响，还是留一份用来排查好。</p>
<p>到后来，又发现如果遇上高IO的情况，如果GC的时候，操作系统正在flush pageCache 到磁盘，也可能导致GC log文件被锁住，从而让GC结束不了。所以把它指向了/dev/shm 这种内存中数据库，避免这种停顿，详见<a href="http://calvin1978.blogcn.com/articles/%E2%80%9Chttps://engineering.linkedin.com/blog/2016/02/eliminating-large-jvm-gc-pauses-caused-by-background-io-traffic%E2%80%9D" target="_blank" rel="external">Eliminating Large JVM GC Pauses Caused by Background IO Traffic</a></p>
<p>另外还有一个-XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime，它的名字没起好，它除了打印清晰的GC停顿时间外，还可以打印其他的停顿时间，比如取消偏向锁，class 被agent redefine，code deoptimization等等，有助于发现一些原来没想到的问题，建议也加上。如果真的发现了一些不知什么的停顿，再加上”-XX:+PrintSafepointStatistics -XX: PrintSafepointStatisticsCount=1” 找原因。</p>
<p>GC日志默认会在重启后清空，但有人担心长期运行不重启的应用会把文件弄得很大，有”-XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=1M”的参数可以让日志滚动起来。但重启后的文件名太混乱太让人头痛，所以还是不加。</p>
<h2 id="2-6-JMX"><a href="#2-6-JMX" class="headerlink" title="2.6 JMX"></a>2.6 JMX</h2><p> <code>-Dcom.sun.management.jmxremote.port=${MY_JMX_PORT} -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=127.0.0.1</code></p>
<p>以上设置，只让本地的Zabbix之类监控软件通过JMX监控JVM，不允许远程访问。</p>
<p>《关键业务系统的JVM启动参数推荐》，转载请保留链接。</p>
<p>谢谢看到这里，还是贴个图吧。</p>
<p>有关的…</p>
<p>2016-07-30 – 从dstat理解Linux性能监控体系<br>2016-04-29 – Java应用调优之－目标与资料篇<br>2016-04-28 – 另一份Java应用调优指南之－工具篇<br>2016-01-01 – 另一份Java应用调优指南之－前菜</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/08/07/关键业务系统的JVM启动参数推荐2-0版-转/" data-id="ciutny7q4000x5cuswwr7g36k" class="article-share-link" data-share="baidu" data-title="关键业务系统的JVM启动参数推荐2.0版[转]">分享到</a>
      

      
        <a href="http://fengfu.io/2016/08/07/关键业务系统的JVM启动参数推荐2-0版-转/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记-微服务设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/30/读书笔记-微服务设计/" class="article-date">
  <time datetime="2016-07-30T03:11:37.000Z" itemprop="datePublished">2016-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/30/读书笔记-微服务设计/">读书笔记:微服务设计-入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>该系列笔记的内容主要来源于人邮出版的《微服务设计》一书。</p>
<h1 id="第一章-微服务"><a href="#第一章-微服务" class="headerlink" title="第一章 微服务"></a>第一章 微服务</h1><h2 id="微服务的由来"><a href="#微服务的由来" class="headerlink" title="微服务的由来"></a>微服务的由来</h2><p>微服务不是发明出来的，而是随着领域驱动设计、持续交付、按需虚拟化、基础设施自动化、小型自治团队、大型集群系统这些实践的流行，从现实世界总结出来的。</p>
<p>拓展知识点：Eric Evans的《<a href="http://item.jd.com/11961038.html" target="_blank" rel="external">领域驱动设计</a>》、Alistair Cookburn的<a href="http://alistair.cockburn.us/hexagonal+architecture" target="_blank" rel="external">六边形架构理论</a>、Netflix的构建大型反脆弱系统</p>
<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><ol>
<li><p>微服务很小<br>在考虑微服务时，内聚性这一原则很重要，具体可以联想到单一职责原则(Single Responsibility Principle)。<br>微服务的边界如何划分？答案是根据业务的边界来确定服务的边界。<br>至于很小，多小算是小？这个事情仁者见仁智者见智，有的人说花2周的时间能够构建完就可以，有的人说你认为已经够小了就行，我的理解是：只要边界小到能够提供独立的服务就行了。</p>
</li>
<li><p>微服务是自治的<br>一个微服务就是一个独立的实体，一个微服务的部署或修改应该尽量避免对消费方的修改，一个很典型的例子就是有人在设计接口返回值的时候用枚举，这其实很坑的。</p>
</li>
</ol>
<h2 id="微服务的好处"><a href="#微服务的好处" class="headerlink" title="微服务的好处"></a>微服务的好处</h2><h3 id="1-技术异构性"><a href="#1-技术异构性" class="headerlink" title="1.技术异构性"></a>1.技术异构性</h3><p>  服务端和消费端可以采用不同的技术。如果把dubbo看做一个微服务框架，那么它在技术异构性方面做得并不好。当然也有人对dubbo进行了改良，比如当当的<a href="https://github.com/dangdangdotcom/dubbox" target="_blank" rel="external">dubbox</a>，它在dubbo协议基础上增加了REST接口，这样消费方就可以使用其他协议与dubbo进行交互了。</p>
<h3 id="2-弹性"><a href="#2-弹性" class="headerlink" title="2.弹性"></a>2.弹性</h3><p>  弹性工程学的一个关键概念就是“舱壁”，比如轮船的水密舱。当一个舱进水时，通过关闭该舱来确保其它舱不进水，进而保证整条船的安全。在微服务中，一个服务A可能会消费下游的很多服务，如果下游的某个服务有问题，那么它不能影响A服务自身的运行的。</p>
<h3 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3.扩展"></a>3.扩展</h3><p>  对于单块服务来讲，即便是系统中某一个服务存在性能问题，那么也需要对整个系统进行扩展。如果使用较多的小服务，那么你只需要对存在性能问题的服务进行扩展就行了。</p>
<h3 id="4-简化部署"><a href="#4-简化部署" class="headerlink" title="4.简化部署"></a>4.简化部署</h3><p>  对于线上服务来说，相对于代码量巨大的单块系统，微服务具有灵活的部署优势和更小的部署风险。这里引申出一个比较重要的部署原则就是：每次部署应尽量少地修改代码，这样才能减少两次部署之间的差异。</p>
<h3 id="5-与组织机构更加匹配"><a href="#5-与组织机构更加匹配" class="headerlink" title="5.与组织机构更加匹配"></a>5.与组织机构更加匹配</h3><p>  说到系统与组织机构的关系，就不能不提康威定律。梅尔.康威在1968年4月的Datamation杂志上发表的一篇名为“How Do Committees Invent”的论文中提出：任何组织在设计一套系统时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。<br>  这里暂时不对康威定律做过多描述，但最起码有一点是肯定的，相比于单体应用，为服务能够更好地在团队之间交接，尤其那些业务、团队频繁变动的公司。</p>
<h3 id="6-可组合性"><a href="#6-可组合性" class="headerlink" title="6.可组合性"></a>6.可组合性</h3><p>  相比单体应用，为服务能够更方便地组合成新的微服务，这一点的思路跟乐高倒是有点相像。</p>
<h3 id="7-可替代性"><a href="#7-可替代性" class="headerlink" title="7.可替代性"></a>7.可替代性</h3><p>  一个规模比较大的单体应用，相信很少有人敢替代它。但对于一个规模比较小的微服务来讲，重新实现或者删除这个服务的可行性就大大增加了。</p>
<h2 id="微服务的不足"><a href="#微服务的不足" class="headerlink" title="微服务的不足"></a>微服务的不足</h2><p>  《微服务设计》这本书里面只是提到了微服务的好处，但是并没有提到微服务有哪些不足和挑战，这里自己做一些总结。</p>
<h3 id="1-维护压力"><a href="#1-维护压力" class="headerlink" title="1.维护压力"></a>1.维护压力</h3><p>  首先从服务部署的角度，无论是单机多服务，还是单机单服务，都会运维量的增加。单机多服务意味着服务维护复杂性的增加。比如服务器load高了，那到底是哪个服务引起的呢？单机单服务意味着服务器数量的增加。<br>  另外，微服务之间存在着很强的关联关系，当系统出现异常时，很有可能是因为下游的系统异常导致的，这就需要我们做好服务的监控和治理，甚至问题排查。因此，一旦你开始引入微服务，那么你就要在最开始的时候好好规划服务的治理。</p>
<h3 id="2-重复性劳动"><a href="#2-重复性劳动" class="headerlink" title="2.重复性劳动"></a>2.重复性劳动</h3><p>  重复性劳动是指你可能无法更多地像单体应用那样引用部分代码，毕竟服务之间是隔离的。当然你也可以通过抽取lib包这样的方式在微服务之间做到代码复用，但是那样就需要微服务的团队之间具有有效的沟通机制。</p>
<h3 id="3-系统运行效率"><a href="#3-系统运行效率" class="headerlink" title="3.系统运行效率"></a>3.系统运行效率</h3><p>  微服务之间的交互是通过网络进行的，因此网络的效率、稳定性就变得更加重要。在单体应用中，我们不必担心模块之间交互的数据量、效率，但是在微服务中，服务与服务之间的效率将至关重要。</p>
<h3 id="4-资源浪费"><a href="#4-资源浪费" class="headerlink" title="4.资源浪费"></a>4.资源浪费</h3><p>  一般来说，微服务推荐的部署方式是单机单服务，这也意味着更多的资源浪费。毕竟我们需要为操作系统、其他基础设施预留一些内存。在一个单体应用中，这些内存就可以共用。</p>
<p><em>图片描述：人间净土-喀纳斯</em></p>
<p><img src="https://img.alicdn.com/imgextra/i1/2657627814/TB222KbuXXXXXbOXpXXXXXXXXXX_!!2657627814.jpg" alt="喀纳斯_卧龙湾"></p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2na01uXXXXXXgXFXXXXXXXXXX_!!2657627814.jpg" alt="喀纳斯_禾木"></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/07/30/读书笔记-微服务设计/" data-id="ciutny7oa00035cus053t10ej" class="article-share-link" data-share="baidu" data-title="读书笔记:微服务设计-入门">分享到</a>
      

      
        <a href="http://fengfu.io/2016/07/30/读书笔记-微服务设计/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微服务/">微服务</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CTO、技术总监、首席架构师的区别-转" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/30/CTO、技术总监、首席架构师的区别-转/" class="article-date">
  <time datetime="2016-06-30T10:15:38.000Z" itemprop="datePublished">2016-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/30/CTO、技术总监、首席架构师的区别-转/">CTO、技术总监、首席架构师的区别(转)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>注:本文转自微信号erpweixin(简化ERP)，如转载请注明原文地址。原文地址请点 <a href="http://mp.weixin.qq.com/s?__biz=MjM5Njk2Mzg0MQ==&amp;mid=2651072525&amp;idx=1&amp;sn=4a5147a1fe70e3531891caf8fba29bb6&amp;scene=24&amp;srcid=0630cwnSLIEbtxEJQFdjTnWv#rd" title="CTO、技术总监、首席架构师的区别" target="_blank" rel="external">这里</a>：</p>
<p>经常有创业公司老板来拜访我，常常会拜托给我一句话：帮我找一个CTO。</p>
<p>我解释的多了，所以想把这个写下来，看看你到底需要的应该是啥。</p>
<h2 id="一、高级程序员"><a href="#一、高级程序员" class="headerlink" title="一、高级程序员"></a>一、高级程序员</h2><p>如果你是一个刚刚创业的公司，公司没有专职产品经理和项目经理，你就是公司的产品经理，你如果对你现在的开发员能力不满，那么你只需要的是一个高级程序员。</p>
<p>你定义功能、你做计划推进和管理，他可以带1-2个副手把你规划的功能实现了，他是主力干活者，有技术难题也是他来亲自攻克解决。</p>
<p>所以，一个高级程序员，他的职责很清晰：</p>
<p>1、负责核心复杂功能的实现方案设计、编码实现<br>2、负责疑难BUG分析诊断、攻关解决</p>
<h2 id="二、研发Leader"><a href="#二、研发Leader" class="headerlink" title="二、研发Leader"></a>二、研发Leader</h2><p>公司再长大些。如果你就有一个研发团队（含产品/开发/测试），你就一套主产品，而且你的研发团队小于15人，那么你需要的就是一个研发Leader。</p>
<p>因为你已经有了1-2个高级程序员，核心难题攻克和核心功能研发进度与质量保证，已经可以靠他们自身能力解决掉了。那么你需要研发Leader干什么。</p>
<p>研发Leader的职责是：</p>
<p>1、团队任务管理：开发工作量评估、开发任务分配</p>
<p>2、团队生产质量提升：代码审核、开发风险识别/报告/协调解决</p>
<p>3、团队生产力提升：代码模板研发与推广、最佳实践规范总结与推广、自动化研发生产工具研发与推广</p>
<p>4、团队专业力提升：招聘面试、新人指导、领导复盘总结改进</p>
<h2 id="三、技术总监"><a href="#三、技术总监" class="headerlink" title="三、技术总监"></a>三、技术总监</h2><p>如果你的研发团队超过20人了，而且有多套主打产品线了，你可能已经有了多个研发Leader了，那么你需要一个技术总监。</p>
<p>技术总监的职责：</p>
<p>1、组建平台研发部，搭建公共技术平台，方便上面各条产品线开发。</p>
<p>2、通过技术平台、通过高一层的职权，管理和协调各个产品线组。现在每个产品线都应该有合格的研发Leader和高级程序员了。</p>
<h2 id="四、首席架构师"><a href="#四、首席架构师" class="headerlink" title="四、首席架构师"></a>四、首席架构师</h2><p>因为你已经有了技术总监了，所以技术平台不错了。技术平台和各条产品线的协调互动，也是技术总监管着。</p>
<p>因为你已经有了各个产品线的高级程序员，他们在靠个人能力维持着核心功能模块的开发进度和代码质量。</p>
<p>因为你已经有了研发Leader，所以代码模板研发与推广、最佳实践规范总结与推广，这些事都已经在日常按份内职责开展了。</p>
<p>那么，啥时候需要首席架构师啊。</p>
<p>也就是说，需要分离管理族和专业族了。你会发现，这个阶段你的研发团队已经超过100来人了，需要有人专注来做架构规划、设计、日常维护。不能让研发总监和研发Leader又做管理又做技术一股脑都扔给他们，你就等着总结果产出。这是不对的。</p>
<p>需要从技术总监和研发Leader身上剥离职责了。让技术总监和研发Leader偏项目管理（管理族），把各个模块之间的架构设计工作，独立出一个岗位，就是架构师，来负责。</p>
<p>每个产品线都有架构师，在技术平台部门也有技术平台的架构师。那么，技术平台和业务产品线的架构互动，就是首席架构师在衔接了。让技术平台架构能够和产品业务系统的架构互相促进和支撑，就是首席架构师的份内之事。</p>
<p>架构师的职责是：</p>
<p>1、架构分析：从功能性需求中识别出需要增加的非功能性需求，好满足性能、可扩展、解耦/集成、安全、可运维、高可用、易部署、易更新。并且识别完非功能型需求，还要做技术选型、技术架构风险识别、技术实现工作量评估</p>
<p>2、架构设计与实现：非功能性模块的架构设计、接口设计、代码实现。所以需要的是有代码实现能力还要有架构思维的工程师，不需要画PPT的工程师</p>
<p>3、业务架构设计与实现：需要对跨系统的接口进行识别、实现、维护，需要对能写成公共代码类库的进行分析、识别、接口设计、实现、变更维护。</p>
<p>4、重构：架构师需要经常做Bug分析、非模板性和公共类库代码检查，以发现代码腐烂程度，以发现还有哪些代码没有做很好的架构与精心的代码设计。所以重构是经常性维护发生的，不是攒到某一刻动大手术，甚至推翻重做，那就不叫重构了。</p>
<h2 id="五、CTO"><a href="#五、CTO" class="headerlink" title="五、CTO"></a>五、CTO</h2><p>你把架构师团队组织建立完成，再往大长，你才需要真正意义上的CTO了。否则你一开始就招真正的CTO，他也不满意，你的期望也不对。现在你的期望也对了，他的能力模型也正好和你的期望职能匹配了，你能给他的和他想要的也正好匹配了。</p>
<p>有的公司有软件系统产品副总裁，也有软件系统技术副总裁，而且把软件系统技术副总裁叫CTO，软件系统产品副总裁叫产品VP。这就很怪异。</p>
<p>真正的CTO，是软件产品和技术是统一管理的。</p>
<p>他做的事情，是商业、产品、技术、管理、团队相平衡的综合统管。</p>
<p>CTO的职责：</p>
<p>1、业绩达成：洞察客户需求，捕捉商业机会，规划技术产品，通过技术产品领导业务增长，有清晰的战略规划、主攻方向，带领团队实现组织目标</p>
<p>2、前沿与平台：到这个研发规模规模级别了，一定要有专门的团队做技术应用创新探索和前沿技术预研。而且要和技术平台团队、应用研发团队形成很好的联动作用，让创新原型试点能够很平滑的融入商业平台再让应用研发线规模化的使用起来。大量的前沿探索都死在了内部，做完试点就停滞了，这就需要CTO做好整体的衔接推动工作。</p>
<p>3、研发过程管理：站在全局立场来端到端改进业务流程，为业务增长提供方便</p>
<p>4、组织与人才建设：公司文化和价值观的传承；研发专业族团队梯队建制建设、研发管理族团队梯队建制建设；创建创新激发机制，激发研发人创新向前发展，激发黑马人脱颖而出</p>
<p>阿朱出品必属精品，阿朱出品必属精品，阿朱出品必属精品，阿朱出品必属精品，唉，现在好文章，都需要重要的话说四遍了</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/06/30/CTO、技术总监、首席架构师的区别-转/" data-id="ciutny7r5001h5cuswxo8au6h" class="article-share-link" data-share="baidu" data-title="CTO、技术总监、首席架构师的区别(转)">分享到</a>
      

      
        <a href="http://fengfu.io/2016/06/30/CTO、技术总监、首席架构师的区别-转/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂谈/">杂谈</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM-垃圾回收器CMS之各阶段整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/21/JVM-垃圾回收器CMS之各阶段整理/" class="article-date">
  <time datetime="2016-06-21T07:50:22.000Z" itemprop="datePublished">2016-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/21/JVM-垃圾回收器CMS之各阶段整理/">JVM 垃圾回收器CMS之各阶段总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>先贴一张图：</p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2HFD0qVXXXXblXpXXXXXXXXXX_!!2657627814.jpg" alt=""></p>
<h2 id="1-初始标记阶段-CMS-initial-mark"><a href="#1-初始标记阶段-CMS-initial-mark" class="headerlink" title="1.初始标记阶段(CMS-initial-mark)"></a>1.初始标记阶段(CMS-initial-mark)</h2><p>  这个阶段的主要任务是找到堆中所有的垃圾回收根节点对象，这个阶段会暂停所有的应用程序线程，即STW(Stop the world)。此阶段会打印1行日志，如下：</p>
<pre><code>[GC [1 CMS-initial-mark: 2905437K(4096000K)] 3134625K(5916480K), 0.2551680 secs] [Times: user=0.26 sys=0.00, real=0.25 secs]
</code></pre><p>其中第一组数据，第一对数据标识老年代实际占用的空间大小和老年代分配的空间大小，第二对数据标识整个堆的实际使用情况和分配的堆的空间。<br>细心的人可能发现了CMS-initial-mark前面的数字“1”，这个标志代表了STW，在后面的“重新标记”阶段，你也会发现这个标志。这正好与上面图中说明的阶段是对应的。</p>
<h2 id="2-标记阶段-CMS-concurrent-mark"><a href="#2-标记阶段-CMS-concurrent-mark" class="headerlink" title="2.标记阶段(CMS-concurrent-mark)"></a>2.标记阶段(CMS-concurrent-mark)</h2><p>  这个阶段是和应用线程并发执行的，所谓并发收集器指的就是这个，主要作用是标记可达的对象。由于只是进行标记，所以不会对堆的占用产生实质的改变。</p>
<pre><code>2016-06-21T16:38:53.911+0800: 367848.849: [CMS-concurrent-mark-start]
2016-06-21T16:38:57.241+0800: 367852.178: [CMS-concurrent-mark: 2.787/3.329 secs] [Times: user=12.12 sys=0.64, real=3.33 secs]
</code></pre><p>这个阶段会打印2行日志，第一行CMS-concurrent-mark-start标识标记阶段开始。第二行中的“2.787/3.329 secs”表示标记阶段的耗时。后面的“user=12.12”表示占用的cpu时间(此JVM运行的服务器CPU为4核)。</p>
<h2 id="3-预清理阶段-CMS-concurrent-preclean"><a href="#3-预清理阶段-CMS-concurrent-preclean" class="headerlink" title="3.预清理阶段(CMS-concurrent-preclean)"></a>3.预清理阶段(CMS-concurrent-preclean)</h2><p>  在之前的标记阶段，标记和应用线程是并发执行的，因此有些对象的状态在标记后会发生改变。这个阶段只要是发现从新生代晋升的对象、新分配到老年代的对象以及在标记阶段被修改了的对象。<br>  这个阶段也会打印2行日志，跟标记阶段类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-06-21T16:38:57.241+0800: 367852.178: [CMS-concurrent-preclean-start]&#10;2016-06-21T16:38:57.718+0800: 367852.655: [CMS-concurrent-preclean: 0.342/0.477 secs] [Times: user=1.79 sys=0.10, real=0.48 secs]</span><br></pre></td></tr></table></figure>
<h2 id="4-重新标记阶段"><a href="#4-重新标记阶段" class="headerlink" title="4.重新标记阶段"></a>4.重新标记阶段</h2><p>  可中断预清理阶段是在JDK1.5中加入的。这个阶段是CMS中比较复杂的一个阶段，因为在这个阶段，JVM会执行很多操作。<br>  首先是CMS-concurrent-abortable-preclean，可中断的预清理。我们可能要问，既然再上一个阶段已经执行了预清理了，为什么还要再做一次？我们知道，CMS是以获取最短停顿时间为目的的GC，所以简单说进行可中断预清理的目的就是希望尽量缩短停顿的时间。<br>  可中断预清理涉及几个参数：<br>  -XX:CMSMaxAbortablePrecleanTime：当abortable-preclean阶段执行达到这个时间时才会结束<br>  -XX:CMSScheduleRemarkEdenSizeThreshold（默认2m）：控制abortable-preclean阶段什么时候开始执行，即当eden使用达到此值时，才会开始abortable-preclean阶段<br>  -XX:CMSScheduleRemarkEdenPenetratio（默认50%）：控制abortable-preclean阶段什么时候结束执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-06-21T16:38:57.718+0800: 367852.656: [CMS-concurrent-abortable-preclean-start]&#10;2016-06-21T16:38:58.801+0800: 367853.738: [CMS-concurrent-abortable-preclean: 0.920/1.083 secs] [Times: user=4.06 sys=0.20, real=1.08 secs]&#10;2016-06-21T16:38:58.808+0800: 367853.746: [GC[YG occupancy: 777901 K (1820480 K)]367853.746: [Rescan (parallel) , 0.1361120 secs]367853.882: [weak refs processing, 0.0005370 secs]367853.883: [scrub string table, 0.0044130 secs] [1 CMS-remark: 3034451K(4096000K)] 3812352K(5916480K), 0.1412750 secs] [Times: user=0.54 sys=0.00, real=0.14 secs]</span><br></pre></td></tr></table></figure>
<p>  其次，是Rescan操作，此阶段暂停应用线程，对对象进行重新扫描并标记。通过上面的日志我们可以看到，在CMS-remark的时候有一次STW。另外，这个过程还会打印出弱引用处理、类卸载等过程的耗时。</p>
<h2 id="5-清除阶段-CMS-concurrent-sweep"><a href="#5-清除阶段-CMS-concurrent-sweep" class="headerlink" title="5.清除阶段(CMS-concurrent-sweep)"></a>5.清除阶段(CMS-concurrent-sweep)</h2><p>  这个阶段开始进行垃圾的清理工作，此时应用线程被重新激活，回收线程与应用线程并发运行，那些无效的对象被清理掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-06-21T16:38:58.950+0800: 367853.888: [CMS-concurrent-sweep-start]&#10;2016-06-21T16:39:05.850+0800: 367860.788: [CMS-concurrent-sweep: 5.656/6.900 secs] [Times: user=25.88 sys=1.28, real=6.90 secs]</span><br></pre></td></tr></table></figure>
<h2 id="6-初始标记阶段-CMS-concurrent-reset"><a href="#6-初始标记阶段-CMS-concurrent-reset" class="headerlink" title="6.初始标记阶段(CMS-concurrent-reset)"></a>6.初始标记阶段(CMS-concurrent-reset)</h2><p>  这是CMS一个回收周期的最后一个阶段，在这个阶段，CMS会清除内部状态，为下次回收做准备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-06-21T16:39:05.850+0800: 367860.788: [CMS-concurrent-reset-start]&#10;2016-06-21T16:39:05.860+0800: 367860.798: [CMS-concurrent-reset: 0.010/0.010 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>
<p>  至此，一个CMS周期结束。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/06/21/JVM-垃圾回收器CMS之各阶段整理/" data-id="ciutny7qv001c5cusy7xbckui" class="article-share-link" data-share="baidu" data-title="JVM 垃圾回收器CMS之各阶段总结">分享到</a>
      

      
        <a href="http://fengfu.io/2016/06/21/JVM-垃圾回收器CMS之各阶段整理/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-性能调优工具-Java-Mission-Control" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/20/性能调优工具-Java-Mission-Control/" class="article-date">
  <time datetime="2016-05-20T06:59:20.000Z" itemprop="datePublished">2016-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/20/性能调优工具-Java-Mission-Control/">性能调优工具-Java Mission Control</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>最近1年多的时间，因为需要排查线上应用出现的性能问题，会借助一些工具如JProfiler、Yourkit，但是这些工具都具有商业性质，使用时难免受到限制。后来发现Oracle Jdk(version&gt;=7u40)中自带了一个Java Mission Control(以下简称JMC)的应用，也可以实现JVM的监控。</p>
<p>另外，与JProfiler等使用JVMPI/JVMTI方式实现的工具不同，JMC使用了JVM内部特定的基于事件的接口，几乎不会给应用造成额外的压力（默认设置下，对性能影响小于1%），因此可以用在负载很高的生产环境中。</p>
<p>本文就来简单介绍一下使用JMC来监测JVM性能。</p>
<p><em>注意：需要下载Oracle Jdk 7u40以后的版本，OpenJdk无效，切记！</em></p>
<h2 id="2-目标JVM配置"><a href="#2-目标JVM配置" class="headerlink" title="2.目标JVM配置"></a>2.目标JVM配置</h2><p>在被监控的JVM（目标JVM）上需要开启以下Java Options才能对其进行监控，对于Tomcat来说，在JAVA_OPTS或CATALINA_OPTS中加入以下代码即可：</p>
<pre><code>-Dcom.sun.management.jmxremote.authenticate=false
-Dcom.sun.management.jmxremote.ssl=false
-Djava.rmi.server.hostname=192.168.32.11
-Dcom.sun.management.jmxremote.port=7777
-Dcom.sun.management.jmxremote
-XX:+UnlockCommercialFeatures
-XX:+FlightRecorder
</code></pre><p>java.rmi.server.hostname：如果要允许其它机器监控该程序，必须设定，否则就只能在本机监控该程序。<br>com.sun.management.jmxremote：启用JMX远程监控。<br>com.sun.management.jmxremote.port：JMX远程监控的端口。<br>com.sun.management.jmxremote.ssl：将此配置设置为 true 时，将使用服务器证书通过 SSL 来保护通信。<br>com.sun.management.jmxremote.authenticate：是否开启权限控制，如果设置为true，需要指定两个文件：jmxremote.password和jmxremote.access，password文件主要是配置用户名和密码，access主要是配置权限（可读或者读写）。<br>在Tomcat的bin目录下增加下面两个文件：jmxremote.password和jmxremote.access，格式如下：</p>
<p>jmxremote.access：</p>
<pre><code>admin readwrite \
  create com.sun.management.*,com.oracle.jrockit.* \
  unregister
monitor readonly
</code></pre><p>表示admin有操作权限（比如调用GC等操作），monitor只有查看权限，不能进行任何操作。<br>jmxremote.password：</p>
<pre><code>admin test
monitor test    
</code></pre><p>表示有两个用户，admin和monitor，密码分别是test和test。</p>
<p>-XX:+UnlockCommercialFeatures：开启商业特性，默认这个选项是关闭的。<br>-XX:+FlightRecorder：开启飞行记录器。</p>
<p>上述参数配置完毕，重新启动tomcat即可。</p>
<h2 id="3-连接远程JVM"><a href="#3-连接远程JVM" class="headerlink" title="3.连接远程JVM"></a>3.连接远程JVM</h2><p>双击本地%JDK_HOME%\bin\jmc.exe，点击左侧“创建新定制JVM连接”图标， </p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2L_MapXXXXXaGXFXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2h8gqpXXXXXbUXXXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p>在弹出的窗口中输入远程JVM的IP地址和端口号：</p>
<p><img src="https://img.alicdn.com/imgextra/i2/2657627814/TB29LQKpXXXXXX3XXXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p>选择“启动JMX控制台”，点击“完成”。</p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2hE_PpXXXXXcRXXXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p>进入JMC主界面：</p>
<p><img src="https://img.alicdn.com/imgextra/i4/2657627814/TB2mAEGpXXXXXaHXXXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p>在左侧飞行记录器的菜单上点击右键，选择“启动飞行记录”，进入到启动飞行记录的界面，在此界面设置飞行记录的文件路径、记录时长(固定时长或固定间隔)：</p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2xSsHpXXXXXafXXXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p>设置监控的事件：</p>
<p><img src="https://img.alicdn.com/imgextra/i4/2657627814/TB2TJcEpXXXXXaKXXXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p>在此界面可以设置监控的详细设置，并点击“完成”</p>
<p><img src="https://img.alicdn.com/imgextra/i2/2657627814/TB2DiMkpXXXXXcsXpXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p>现在你可以愉快地使用JFR的强大功能了。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/05/20/性能调优工具-Java-Mission-Control/" data-id="ciutny7pu000s5cusl7hxwd18" class="article-share-link" data-share="baidu" data-title="性能调优工具-Java Mission Control">分享到</a>
      

      
        <a href="http://fengfu.io/2016/05/20/性能调优工具-Java-Mission-Control/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>
</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/人生/">人生</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/商业/">商业</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂谈/">杂谈</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/人生/" style="font-size: 10px;">人生</a> <a href="/tags/商业/" style="font-size: 10px;">商业</a> <a href="/tags/微服务/" style="font-size: 12.5px;">微服务</a> <a href="/tags/杂谈/" style="font-size: 17.5px;">杂谈</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">二月 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/10/27/晋级Review归来话代码有毒/">晋级Review归来话代码有毒</a>
          </li>
        
          <li>
            <a href="/2016/10/24/让你变成优秀程序员的几个小习惯/">让你变成优秀程序员的几个小习惯(转)</a>
          </li>
        
          <li>
            <a href="/2016/08/23/接口文档参考模板/">接口文档参考模板</a>
          </li>
        
          <li>
            <a href="/2016/08/22/晋级Review归来话答辩/">晋级Review归来话答辩</a>
          </li>
        
          <li>
            <a href="/2016/08/12/读书笔记-微服务设计-建模/">读书笔记:微服务设计-建模</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://coolshell.cn" target="_blank">酷壳</a>
          </li>
        
          <li>
            <a href="http://ifeve.com" target="_blank">并发编程网</a>
          </li>
        
          <li>
            <a href="http://calvin1978.blogcn.com" target="_blank">花钱的年化</a>
          </li>
        
          <li>
            <a href="http://lovestblog.cn" target="_blank">你假笨</a>
          </li>
        
          <li>
            <a href="http://hellojava.info" target="_blank">hellojava</a>
          </li>
        
          <li>
            <a href="http://techblog.netflix.com" target="_blank">Netflix技术博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 宁静·致远<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"qufengfu"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
