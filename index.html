
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>宁静·致远</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="宁静·致远">
<meta property="og:url" content="http://fengfu.io/index.html">
<meta property="og:site_name" content="宁静·致远">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="宁静·致远">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="宁静·致远" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">宁静·致远</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="fengfu.io">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-关键业务系统的JVM启动参数推荐2-0版-转" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/07/关键业务系统的JVM启动参数推荐2-0版-转/" class="article-date">
  <time datetime="2016-08-07T02:20:22.000Z" itemprop="datePublished">2016-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/07/关键业务系统的JVM启动参数推荐2-0版-转/">关键业务系统的JVM启动参数推荐2.0版[转]</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>注：本文转自SpringSide的作者江南白衣的博客“<a href="http://calvin1978.blogcn.com/articles/jvmoption-2.html" target="_blank" rel="external">关键业务系统的JVM启动参数推荐 2.0版</a>”，如需转载，请尊重作者权利，注明原文出处，谢谢。</p>
<p>在关键的业务系统里，除了继续追求技术人员最爱的高吞吐与低延时之外，系统的稳定性与出现问题时排查的便捷性也很重要。</p>
<p>这是本文的一个原则，后面也会一次又一次的强调，所以与网上其他的文章略有不同，请调优高手和运维老大们多指引。</p>
<p>更新记录：</p>
<p>2.0版，增加 -XX:+PerfDisableSharedMem，GC日志指向/dev/shm，避免IO造成的JVM停顿。</p>
<h1 id="前言1，资料"><a href="#前言1，资料" class="headerlink" title="前言1，资料"></a>前言1，资料</h1><p>学习开源项目的启动脚本是个不错的主意，比如<a href="https://github.com/apache/cassandra/blob/trunk/conf/cassandra-env.sh" target="_blank" rel="external">Cassandra</a>家的， 附送一篇<a href="https://tobert.github.io/pages/als-cassandra-21-tuning-guide.html" target="_blank" rel="external">解释它的文章</a>。</p>
<p><a href="http://hllvm.group.iteye.com/group/topic/27945" target="_blank" rel="external">JVM调优的”标准参数”的各种陷阱</a> R大的文章，在JDK6时写的，期待更新。</p>
<p>偶然翻到Linkedin工程师的<a href="http://www.importnew.com/11336.html" target="_blank" rel="external">一篇文章</a>。</p>
<p>更偶然翻到的<a href="http://www.techpaste.com/2012/02/java-command-line-options-jvm-performance-improvement/" target="_blank" rel="external">一份不错的参数列表</a>。</p>
<h1 id="前言2，-XX-PrintFlagsFinal打印参数值"><a href="#前言2，-XX-PrintFlagsFinal打印参数值" class="headerlink" title="前言2， -XX:+PrintFlagsFinal打印参数值"></a>前言2， -XX:+PrintFlagsFinal打印参数值</h1><p>当你在网上兴冲冲找到一个可优化的参数时，先用-XX: +PrintFlagsFinal看看，它可能已经默认打开了，再找到一个，还是默认打开了…</p>
<p>JDK7与JDK8，甚至JDK7中的不同版本，有些参数值都不一样，所以不要轻信网上任何文章，一切以生产环境同版本的JDK打出来的为准。</p>
<p>经常以类似下面的语句去查看参数，偷懒不起应用，用-version代替。有些参数设置后会影响其他参数，所以查看时也把它带上。</p>
<pre><code>java -server -Xmx1024m -Xms1024m -XX:+UseConcMarkSweepGC -XX:+PrintFlagsFinal -version| grep ParallelGCThreads
</code></pre><h1 id="前言3，关于默认值"><a href="#前言3，关于默认值" class="headerlink" title="前言3，关于默认值"></a>前言3，关于默认值</h1><p>JDK8会默认打开-XX:+TieredCompilation多层编译，而JDK7则不会。JDK7u40以后的版本会默认打开-XX:+OptimizeStringConcat优化字符串拼接，而之前的则不打开。</p>
<p>对于这些参数，我的建议是顺势而为，JDK在那个版本默认打开不打开总有它的理由。安全第一，没有很好的因由，不要随便因为网上某篇文章的推荐(包括你现在在读的这篇)就去设置。</p>
<h1 id="1-性能篇"><a href="#1-性能篇" class="headerlink" title="1. 性能篇"></a>1. 性能篇</h1><p>先写一些不那么常见的，后面再来老生常谈。</p>
<h2 id="1-1-取消偏向锁-XX-UseBiasedLocking"><a href="#1-1-取消偏向锁-XX-UseBiasedLocking" class="headerlink" title="1.1 取消偏向锁 -XX:-UseBiasedLocking"></a>1.1 取消偏向锁 -XX:-UseBiasedLocking</h2><p>JDK1.6开始默认打开的偏向锁，在没有竞争的情况下，会取消线程同步的原语，比如那个所有方法都挂着synchronized关键字的StringBuffer，如果始终只有一条线程在访问它，就略过同步操作以获得性能提升。</p>
<p>但一旦有第二条线程访问这把锁，JVM就要撤销偏向锁恢复到未锁定线程的状态，用”-XX:+PrintSafepointStatistics -XX :P rintSafepointStatisticsCount=1” 可以看到不少RevokeBiasd的纪录，像GC一样，会Stop The World的干活，虽然只是很短很短的停顿，但对于多线程并发的应用，取消掉它反而有性能的提升和延时的极微的缩短，所以Cassandra就取消了它。</p>
<h2 id="1-2-启动时访问并置零内存页面-XX-AlwaysPreTouch"><a href="#1-2-启动时访问并置零内存页面-XX-AlwaysPreTouch" class="headerlink" title="1.2 启动时访问并置零内存页面-XX:+AlwaysPreTouch"></a>1.2 启动时访问并置零内存页面-XX:+AlwaysPreTouch</h2><p>启动时就把参数里说好了的内存全部舔一遍，可能令得启动时慢上一点，但后面访问时会更流畅，比如页面会连续分配，比如不会在晋升新生代到老生代时才去申请页面使得GC停顿时间加长。不过这选项对32G之类的大堆才会更有感觉一点。</p>
<h2 id="1-3-Djava-security-egd-file-dev-urandom"><a href="#1-3-Djava-security-egd-file-dev-urandom" class="headerlink" title="1.3 -Djava.security.egd=file:/dev/./urandom"></a>1.3 -Djava.security.egd=file:/dev/./urandom</h2><p>UUID.randomUUID() 有时候会很慢，Thread Dump一看居然被锁住了，原因是里面用了SecureRandom，要等待机器产生新的噪音(比如机器里的某个文件发生了变化)才肯产生新的随机数。因此最好让熵池里没有新的噪音因子时重用当前的因子。详见 <a href="http://blog.csdn.net/xiaoxinyu316/article/details/39064003" target="_blank" rel="external">JVM上的随机数与熵池策略</a></p>
<h2 id="1-4-XX-AutoBoxCacheMax-20000"><a href="#1-4-XX-AutoBoxCacheMax-20000" class="headerlink" title="1.4 -XX:AutoBoxCacheMax=20000"></a>1.4 -XX:AutoBoxCacheMax=20000</h2><p>Integer i = 3;这语句有着 int自动装箱成Integer的过程，JDK默认只缓存 -128 ~ +127的int 和 long，超出范围的数字就要即时构建新的Integer对象。设为20000后，我们应用的QPS从48,000提升到50,000，足足4%的影响。详见<a href="http://blog.csdn.net/chengzhezhijian/article/details/9628251" target="_blank" rel="external">Java Integer(-128~127)值的==和equals比较产生的思考</a></p>
<h2 id="1-5-XX-PerfDisableSharedMem"><a href="#1-5-XX-PerfDisableSharedMem" class="headerlink" title="1.5 -XX:+PerfDisableSharedMem"></a>1.5 -XX:+PerfDisableSharedMem</h2><p>Cassandra家的一个参数，一直没留意，直到发生高IO时的JVM停顿。原来每次进入安全点（比如GC）, JVM都会默默的在/tmp/hperf 目录写上一点statistics数据，如果刚好遇到PageCache刷盘，把文件阻塞了，就不能结束这个Stop the World的安全点了。用此参数可以禁止JVM写statistics数据，代价是VisualVM和jstat用不了，只能用JMX取数据，但在生产环境本来就不需要VisaulVM。详见<a href="http://calvin1978.blogcn.com/articles/%20http://www.evanjones.ca/jvm-mmap-pause.html" target="_blank" rel="external">The Four Month Bug: JVM statistics cause garbage collection pauses</a></p>
<h2 id="1-6-不建议的参数"><a href="#1-6-不建议的参数" class="headerlink" title="1.6 不建议的参数"></a>1.6 不建议的参数</h2><p>-XX:+AggressiveOpts是一些还没默认打开的优化参数集合, -XX:AutoBoxCacheMax是其中的一项。但如前所述，关键系统里不建议打开。虽然通过-XX:+AggressiveOpts 与 -XX:-AggressiveOpts 的对比，目前才改变了三个参数，但为免以后某个版本的JDK里默默改变更多激进的配置，还是不要了。</p>
<p>Linkined那种黑科技，先要解锁VMOptions才能配置的就更不用说了，比如</p>
<pre><code>-XX:+UnlockDiagnosticVMOptions -XX: ParGCCardsPerStrideChunk=32768
</code></pre><p>JIT Compile相关的参数，函数调用多少次之后开始编译的阀值，内联函数大小的阀值等等，不要乱改了。</p>
<p>-XX:+UseFastAccessorMethods，据说在多层编译下还慢了，所以是默认关闭的。</p>
<h2 id="1-7-server"><a href="#1-7-server" class="headerlink" title="1.7 -server"></a>1.7 -server</h2><p>-server 与 -client的JVM默认参数完全不一样，虽然在Linux 64位JVM里默认会被认成server模式，但还是顺手写上吧。</p>
<h2 id="1-8-GC策略"><a href="#1-8-GC策略" class="headerlink" title="1.8 GC策略"></a>1.8 GC策略</h2><p>为了稳健，还是8G以下的堆还是CMS好了，G1的细节实现起来难度太大，从理论提出到现在都做了六七年了。</p>
<p>CMS真正可设的东西也不多，详见<a href="http://ifeve.com/useful-jvm-flags-part-7-cms-collector/" target="_blank" rel="external">JVM实用参数（七）CMS收集器</a></p>
<pre><code>-XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly
</code></pre><p>因为我们的监控系统会通过JMX监控内存达到90%的状况（留点处理的时间），所以设置让它75%就开始跑了，早点开始也能避免Full GC等意外情况(概念重申，这种主动的CMS GC，和JVM的老生代、永久代、堆外内存完全不能分配内存了而强制Full GC是不同的概念)。为了让这个设置生效，还要设置-XX:+UseCMSInitiatingOccupancyOnly，否则75只被用来做开始的参考值，后面还是JVM自己算。</p>
<p>-XX:MaxTenuringThreshold=2，这是GC里改动效果最明显的一个参数了。对象在Survivor区熬过多少次Young GC后晋升到年老代，JDK7里看起来默认是6，跑起来好像变成了15。</p>
<p>Young GC是最大的应用停顿来源，而新生代里GC后存活对象的多少又直接影响停顿的时间，所以如果清楚Young GC的执行频率和应用里大部分临时对象的最长生命周期，可以把它设的更短一点，让其实不是临时对象的新生代长期对象赶紧晋升到年老代，别呆着。</p>
<p>用-XX:+PrintTenuringDistribution观察下，如果后面几代都差不多，就可以设小，比如JMeter里是2。而我们的两个系统里一个设了2，一个设了6。</p>
<p>-XX:+ExplicitGCInvokesConcurrent， 但不要-XX:+DisableExplicitGC， 比如<a href="http://calvin1978.blogcn.com/articles/directbytebuffer.html" target="_blank" rel="external">Netty之堆外内存扫盲篇</a>，可见禁了system.gc() 未必是好事，只要自己的代码里没有调它，也没用什么特别烂的类库，真有人调了总有调的原因。-XX+ExplicitGCInvokesConcurrent 则在full gc时，并不全程停顿，依然只在ygc和两个remark阶段停顿，详见<a href="http://lovestblog.cn/blog/2015/05/07/system-gc/" target="_blank" rel="external">JVM源码分析之SystemGC完全解读</a></p>
<p>-XX: ParallelRefProcEnabled , 默认为false，并行的处理Reference对象，如WeakReference，除非在GC log里出现Reference处理时间较长的日志，否则效果不会很明显，但我们总是要JVM尽量的并行，所以设了也就设了。</p>
<h2 id="1-9-GC里不建议设的参数"><a href="#1-9-GC里不建议设的参数" class="headerlink" title="1.9 GC里不建议设的参数"></a>1.9 GC里不建议设的参数</h2><p>-XX:+CMSClassUnloadingEnabled，在CMS中清理永久代中的过期的Class而不等到Full GC，JDK7默认关闭而JDK8打开。看自己情况，比如有没有运行动态语言脚本如Groovy产生大量的临时类。它会增加CMS remark的暂停时间，所以如果新类加载并不频繁，这个参数还是不开的好。</p>
<p>用了CMS，新生代收集默认就是-XX:+UseParNewGC，不用自己设。</p>
<p>并发收集线程数，ParallelGCThreads＝8+( Processor - 8 ) ( 5/8 )， ConcGCThreads = (ParallelGCThreads + 3)/4，比如双CPU，六核，超线程就是24个处理器，小于8个处理器时ParallelGCThreads按处理器数量，大于时按上述公式ParallelGCThreads＝18， ConcGCThreads＝5。这线程数调整了变化也不大，还是别乱动了。</p>
<p>-XX:+CMSScavengeBeforeRemark，默认为关闭，在CMS remark前，先执行一次minor GC将新生代清掉，这样从老生代的对象引用到的新生代对象的个数就少了，停止全世界的CMS remark阶段就短一些。如果看到GC日志里remark阶段的时间超长，可以打开此项看看有没有效果，否则还是不要打开了，白白多了次GC。</p>
<p>-XX:CMSFullGCsBeforeCompaction，默认为0，即每次full gc都对老生代进行碎片整理压缩。Full GC 不同于 前面设置的75%老生代时触发的CMS GC，只在System.gc()，老生代达到100%，老生代碎片过大无法分配空间给新晋升的大对象这些特殊情况里发生，所以设为每次都进行碎片整理是合适的，详见此贴里R大的解释。</p>
<h2 id="1-10-内存大小的设置"><a href="#1-10-内存大小的设置" class="headerlink" title="1.10 内存大小的设置"></a>1.10 内存大小的设置</h2><p>这些关于大小的参数，给人感觉是最踏实可控的。</p>
<p>其实JVM除了显式设置的-Xmx堆内存，还有一堆其他占内存的地方(堆外内存，线程栈，永久代，二进制代码cache)，在容量规划的时候要留意。</p>
<p>关键业务系统的服务器上内存一般都是够的，所以尽管设得宽松点。</p>
<p>-Xmx, -Xms, 堆内存大小，2～4G均可，再大了GC时间会拖长。</p>
<p>-Xmn or -XX:NewSize and -XX:MaxNewSize or -XX:NewRatio， JDK默认新生代占堆大小的1/3， 个人喜欢把对半分， 增大新生代的大小，能减少GC的频率（但也会加大每次GC的停顿时间），主要是看老生代里没多少长期对象的话，占2/3太多了。可以用-Xmn 直接赋值(等于-XX:NewSize and -XX:MaxNewSize同值的缩写)，或把NewRatio设为1来对半分(但如果想设置新生代比老生代大就只能用-Xmn)。</p>
<p>-XX: PermSize=128m -XX:MaxPermSize=512m （JDK7）现在的应用有Hibernate/Spring这些闹腾的家伙AOP之后类都比较多，可以一开始就把初始值从64M设到128M，并设一个更大的Max值以求保险。</p>
<p>-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m（JDK8），JDK8的永生代几乎可用完机器的所有内存，同样设一个128M的初始值，512M的最大值保护一下。</p>
<h2 id="1-11-其他内存大小等可选设置"><a href="#1-11-其他内存大小等可选设置" class="headerlink" title="1.11 其他内存大小等可选设置"></a>1.11 其他内存大小等可选设置</h2><p>-XX:SurvivorRatio 新生代中每个存活区的大小，默认为8，即1/10的新生代 1/(SurvivorRatio+2)，有人喜欢设小点省点给新生代，但要避免太小使得存活区放不下临时对象而要晋升到老生代，还是从GC Log里看实际情况了。</p>
<p>-Xss 在堆之外，线程占用栈内存，默认每条线程为1M（以前是256K）。除了方法调用出参入参的栈，逃逸分析后也会把只在该线程里可见的对象直接分配在线程栈里，而不是公共的Heap里，也就减少了新生代的GC频率。有人喜欢设小点节约内存开更多线程，但反正内存够也就不必要设小，有人喜欢再设大点。</p>
<p>-XX:MaxDirectMemorySize，堆外内存/直接内存的大小，默认为Heap区总内存减去一个Survivor区的大小，详见<a href="http://calvin1978.blogcn.com/articles/directbytebuffer.html" target="_blank" rel="external">Netty之堆外内存扫盲篇</a>。</p>
<p>-XX:ReservedCodeCacheSize， JIT编译后二进制代码的存放区，满了之后就不再编译。JDK7默认不开多层编译48M，开了96M，而JDK8默认开多层编译256M。可以在JMX里看看CodeCache的大小，JDK7下的48M一般够了，也可以把它设大点，反正内存多。</p>
<h1 id="2-监控篇"><a href="#2-监控篇" class="headerlink" title="2. 监控篇"></a>2. 监控篇</h1><p>JVM输出的各种日志，如果未指定路径，通常会生成到运行应用的相同目录，为了避免有时候在不同的地方执行启动脚本，一般将日志路径集中设到一个固定的地方。</p>
<h2 id="2-1-XX-PrintCommandLineFlags"><a href="#2-1-XX-PrintCommandLineFlags" class="headerlink" title="2.1 -XX:+PrintCommandLineFlags"></a>2.1 -XX:+PrintCommandLineFlags</h2><p>运维有时会对启动参数做一些临时的更改，将每次启动的参数输出到stdout，将来有据可查。<br>打印出来的是命令行里设置了的参数以及因为这些参数隐式影响的参数，比如开了CMS后，-XX:+UseParNewGC也被自动打开。</p>
<h2 id="2-2-XX-OmitStackTraceInFastThrow"><a href="#2-2-XX-OmitStackTraceInFastThrow" class="headerlink" title="2.2 -XX:-OmitStackTraceInFastThrow"></a>2.2 -XX:-OmitStackTraceInFastThrow</h2><p>为异常设置StackTrace是个昂贵的操作，所以当应用在相同地方抛出相同的异常N次(两万?)之后，JVM会对某些特定异常如NPE，数组越界等进行优化，不再带上异常栈。此时，你可能会看到日志里一条条Null Point Exception，而真正输出完整栈的日志早被滚动到不知哪里去了，也就完全不知道这NPE发生在什么地方，欲哭无泪。 所以，将它禁止吧。</p>
<h2 id="2-3-coredump与-XX-ErrorFile"><a href="#2-3-coredump与-XX-ErrorFile" class="headerlink" title="2.3 coredump与 -XX:ErrorFile"></a>2.3 coredump与 -XX:ErrorFile</h2><p>JVM crash时，hotspot 会生成一个error文件，提供JVM状态信息的细节。如前所述，将其输出到固定目录，避免到时会到处找这文件。文件名中的%p会被自动替换为应用的PID</p>
<pre><code>-XX:ErrorFile=${MYLOGDIR}/hs_err_%p.log
</code></pre><p>当然，更好的做法是生成coredump，从CoreDump能够转出Heap Dump 和 Thread Dump 还有crash的地方，非常实用。</p>
<p>在启动脚本里加上 ulimit -c unlimited或其他的设置方式，如果有root权限，用一下一下输出目录更好</p>
<pre><code>echo &quot;/{MYLOGDIR}/coredump.%p&quot; &gt; /proc/sys/kernel/core_pattern
</code></pre><p>什么？你不知道这东西什么用？看来你是没遇过JVM Segment Fault的幸福人。</p>
<h2 id="2-4-XX-HeapDumpOnOutOfMemoryError"><a href="#2-4-XX-HeapDumpOnOutOfMemoryError" class="headerlink" title="2.4 -XX:+HeapDumpOnOutOfMemoryError"></a>2.4 -XX:+HeapDumpOnOutOfMemoryError</h2><p>在Out Of Memory，JVM快死快死掉的时候，输出Heap Dump到指定文件。不然开发很多时候还真不知道怎么重现错误。</p>
<p>路径只指向目录，JVM会保持文件名的唯一性，叫java_pid${pid}.hprof。如果指向文件，而文件已存在，反而不能写入。</p>
<pre><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${LOGDIR}/
</code></pre><h2 id="2-5-GC日志"><a href="#2-5-GC日志" class="headerlink" title="2.5 GC日志"></a>2.5 GC日志</h2><pre><code>-Xloggc:/dev/shm/gc-myapplication.log -XX:+PrintGCDateStamps -XX:+PrintGCDetails
</code></pre><p>详见<a href="http://ifeve.com/useful-jvm-flags-part-8-gc-logging/" target="_blank" rel="external">JVM实用参数（八）GC日志</a>，有人担心写GC日志会影响性能，但测试下来实在没什么影响，还是留一份用来排查好。</p>
<p>到后来，又发现如果遇上高IO的情况，如果GC的时候，操作系统正在flush pageCache 到磁盘，也可能导致GC log文件被锁住，从而让GC结束不了。所以把它指向了/dev/shm 这种内存中数据库，避免这种停顿，详见<a href="http://calvin1978.blogcn.com/articles/%E2%80%9Chttps://engineering.linkedin.com/blog/2016/02/eliminating-large-jvm-gc-pauses-caused-by-background-io-traffic%E2%80%9D" target="_blank" rel="external">Eliminating Large JVM GC Pauses Caused by Background IO Traffic</a></p>
<p>另外还有一个-XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime，它的名字没起好，它除了打印清晰的GC停顿时间外，还可以打印其他的停顿时间，比如取消偏向锁，class 被agent redefine，code deoptimization等等，有助于发现一些原来没想到的问题，建议也加上。如果真的发现了一些不知什么的停顿，再加上”-XX:+PrintSafepointStatistics -XX: PrintSafepointStatisticsCount=1” 找原因。</p>
<p>GC日志默认会在重启后清空，但有人担心长期运行不重启的应用会把文件弄得很大，有”-XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=1M”的参数可以让日志滚动起来。但重启后的文件名太混乱太让人头痛，所以还是不加。</p>
<h2 id="2-6-JMX"><a href="#2-6-JMX" class="headerlink" title="2.6 JMX"></a>2.6 JMX</h2><p> <code>-Dcom.sun.management.jmxremote.port=${MY_JMX_PORT} -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=127.0.0.1</code></p>
<p>以上设置，只让本地的Zabbix之类监控软件通过JMX监控JVM，不允许远程访问。</p>
<p>《关键业务系统的JVM启动参数推荐》，转载请保留链接。</p>
<p>谢谢看到这里，还是贴个图吧。</p>
<p>有关的…</p>
<p>2016-07-30 – 从dstat理解Linux性能监控体系<br>2016-04-29 – Java应用调优之－目标与资料篇<br>2016-04-28 – 另一份Java应用调优指南之－工具篇<br>2016-01-01 – 另一份Java应用调优指南之－前菜</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/08/07/关键业务系统的JVM启动参数推荐2-0版-转/" data-id="cirkc45du000nfgus2xpvp6ng" class="article-share-link" data-share="baidu" data-title="关键业务系统的JVM启动参数推荐2.0版[转]">分享到</a>
      

      
        <a href="http://fengfu.io/2016/08/07/关键业务系统的JVM启动参数推荐2-0版-转/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记-微服务设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/30/读书笔记-微服务设计/" class="article-date">
  <time datetime="2016-07-30T03:11:37.000Z" itemprop="datePublished">2016-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/30/读书笔记-微服务设计/">读书笔记:微服务设计-入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一章-微服务"><a href="#第一章-微服务" class="headerlink" title="第一章 微服务"></a>第一章 微服务</h1><h2 id="微服务的由来"><a href="#微服务的由来" class="headerlink" title="微服务的由来"></a>微服务的由来</h2><p>微服务不是发明出来的，而是随着领域驱动设计、持续交付、按需虚拟化、基础设施自动化、小型自治团队、大型集群系统这些实践的流行，从现实世界总结出来的。</p>
<p>拓展知识点：Eric Evans的《<a href="http://item.jd.com/11961038.html" target="_blank" rel="external">领域驱动设计</a>》、Alistair Cookburn的<a href="http://alistair.cockburn.us/hexagonal+architecture" target="_blank" rel="external">六边形架构理论</a>、Netflix的构建大型反脆弱系统</p>
<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><ol>
<li><p>微服务很小<br>在考虑微服务时，内聚性这一原则很重要，具体可以联想到单一职责原则(Single Responsibility Principle)。<br>微服务的边界如何划分？答案是根据业务的边界来确定服务的边界。<br>至于很小，多小算是小？这个事情仁者见仁智者见智，有的人说花2周的时间能够构建完就可以，有的人说你认为已经够小了就行，我的理解是：只要边界小到能够提供独立的服务就行了。</p>
</li>
<li><p>微服务是自治的<br>一个微服务就是一个独立的实体，一个微服务的部署或修改应该尽量避免对消费方的修改，一个很典型的例子就是有人在设计接口返回值的时候用枚举，这其实很坑的。</p>
</li>
</ol>
<h2 id="微服务的好处"><a href="#微服务的好处" class="headerlink" title="微服务的好处"></a>微服务的好处</h2><h3 id="1-技术异构性"><a href="#1-技术异构性" class="headerlink" title="1.技术异构性"></a>1.技术异构性</h3><p>  服务端和消费端可以采用不同的技术。如果把dubbo看做一个微服务框架，那么它在技术异构性方面做得并不好。当然也有人对dubbo进行了改良，比如当当的<a href="https://github.com/dangdangdotcom/dubbox" target="_blank" rel="external">dubbox</a>，它在dubbo协议基础上增加了REST接口，这样消费方就可以使用其他协议与dubbo进行交互了。</p>
<h3 id="2-弹性"><a href="#2-弹性" class="headerlink" title="2.弹性"></a>2.弹性</h3><p>  弹性工程学的一个关键概念就是“舱壁”，比如轮船的水密舱。当一个舱进水时，通过关闭该舱来确保其它舱不进水，进而保证整条船的安全。在微服务中，一个服务A可能会消费下游的很多服务，如果下游的某个服务有问题，那么它不能影响A服务自身的运行的。</p>
<h3 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3.扩展"></a>3.扩展</h3><p>  对于单块服务来讲，即便是系统中某一个服务存在性能问题，那么也需要对整个系统进行扩展。如果使用较多的小服务，那么你只需要对存在性能问题的服务进行扩展就行了。</p>
<h3 id="4-简化部署"><a href="#4-简化部署" class="headerlink" title="4.简化部署"></a>4.简化部署</h3><p>  对于线上服务来说，相对于代码量巨大的单块系统，微服务具有灵活的部署优势和更小的部署风险。这里引申出一个比较重要的部署原则就是：每次部署应尽量少地修改代码，这样才能减少两次部署之间的差异。</p>
<h3 id="5-与组织机构更加匹配"><a href="#5-与组织机构更加匹配" class="headerlink" title="5.与组织机构更加匹配"></a>5.与组织机构更加匹配</h3><p>  说到系统与组织机构的关系，就不能不提康威定律。梅尔.康威在1968年4月的Datamation杂志上发表的一篇名为“How Do Committees Invent”的论文中提出：任何组织在设计一套系统时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。<br>  这里暂时不对康威定律做过多描述，但最起码有一点是肯定的，相比于单体应用，为服务能够更好地在团队之间交接，尤其那些业务、团队频繁变动的公司。</p>
<h3 id="6-可组合性"><a href="#6-可组合性" class="headerlink" title="6.可组合性"></a>6.可组合性</h3><p>  相比单体应用，为服务能够更方便地组合成新的微服务，这一点的思路跟乐高倒是有点相像。</p>
<h3 id="7-可替代性"><a href="#7-可替代性" class="headerlink" title="7.可替代性"></a>7.可替代性</h3><p>  一个规模比较大的单体应用，相信很少有人敢替代它。但对于一个规模比较小的微服务来讲，重新实现或者删除这个服务的可行性就大大增加了。</p>
<h2 id="微服务的不足"><a href="#微服务的不足" class="headerlink" title="微服务的不足"></a>微服务的不足</h2><p>  《微服务设计》这本书里面只是提到了微服务的好处，但是并没有提到微服务有哪些不足和挑战，这里自己做一些总结。</p>
<h3 id="1-维护压力"><a href="#1-维护压力" class="headerlink" title="1.维护压力"></a>1.维护压力</h3><p>  首先从服务部署的角度，无论是单机多服务，还是单机单服务，都会运维量的增加。单机多服务意味着服务维护复杂性的增加。比如服务器load高了，那到底是哪个服务引起的呢？单机单服务意味着服务器数量的增加。<br>  另外，微服务之间存在着很强的关联关系，当系统出现异常时，很有可能是因为下游的系统异常导致的，这就需要我们做好服务的监控和治理，甚至问题排查。因此，一旦你开始引入微服务，那么你就要在最开始的时候好好规划服务的治理。</p>
<h3 id="2-重复性劳动"><a href="#2-重复性劳动" class="headerlink" title="2.重复性劳动"></a>2.重复性劳动</h3><p>  重复性劳动是指你可能无法更多地像单体应用那样引用部分代码，毕竟服务之间是隔离的。当然你也可以通过抽取lib包这样的方式在微服务之间做到代码复用，但是那样就需要微服务的团队之间具有有效的沟通机制。</p>
<h3 id="3-系统运行效率"><a href="#3-系统运行效率" class="headerlink" title="3.系统运行效率"></a>3.系统运行效率</h3><p>  微服务之间的交互是通过网络进行的，因此网络的效率、稳定性就变得更加重要。在单体应用中，我们不必担心模块之间交互的数据量、效率，但是在微服务中，服务与服务之间的效率将至关重要。</p>
<h3 id="4-资源浪费"><a href="#4-资源浪费" class="headerlink" title="4.资源浪费"></a>4.资源浪费</h3><p>  一般来说，微服务推荐的部署方式是单机单服务，这也意味着更多的资源浪费。毕竟我们需要为操作系统、其他基础设施预留一些内存。在一个单体应用中，这些内存就可以共用。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/07/30/读书笔记-微服务设计/" data-id="cirkc45d90003fgusr0ssj54k" class="article-share-link" data-share="baidu" data-title="读书笔记:微服务设计-入门">分享到</a>
      

      
        <a href="http://fengfu.io/2016/07/30/读书笔记-微服务设计/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微服务/">微服务</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CTO、技术总监、首席架构师的区别-转" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/30/CTO、技术总监、首席架构师的区别-转/" class="article-date">
  <time datetime="2016-06-30T10:15:38.000Z" itemprop="datePublished">2016-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/30/CTO、技术总监、首席架构师的区别-转/">CTO、技术总监、首席架构师的区别(转)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>注:本文转自微信号erpweixin(简化ERP)，如转载请注明原文地址。原文地址请点 <a href="http://mp.weixin.qq.com/s?__biz=MjM5Njk2Mzg0MQ==&amp;mid=2651072525&amp;idx=1&amp;sn=4a5147a1fe70e3531891caf8fba29bb6&amp;scene=24&amp;srcid=0630cwnSLIEbtxEJQFdjTnWv#rd" title="CTO、技术总监、首席架构师的区别" target="_blank" rel="external">这里</a>：</p>
<p>经常有创业公司老板来拜访我，常常会拜托给我一句话：帮我找一个CTO。</p>
<p>我解释的多了，所以想把这个写下来，看看你到底需要的应该是啥。</p>
<h2 id="一、高级程序员"><a href="#一、高级程序员" class="headerlink" title="一、高级程序员"></a>一、高级程序员</h2><p>如果你是一个刚刚创业的公司，公司没有专职产品经理和项目经理，你就是公司的产品经理，你如果对你现在的开发员能力不满，那么你只需要的是一个高级程序员。</p>
<p>你定义功能、你做计划推进和管理，他可以带1-2个副手把你规划的功能实现了，他是主力干活者，有技术难题也是他来亲自攻克解决。</p>
<p>所以，一个高级程序员，他的职责很清晰：</p>
<p>1、负责核心复杂功能的实现方案设计、编码实现<br>2、负责疑难BUG分析诊断、攻关解决</p>
<h2 id="二、研发Leader"><a href="#二、研发Leader" class="headerlink" title="二、研发Leader"></a>二、研发Leader</h2><p>公司再长大些。如果你就有一个研发团队（含产品/开发/测试），你就一套主产品，而且你的研发团队小于15人，那么你需要的就是一个研发Leader。</p>
<p>因为你已经有了1-2个高级程序员，核心难题攻克和核心功能研发进度与质量保证，已经可以靠他们自身能力解决掉了。那么你需要研发Leader干什么。</p>
<p>研发Leader的职责是：</p>
<p>1、团队任务管理：开发工作量评估、开发任务分配</p>
<p>2、团队生产质量提升：代码审核、开发风险识别/报告/协调解决</p>
<p>3、团队生产力提升：代码模板研发与推广、最佳实践规范总结与推广、自动化研发生产工具研发与推广</p>
<p>4、团队专业力提升：招聘面试、新人指导、领导复盘总结改进</p>
<h2 id="三、技术总监"><a href="#三、技术总监" class="headerlink" title="三、技术总监"></a>三、技术总监</h2><p>如果你的研发团队超过20人了，而且有多套主打产品线了，你可能已经有了多个研发Leader了，那么你需要一个技术总监。</p>
<p>技术总监的职责：</p>
<p>1、组建平台研发部，搭建公共技术平台，方便上面各条产品线开发。</p>
<p>2、通过技术平台、通过高一层的职权，管理和协调各个产品线组。现在每个产品线都应该有合格的研发Leader和高级程序员了。</p>
<h2 id="四、首席架构师"><a href="#四、首席架构师" class="headerlink" title="四、首席架构师"></a>四、首席架构师</h2><p>因为你已经有了技术总监了，所以技术平台不错了。技术平台和各条产品线的协调互动，也是技术总监管着。</p>
<p>因为你已经有了各个产品线的高级程序员，他们在靠个人能力维持着核心功能模块的开发进度和代码质量。</p>
<p>因为你已经有了研发Leader，所以代码模板研发与推广、最佳实践规范总结与推广，这些事都已经在日常按份内职责开展了。</p>
<p>那么，啥时候需要首席架构师啊。</p>
<p>也就是说，需要分离管理族和专业族了。你会发现，这个阶段你的研发团队已经超过100来人了，需要有人专注来做架构规划、设计、日常维护。不能让研发总监和研发Leader又做管理又做技术一股脑都扔给他们，你就等着总结果产出。这是不对的。</p>
<p>需要从技术总监和研发Leader身上剥离职责了。让技术总监和研发Leader偏项目管理（管理族），把各个模块之间的架构设计工作，独立出一个岗位，就是架构师，来负责。</p>
<p>每个产品线都有架构师，在技术平台部门也有技术平台的架构师。那么，技术平台和业务产品线的架构互动，就是首席架构师在衔接了。让技术平台架构能够和产品业务系统的架构互相促进和支撑，就是首席架构师的份内之事。</p>
<p>架构师的职责是：</p>
<p>1、架构分析：从功能性需求中识别出需要增加的非功能性需求，好满足性能、可扩展、解耦/集成、安全、可运维、高可用、易部署、易更新。并且识别完非功能型需求，还要做技术选型、技术架构风险识别、技术实现工作量评估</p>
<p>2、架构设计与实现：非功能性模块的架构设计、接口设计、代码实现。所以需要的是有代码实现能力还要有架构思维的工程师，不需要画PPT的工程师</p>
<p>3、业务架构设计与实现：需要对跨系统的接口进行识别、实现、维护，需要对能写成公共代码类库的进行分析、识别、接口设计、实现、变更维护。</p>
<p>4、重构：架构师需要经常做Bug分析、非模板性和公共类库代码检查，以发现代码腐烂程度，以发现还有哪些代码没有做很好的架构与精心的代码设计。所以重构是经常性维护发生的，不是攒到某一刻动大手术，甚至推翻重做，那就不叫重构了。</p>
<h2 id="五、CTO"><a href="#五、CTO" class="headerlink" title="五、CTO"></a>五、CTO</h2><p>你把架构师团队组织建立完成，再往大长，你才需要真正意义上的CTO了。否则你一开始就招真正的CTO，他也不满意，你的期望也不对。现在你的期望也对了，他的能力模型也正好和你的期望职能匹配了，你能给他的和他想要的也正好匹配了。</p>
<p>有的公司有软件系统产品副总裁，也有软件系统技术副总裁，而且把软件系统技术副总裁叫CTO，软件系统产品副总裁叫产品VP。这就很怪异。</p>
<p>真正的CTO，是软件产品和技术是统一管理的。</p>
<p>他做的事情，是商业、产品、技术、管理、团队相平衡的综合统管。</p>
<p>CTO的职责：</p>
<p>1、业绩达成：洞察客户需求，捕捉商业机会，规划技术产品，通过技术产品领导业务增长，有清晰的战略规划、主攻方向，带领团队实现组织目标</p>
<p>2、前沿与平台：到这个研发规模规模级别了，一定要有专门的团队做技术应用创新探索和前沿技术预研。而且要和技术平台团队、应用研发团队形成很好的联动作用，让创新原型试点能够很平滑的融入商业平台再让应用研发线规模化的使用起来。大量的前沿探索都死在了内部，做完试点就停滞了，这就需要CTO做好整体的衔接推动工作。</p>
<p>3、研发过程管理：站在全局立场来端到端改进业务流程，为业务增长提供方便</p>
<p>4、组织与人才建设：公司文化和价值观的传承；研发专业族团队梯队建制建设、研发管理族团队梯队建制建设；创建创新激发机制，激发研发人创新向前发展，激发黑马人脱颖而出</p>
<p>阿朱出品必属精品，阿朱出品必属精品，阿朱出品必属精品，阿朱出品必属精品，唉，现在好文章，都需要重要的话说四遍了</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/06/30/CTO、技术总监、首席架构师的区别-转/" data-id="cirkc45eo0017fguswt5m9nrv" class="article-share-link" data-share="baidu" data-title="CTO、技术总监、首席架构师的区别(转)">分享到</a>
      

      
        <a href="http://fengfu.io/2016/06/30/CTO、技术总监、首席架构师的区别-转/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂谈/">杂谈</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM-垃圾回收器CMS之各阶段整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/21/JVM-垃圾回收器CMS之各阶段整理/" class="article-date">
  <time datetime="2016-06-21T07:50:22.000Z" itemprop="datePublished">2016-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/21/JVM-垃圾回收器CMS之各阶段整理/">JVM 垃圾回收器CMS之各阶段总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>先贴一张图：</p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2HFD0qVXXXXblXpXXXXXXXXXX_!!2657627814.jpg" alt=""></p>
<h2 id="1-初始标记阶段-CMS-initial-mark"><a href="#1-初始标记阶段-CMS-initial-mark" class="headerlink" title="1.初始标记阶段(CMS-initial-mark)"></a>1.初始标记阶段(CMS-initial-mark)</h2><p>  这个阶段的主要任务是找到堆中所有的垃圾回收根节点对象，这个阶段会暂停所有的应用程序线程，即STW(Stop the world)。此阶段会打印1行日志，如下：</p>
<pre><code>[GC [1 CMS-initial-mark: 2905437K(4096000K)] 3134625K(5916480K), 0.2551680 secs] [Times: user=0.26 sys=0.00, real=0.25 secs]
</code></pre><p>其中第一组数据，第一对数据标识老年代实际占用的空间大小和老年代分配的空间大小，第二对数据标识整个堆的实际使用情况和分配的堆的空间。<br>细心的人可能发现了CMS-initial-mark前面的数字“1”，这个标志代表了STW，在后面的“重新标记”阶段，你也会发现这个标志。这正好与上面图中说明的阶段是对应的。</p>
<h2 id="2-标记阶段-CMS-concurrent-mark"><a href="#2-标记阶段-CMS-concurrent-mark" class="headerlink" title="2.标记阶段(CMS-concurrent-mark)"></a>2.标记阶段(CMS-concurrent-mark)</h2><p>  这个阶段是和应用线程并发执行的，所谓并发收集器指的就是这个，主要作用是标记可达的对象。由于只是进行标记，所以不会对堆的占用产生实质的改变。</p>
<pre><code>2016-06-21T16:38:53.911+0800: 367848.849: [CMS-concurrent-mark-start]
2016-06-21T16:38:57.241+0800: 367852.178: [CMS-concurrent-mark: 2.787/3.329 secs] [Times: user=12.12 sys=0.64, real=3.33 secs]
</code></pre><p>这个阶段会打印2行日志，第一行CMS-concurrent-mark-start标识标记阶段开始。第二行中的“2.787/3.329 secs”表示标记阶段的耗时。后面的“user=12.12”表示占用的cpu时间(此JVM运行的服务器CPU为4核)。</p>
<h2 id="3-预清理阶段-CMS-concurrent-preclean"><a href="#3-预清理阶段-CMS-concurrent-preclean" class="headerlink" title="3.预清理阶段(CMS-concurrent-preclean)"></a>3.预清理阶段(CMS-concurrent-preclean)</h2><p>  在之前的标记阶段，标记和应用线程是并发执行的，因此有些对象的状态在标记后会发生改变。这个阶段只要是发现从新生代晋升的对象、新分配到老年代的对象以及在标记阶段被修改了的对象。<br>  这个阶段也会打印2行日志，跟标记阶段类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-06-21T16:38:57.241+0800: 367852.178: [CMS-concurrent-preclean-start]&#10;2016-06-21T16:38:57.718+0800: 367852.655: [CMS-concurrent-preclean: 0.342/0.477 secs] [Times: user=1.79 sys=0.10, real=0.48 secs]</span><br></pre></td></tr></table></figure>
<h2 id="4-重新标记阶段"><a href="#4-重新标记阶段" class="headerlink" title="4.重新标记阶段"></a>4.重新标记阶段</h2><p>  可中断预清理阶段是在JDK1.5中加入的。这个阶段是CMS中比较复杂的一个阶段，因为在这个阶段，JVM会执行很多操作。<br>  首先是CMS-concurrent-abortable-preclean，可中断的预清理。我们可能要问，既然再上一个阶段已经执行了预清理了，为什么还要再做一次？我们知道，CMS是以获取最短停顿时间为目的的GC，所以简单说进行可中断预清理的目的就是希望尽量缩短停顿的时间。<br>  可中断预清理涉及几个参数：<br>  -XX:CMSMaxAbortablePrecleanTime：当abortable-preclean阶段执行达到这个时间时才会结束<br>  -XX:CMSScheduleRemarkEdenSizeThreshold（默认2m）：控制abortable-preclean阶段什么时候开始执行，即当eden使用达到此值时，才会开始abortable-preclean阶段<br>  -XX:CMSScheduleRemarkEdenPenetratio（默认50%）：控制abortable-preclean阶段什么时候结束执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-06-21T16:38:57.718+0800: 367852.656: [CMS-concurrent-abortable-preclean-start]&#10;2016-06-21T16:38:58.801+0800: 367853.738: [CMS-concurrent-abortable-preclean: 0.920/1.083 secs] [Times: user=4.06 sys=0.20, real=1.08 secs]&#10;2016-06-21T16:38:58.808+0800: 367853.746: [GC[YG occupancy: 777901 K (1820480 K)]367853.746: [Rescan (parallel) , 0.1361120 secs]367853.882: [weak refs processing, 0.0005370 secs]367853.883: [scrub string table, 0.0044130 secs] [1 CMS-remark: 3034451K(4096000K)] 3812352K(5916480K), 0.1412750 secs] [Times: user=0.54 sys=0.00, real=0.14 secs]</span><br></pre></td></tr></table></figure>
<p>  其次，是Rescan操作，此阶段暂停应用线程，对对象进行重新扫描并标记。通过上面的日志我们可以看到，在CMS-remark的时候有一次STW。另外，这个过程还会打印出弱引用处理、类卸载等过程的耗时。</p>
<h2 id="5-清除阶段-CMS-concurrent-sweep"><a href="#5-清除阶段-CMS-concurrent-sweep" class="headerlink" title="5.清除阶段(CMS-concurrent-sweep)"></a>5.清除阶段(CMS-concurrent-sweep)</h2><p>  这个阶段开始进行垃圾的清理工作，此时应用线程被重新激活，回收线程与应用线程并发运行，那些无效的对象被清理掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-06-21T16:38:58.950+0800: 367853.888: [CMS-concurrent-sweep-start]&#10;2016-06-21T16:39:05.850+0800: 367860.788: [CMS-concurrent-sweep: 5.656/6.900 secs] [Times: user=25.88 sys=1.28, real=6.90 secs]</span><br></pre></td></tr></table></figure>
<h2 id="6-初始标记阶段-CMS-concurrent-reset"><a href="#6-初始标记阶段-CMS-concurrent-reset" class="headerlink" title="6.初始标记阶段(CMS-concurrent-reset)"></a>6.初始标记阶段(CMS-concurrent-reset)</h2><p>  这是CMS一个回收周期的最后一个阶段，在这个阶段，CMS会清除内部状态，为下次回收做准备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-06-21T16:39:05.850+0800: 367860.788: [CMS-concurrent-reset-start]&#10;2016-06-21T16:39:05.860+0800: 367860.798: [CMS-concurrent-reset: 0.010/0.010 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>
<p>  至此，一个CMS周期结束。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/06/21/JVM-垃圾回收器CMS之各阶段整理/" data-id="cirkc45eh0012fgus4ivjw2o4" class="article-share-link" data-share="baidu" data-title="JVM 垃圾回收器CMS之各阶段总结">分享到</a>
      

      
        <a href="http://fengfu.io/2016/06/21/JVM-垃圾回收器CMS之各阶段整理/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-性能调优工具-Java-Mission-Control" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/20/性能调优工具-Java-Mission-Control/" class="article-date">
  <time datetime="2016-05-20T06:59:20.000Z" itemprop="datePublished">2016-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/20/性能调优工具-Java-Mission-Control/">性能调优工具-Java Mission Control</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>最近1年多的时间，因为需要排查线上应用出现的性能问题，会借助一些工具如JProfiler、Yourkit，但是这些工具都具有商业性质，使用时难免受到限制。后来发现Oracle Jdk(version&gt;=7u40)中自带了一个Java Mission Control(以下简称JMC)的应用，也可以实现JVM的监控。</p>
<p>另外，与JProfiler等使用JVMPI/JVMTI方式实现的工具不同，JMC使用了JVM内部特定的基于事件的接口，几乎不会给应用造成额外的压力（默认设置下，对性能影响小于1%），因此可以用在负载很高的生产环境中。</p>
<p>本文就来简单介绍一下使用JMC来监测JVM性能。</p>
<p><em>注意：需要下载Oracle Jdk 7u40以后的版本，OpenJdk无效，切记！</em></p>
<h2 id="2-目标JVM配置"><a href="#2-目标JVM配置" class="headerlink" title="2.目标JVM配置"></a>2.目标JVM配置</h2><p>在被监控的JVM（目标JVM）上需要开启以下Java Options才能对其进行监控，对于Tomcat来说，在JAVA_OPTS或CATALINA_OPTS中加入以下代码即可：</p>
<pre><code>-Dcom.sun.management.jmxremote.authenticate=false
-Dcom.sun.management.jmxremote.ssl=false
-Djava.rmi.server.hostname=192.168.32.11
-Dcom.sun.management.jmxremote.port=7777
-Dcom.sun.management.jmxremote
-XX:+UnlockCommercialFeatures
-XX:+FlightRecorder
</code></pre><p>java.rmi.server.hostname：如果要允许其它机器监控该程序，必须设定，否则就只能在本机监控该程序。<br>com.sun.management.jmxremote：启用JMX远程监控。<br>com.sun.management.jmxremote.port：JMX远程监控的端口。<br>com.sun.management.jmxremote.ssl：将此配置设置为 true 时，将使用服务器证书通过 SSL 来保护通信。<br>com.sun.management.jmxremote.authenticate：是否开启权限控制，如果设置为true，需要指定两个文件：jmxremote.password和jmxremote.access，password文件主要是配置用户名和密码，access主要是配置权限（可读或者读写）。<br>在Tomcat的bin目录下增加下面两个文件：jmxremote.password和jmxremote.access，格式如下：</p>
<p>jmxremote.access：</p>
<pre><code>admin readwrite
monitor readonly
</code></pre><p>表示admin有操作权限（比如调用GC等操作），monitor只有查看权限，不能进行任何操作。<br>jmxremote.password：</p>
<pre><code>admin test
monitor test    
</code></pre><p>表示有两个用户，admin和monitor，密码分别是test和test。</p>
<p>-XX:+UnlockCommercialFeatures：开启商业特性，默认这个选项是关闭的。<br>-XX:+FlightRecorder：开启飞行记录器。</p>
<p>上述参数配置完毕，重新启动tomcat即可。</p>
<h2 id="3-连接远程JVM"><a href="#3-连接远程JVM" class="headerlink" title="3.连接远程JVM"></a>3.连接远程JVM</h2><p>双击本地%JDK_HOME%\bin\jmc.exe，点击左侧“创建新定制JVM连接”图标， </p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2L_MapXXXXXaGXFXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2h8gqpXXXXXbUXXXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p>在弹出的窗口中输入远程JVM的IP地址和端口号：</p>
<p><img src="https://img.alicdn.com/imgextra/i2/2657627814/TB29LQKpXXXXXX3XXXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p>选择“启动JMX控制台”，点击“完成”。</p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2hE_PpXXXXXcRXXXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p>进入JMC主界面：</p>
<p><img src="https://img.alicdn.com/imgextra/i4/2657627814/TB2mAEGpXXXXXaHXXXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p>在左侧飞行记录器的菜单上点击右键，选择“启动飞行记录”，进入到启动飞行记录的界面，在此界面设置飞行记录的文件路径、记录时长(固定时长或固定间隔)：</p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2xSsHpXXXXXafXXXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p>设置监控的事件：</p>
<p><img src="https://img.alicdn.com/imgextra/i4/2657627814/TB2TJcEpXXXXXaKXXXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p>在此界面可以设置监控的详细设置，并点击“完成”</p>
<p><img src="https://img.alicdn.com/imgextra/i2/2657627814/TB2DiMkpXXXXXcsXpXXXXXXXXXX_!!2657627814.png" alt=""></p>
<p>现在你可以愉快地使用JFR的强大功能了。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/05/20/性能调优工具-Java-Mission-Control/" data-id="cirkc45dp000ifgus1kvqbty5" class="article-share-link" data-share="baidu" data-title="性能调优工具-Java Mission Control">分享到</a>
      

      
        <a href="http://fengfu.io/2016/05/20/性能调优工具-Java-Mission-Control/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-Instrumentation研究-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/25/Java-Instrumentation研究-2/" class="article-date">
  <time datetime="2016-04-25T02:20:43.000Z" itemprop="datePublished">2016-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/25/Java-Instrumentation研究-2/">Java Instrumentation研究之动态植入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>前一篇文章我们提到：在Java SE5中，Instrument要求在运行前利用命令行参数或者系统参数来设置代理类，在实际的运行之中，虚拟机在初始化之时（在绝大多数的 Java 类库被载入之前），instrumentation的设置已经启动，并在虚拟机中设置了回调函数，检测特定类的加载情况，并完成实际工作。也就是说，在Java SE5中，我们只能使用premain的方式实现Instrumentation。但是在实际的很多的情况下，我们没有办法在虚拟机启动之时就为其设定代理，这样实际上限制了instrument的应用。而Java SE6的新特性改变了这种情况，通过agentmain和Java Tool API中的attach方式，我们可以很方便地在运行过程中动态地设置加载代理类，以达到instrumentation的目的。本文就是对Java动态Instrumentation的实现进行研究。</p>
<h2 id="2-关于agentmain"><a href="#2-关于agentmain" class="headerlink" title="2.关于agentmain"></a>2.关于agentmain</h2><p>在Java SE6的Instrumentation 当中，有一个跟 premain“并驾齐驱”的“agentmain”方法，可以在main函数开始运行之后再运行。<br>跟premain函数一样， 开发者可以编写一个含有“agentmain”函数的Java类：</p>
<pre><code>public static void agentmain(String agentArgs, Instrumentation inst);          [1] 
public static void agentmain(String agentArgs);              [2]
</code></pre><p>[1]的优先级比[2]高，将会被优先执行。</p>
<p>跟前文提到的premain函数一样，我们可以在agentmain方法中对类进行各种操作。其中的agentArgs和Inst的用法跟premain相同。<br>与“Premain-Class”类似，我们必须在manifest文件里面设置“Agent-Class”来指定包含agentmain函数的类。<br>可是，跟premain不同的是，agentmain需要在main函数开始运行后才启动，这样的时机应该如何确定呢，这样的功能又如何实现呢？<br>在 Java SE6 文档当中，我们也许无法在java.lang.instrument包相关的文档部分看到明确的介绍，更加无法看到具体的应用agnetmain的例子。不过，在 Java SE6的新特性里面，有一个不太起眼的地方，揭示了agentmain的用法。这就是Java SE6当中提供的Attach API。</p>
<h2 id="3-关于Attach-API"><a href="#3-关于Attach-API" class="headerlink" title="3.关于Attach API"></a>3.关于Attach API</h2><p><a href="http://docs.oracle.com/javase/7/docs/jdk/api/attach/spec/index.html" target="_blank" rel="external">Attach API</a>不是Java的标准API，而是Sun公司提供的一套扩展API，用来向目标JVM“附着”（Attach）代理工具程序的。有了它，我们可以方便地监控一个JVM，运行一个外加的代理程序。<br>Attach API很简单，只有2个主要的类，都在com.sun.tools.attach包里面：VirtualMachine代表一个Java虚拟机，也就是程序需要监控的目标虚拟机，提供了JVM枚举，Attach动作和Detach动作（Attach 动作的相反行为，从JVM 上面解除一个代理）等等 ; VirtualMachineDescriptor则是一个描述虚拟机的容器类，配合VirtualMachine类完成各种功能。</p>
<h2 id="4-agentmain实现步骤"><a href="#4-agentmain实现步骤" class="headerlink" title="4.agentmain实现步骤"></a>4.agentmain实现步骤</h2><p>与Permain类似，agentmain方式同样需要提供一个agent jar，并且这个jar需要满足：</p>
<ol>
<li>在manifest中指定Agent-Class属性，值为代理类全路径；</li>
<li>代理类需要提供public static void agentmain(String args, Instrumentation inst)或public static void agentmain(String args)方法。并且再二者同时存在时以前者优先。args和inst和premain中的一致。</li>
</ol>
<p>Attach API中的VirtualMachine代表一个运行中的VM，其提供了loadAgent()方法，可以在运行时动态加载一个代理jar，这样就可以实现类似premain的效果了。</p>
<h2 id="5-agentmain实例"><a href="#5-agentmain实例" class="headerlink" title="5.agentmain实例"></a>5.agentmain实例</h2><p>与上文一样，我们要通过Java Instrumentation实现对某个类中所有方法执行时间的统计，只不过不同的是：这次我们采用动态Instrumentation的方式。</p>
<ol>
<li>编写一个简单的测试类Test，以便于后面我们通过动态代理实现方法计时功能；</li>
<li>编写Agent实现类SampleTransformer，实现ClassFileTransformer接口。代码同上篇文章一样，这里不再赘述。</li>
<li><p>编写Agent入口类DynamicAgent，实现agentmain方法：</p>
<p> public static void agentmain(String args, Instrumentation inst)</p>
</li>
<li><p>编写Agent加载类AgentLoader，以通过Attach API中的VirtualMachine来动态加载我们编写的代理jar；</p>
</li>
<li>编写一个测试入口类SampleApp，能够长时间驻留，便于我们测试动态植入功能；本例中我们通过键盘数据接收用户的输入数据。只要用户输入不为“bye”，那么就会执行Test类的test()方法；在系统刚刚启动的时候，我们没有利用动态植入实现对test()方法的计时；当执行动态植入后，再执行test()方法，我们就能看到屏幕除了输出原test()方法输出的“hello world”之外，还额外输出了test()方法的运行计时。这就能够证明植入代码生效了；</li>
<li>设置MANIFEST.MF文件，指定Agent-Class、Can-Retransform-Classes、Can-Redefine-Classes等属性。在本实例所付的代码中，是通过maven配置的，具体请参考附件中的代码；</li>
<li>打包得到DynamicAgent-1.0-SNAPSHOT.jar；</li>
<li><p>执行SampleApp，启动应用：</p>
<p> java -cp /home/fengfu/DynamicAgent/target/DynamicAgent-1.0-SNAPSHOT.jar;/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar io.fengfu.learning.instrument.SampleApp</p>
</li>
</ol>
<p>在交互窗口输入test，我们可以看到系统输出：Hello World!</p>
<ol>
<li>得到SampleApp的进程id，比如1234；</li>
<li><p>执行AgentLoader，启动动态代理：</p>
<p> java -cp /home/fengfu/DynamicAgent/target/DynamicAgent-1.0-SNAPSHOT.jar;/usr/local/jdk1.7/lib/tools.jar;/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar  io.fengfu.learning.instrument.AgentLoader 1234</p>
</li>
<li><p>在SampleApp的交互窗口再次输入test，我们可以看到系统输出：Hello World!，同时也输出：Call to method test took 3001 ms.</p>
</li>
</ol>
<p>大功告成，一个简单的动态植入功能就实现了~<br>本实例的代码可以点 <a href="(http://fengfu.io/attach/DynamicAgent.zip">这里</a>) 下载。</p>
<h2 id="6-说明"><a href="#6-说明" class="headerlink" title="6.说明"></a>6.说明</h2><p>实例虽然简单，但是在代码编写过程中还是遇到了几个坑，贴出来供大家参考：</p>
<ol>
<li>如果动态植入需要通过javassist去修改某些类，那么需要在MANIFEST.MF中设置Can-Retransform-Classes和Can-Redefine-Classes为true；</li>
<li><p>要动态修改的类Test不要跟测试入口类SampleApp放在一个类文件中，否则代理启动动态修改Class时会报如下异常：</p>
<pre><code>java.lang.reflect.InvocationTargetException
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
at java.lang.reflect.Method.invoke(Unknown Source)
at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(Unknown Source)
at sun.instrument.InstrumentationImpl.loadClassAndCallAgentmain(Unknown Source)
Caused by: java.lang.UnsupportedOperationException: class redefinition failed: attempted to add a method
at sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
at sun.instrument.InstrumentationImpl.retransformClasses(Unknown Source)
at io.fengfu.learning.instrument.DynamicAgent.agentmain(DynamicAgent.java:14)
... 6 more
</code></pre></li>
</ol>
<p>分析原因，是因为SampleApp正在运行中，而JVM是不允许reload一个正在运行时的类的。一旦classloader加载了一个class，在运行时就不能重新加载这个class的另一个版本。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/04/25/Java-Instrumentation研究-2/" data-id="cirkc45e7000wfgusx4x52cl5" class="article-share-link" data-share="baidu" data-title="Java Instrumentation研究之动态植入">分享到</a>
      

      
        <a href="http://fengfu.io/2016/04/25/Java-Instrumentation研究-2/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-Instrumentation研究-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/24/Java-Instrumentation研究-1/" class="article-date">
  <time datetime="2016-04-24T07:30:14.000Z" itemprop="datePublished">2016-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/24/Java-Instrumentation研究-1/">Java Instrumentation研究之premain</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>作为一个软件工程师，你有没有遇到过以下场景：</p>
<ol>
<li>为了排查线上问题，非常迫切地想要知道系统中某个方法的运行数据，为此只能临时修改代码，打印日志；</li>
<li>为了查找系统瓶颈，你需要知道某个方法的耗时，为此你只能在方法头尾处记录时间戳，并打印日志或者记录到监控中；</li>
<li>……</li>
</ol>
<p>为了实现上述种种临时需求，你需要修改代码、发布、查看日志。或许，这些场景对于作为码农的你已经习以为常，但是世界是懒人创造的，那有没有一种方式能够避免我们这种重复又无任何积累的劳动呢？答案是有的。</p>
<p>最近，公司的大神 <a href="http://www.cnblogs.com/yuyijq/" target="_blank" rel="external">余昭辉</a> 发布了一个新的应用QTracer watch，可以支持通过简单的配置，查看系统运行时的数据。而实现这一点，竟然不用像以前一样在系统中添加一行代码并发布。这种高大上的技术实现立马让我对神的仰慕之情增加了几分。但仰慕归仰慕，对于神作我们还是需要知道其原理的。</p>
<p>通过了解，清楚了这高大上的技术实现来自于Java的Instrumentation(植入)。</p>
<h2 id="2-Java-Instrumentation简介"><a href="#2-Java-Instrumentation简介" class="headerlink" title="2.Java Instrumentation简介"></a>2.Java Instrumentation简介</h2><p>Instrumentation是Java SE5的新特性，它把Java的instrument功能从本地代码中解放出来，使之可以用Java代码的方式解决问题。使用Instrumentation，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在JVM上的程序，甚至能够替换和修改某些类的定义。有了这样的功能，我们就可以实现更为灵活的运行时虚拟机监控和Java类操作了，这样的特性实际上提供了一种虚拟机级别支持的AOP实现方式，使得我们无需对原有代码做任何升级和改动，就可以实现某些 AOP 的功能了。<br>在Java SE6里面，instrument包被赋予了更强大的功能：启动后的instrument、本地代码（native code）instrument，以及动态改变classpath等。这些改变意味着Java具有了更强的动态控制、解释能力，使得Java语言变得更加灵活多变。<br>在Java SE6里面，最大的改变是运行时的Instrumentation成为可能。在Java SE5中，Instrument要求在运行前利用命令行参数或者系统参数来设置代理类，在实际的运行之中，虚拟机在初始化之时（在绝大多数的 Java 类库被载入之前），instrumentation的设置已经启动，并在虚拟机中设置了回调函数，检测特定类的加载情况，并完成实际工作。但是在实际的很多的情况下，我们没有办法在虚拟机启动之时就为其设定代理，这样实际上限制了instrument的应用。而Java SE 6的新特性改变了这种情况，通过Java Tool API中的attach方式，我们可以很方便地在运行过程中动态地设置加载代理类，以达到 instrumentation的目的。<br>另外，对native的Instrumentation也是Java SE6的一个崭新的功能，这使以前无法完成的功能–对native接口的instrumentation。我们可以在Java SE6中，通过一个或者一系列的prefix添加而得以完成。<br>最后，Java SE6里的Instrumentation也增加了动态添加classpath的功能。所有这些新的功能，都使得instrument包的功能更加丰富，从而使Java语言本身更加强大。</p>
<h2 id="3-Java-Instrumentation原理"><a href="#3-Java-Instrumentation原理" class="headerlink" title="3.Java Instrumentation原理"></a>3.Java Instrumentation原理</h2><p>“java.lang.instrument”包的具体实现，依赖于JVMTI。JVMTI（Java Virtual Machine Tool Interface）是一套由 Java虚拟机提供的，为JVM相关的工具提供的本地编程接口集合。JVMTI是从Java SE5开始引入，整合和取代了以前使用的 Java Virtual Machine Profiler Interface (JVMPI) 和 the Java Virtual Machine Debug Interface (JVMDI)，而在Java SE6中，JVMPI和JVMDI已经消失了。JVMTI提供了一套“代理”程序机制，可以支持第三方工具程序以代理的方式连接和访问JVM，并利用JVMTI提供的丰富的编程接口，完成很多跟JVM相关的功能。事实上，java.lang.instrument包的实现，也就是基于这种机制的：在Instrumentation的实现当中，存在一个JVMTI的代理程序，通过调用JVMTI当中Java类相关的函数来完成Java类的动态操作。除开Instrumentation功能外，JVMTI还在虚拟机内存管理，线程控制，方法和变量操作等等方面提供了大量有价值的函数，具体可以参考<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html" target="_blank" rel="external">JVMTI官方文档</a>。</p>
<h2 id="4-Java-Instrumentation实现步骤"><a href="#4-Java-Instrumentation实现步骤" class="headerlink" title="4.Java Instrumentation实现步骤"></a>4.Java Instrumentation实现步骤</h2><p>在Java SE5时代，Instrument只提供了premain（命令行）一种方式，即在真正的应用程序（包含main方法的程序）main方法启动前启动一个代理程序。而在Java SE6中则包含两种应用Instrumentation的方式：premain（命令行）和agentmain（运行时）。在本文中，我们首先研究premain方式。<br>要实现premain方式，我们要遵循的步骤如下：<br>1）编写Agent实现类，实现ClassFileTransformer接口。ClassFileTransformer中声明了一个方法：</p>
<pre><code>public byte[] transform(
ClassLoader loader, 
String className, 
Class cBR, 
java.security.ProtectionDomain pD, 
byte[] classfileBuffer) throws IllegalClassFormatException
</code></pre><p>通过这个方法，代理可以得到虚拟机载入的类的字节码（通过 classfileBuffer 参数）。代理的各种功能一般是通过操作这一串字节码得以实现的。</p>
<p>2）编写Agent入口类，实现premain方法：</p>
<pre><code>public static void premain(String agentArgs, Instrumentation inst)
</code></pre><p>3）打包Agent：将上述步骤1中声明的Java类打包成一个jar文件，并在META-INF/MANIFEST.MF文件中加入“Premain-Class”来指定此Java类（注意此处需要声明全路径）；</p>
<pre><code>Manifest-Version: 1.0
Premain-Class: io.fengfu.learning.instrument.SampleAgent
</code></pre><p>最终我们打包得到SampleAgent.jar。</p>
<p>4）执行命令：</p>
<pre><code>java -javaagent:SampleAgent-1.0-SNAPSHOT.jar -cp /home/fengfu/SampleAgent/SampleAgent-1.0-SNAPSHOT.jar;/home/fengfu/SampleAgent/lib/javassist-3.19.0-GA.jar io.fengfu.learning.instrument.SampleApp
</code></pre><p>java选项中有-javaagent:xx，xx就是你的agent jar，java通过此选项加载agent,由agent来监控classpath下的应用。<br>如果你的Agent类引入别的包，那么需要使用-cp参数指定包的路径，否则在执行java命令时，会报找不到类的错误。</p>
<h2 id="5-Java-Instrumentation实例-premain"><a href="#5-Java-Instrumentation实例-premain" class="headerlink" title="5.Java Instrumentation实例(premain)"></a>5.Java Instrumentation实例(premain)</h2><p>本实例基于javassist实现了对某个类中所有方法执行时间的统计，具体代码请点击 <a href="http://fengfu.io/attach/SampleAgent.zip">这里</a> 下载。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/04/24/Java-Instrumentation研究-1/" data-id="cirkc45ec000yfgusz255xzqt" class="article-share-link" data-share="baidu" data-title="Java Instrumentation研究之premain">分享到</a>
      

      
        <a href="http://fengfu.io/2016/04/24/Java-Instrumentation研究-1/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-浅谈软件工程师的职业发展方向" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/11/浅谈软件工程师的职业发展方向/" class="article-date">
  <time datetime="2016-04-11T09:31:37.000Z" itemprop="datePublished">2016-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/11/浅谈软件工程师的职业发展方向/">浅谈软件工程师的职业发展方向</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天在跟团队一个工作了2年多的同学做绩效面谈时，该同学问了我一个问题：自己现在比较迷茫，不知道该往哪个方向发展……</p>
<p>相信这是很多有一定工作经验的同学都会有的困惑，很多人每隔几年(一般是3年)就会遇到瓶颈，也会面临着新的选择。这时候，他们都会看不清方向，感到迷茫。如果这个问题得不到解决，那么他的成长就会受到制约，甚至停滞不前。在工作中的表现就是比较沉默甚至消极，严重者则选择离职，寻求新的方向（其实是开始新的轮回……）。此时，如果有人能够根据他们的特点帮助他们选择适合他们的方向，或者给出建议，那么相信他会走出迷雾，豁然开朗，这样团队的稳定性会得到加强。</p>
<p>所以今天简单总结一下软件工程师的职业发展方向，以帮助迷茫的同学早日走出混沌状态。</p>
<h2 id="1-技术专家"><a href="#1-技术专家" class="headerlink" title="1.技术专家"></a>1.技术专家</h2><p>技术专家这个方向对于软件工程师来讲应该是比较容易实现的一个目标，因为这是外在因素影响最小的一个，我们所需要的就是专注和毅力。<br>在技术发展百花齐放、日新月异的今天，我们工作中可能会用到很多的技术，但是很多人只是把自己局限在“用”的层面上，并没有继续去深入研究和改进，更有人只是“知其然不知其所以然”，这样就失去了进一步积累的机会。<br>作家格拉德威尔在《异数》一书中指出：”人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。1万小时的锤炼是任何人从平凡变成超凡的必要条件”。我们做个简单的算术题：如果每天工作八个小时，一周工作五天，那么成为一个领域的专家至少需要五年。<br>5年，看起来貌似时间很长，但是试想一下，如果我们借着工作的机会深入研究某个技术栈的原理，并在此基础上加以实践，那么我们只要不断地积累，最终是有机会成为这方面的专家的。在我身边就有这样的例子：以前我的团队中有个非常内向的小伙子（就叫他HX吧），刚来公司的时候各方面资质很平庸，平时寡言少语，也缺乏自信。在做一个项目时，我们采用了hbase作为系统存储。因为之前对hbase缺乏了解，所以项目过程中踩了很多的坑，于是HX同学就不停地填坑，甚至工作之外的时间都贡献了出去。2年过去了，虽然我们的项目早已结束，但是HX却从未放弃对hbase的研究，相反他经常翻看hbase的代码，并经常去hbase社区查看别人的讨论。现在HX已经成为了公司中对hbase最熟悉的人，并开始往hbase社区提交代码。在公司中他也已经小有名气，其他事业部的开发遇到hbase相关的问题也会来找他了解。虽然他现在还算不是hbase的专家，但是很明显，他现在已经度过了最难熬的时间，已经进入了收获期，只要他继续坚持下去，相信会取得更大的成绩。<br>这是身边真真切切的例子，虽然每个人的情况不完全一样，但是很多时候，我们是可以从别人的故事中找到自己的期待。</p>
<h2 id="2-业务专家"><a href="#2-业务专家" class="headerlink" title="2.业务专家"></a>2.业务专家</h2><p>业务专家这个方向也比较好理解，我们长时间接触某一块业务，耳濡目染，久而久之也就会对这个业务比较熟悉甚至精通了。这个方向，其实我们仔细观察一下，身边也能找出很多的例子。我有一个认识了十几年的前同事，他从毕业开始就在做银行的信贷系统，现在还在做。目前他自己拥有一个几十人的开发团队，在国家开发银行驻场帮国开行做信贷系统，小日子过得很滋润。再回想自己曾经做过银行的外汇系统，最开始跟着中国银行学习业务，边学习边做系统，2年之后系统成熟了，业务熟悉了，就开始给建行做系统。但建行做外汇业务起步比较晚，于是我一个开发给银行的人讲业务，那种成就感你自己可以设想一下。<br>当然，这个方向也需要保持专注，跟上面讲的技术专家是一样的，你需要不断的积累。现在很多同学总是不停地在各个公司跳来跳去，薪水是涨上去了，但是在行业领域却没有太多的积累，从个人发展来讲，这迟早会成为一个限制因素。</p>
<h2 id="3-技术经理"><a href="#3-技术经理" class="headerlink" title="3.技术经理"></a>3.技术经理</h2><p>我们身边有这么一类人，各方面能力都比较均衡，比如技术、沟通能力、组织能力。这样的人经过一段时间的锻炼后，可能会被任命为小组长，承担一些管理性的工作。再经过一段时间的历练，有些人可能不太适合这个方向，于是转向其他方向，剩下的做的还不错的人则继续升级，管理更大的团队，于是就成了技术经理。<br>技术经理的要求不同于前面的2个职位，保持专注就可以；而技术经理的要求就比较广泛，因为你管理的是技术团队，所以技术你不能扔；同时你管的是人，所以人际关系的相关技能你也要提升，比如沟通能力、组织能力，甚至你还要了解心理学、组织行为学等内容。这时候，全方位地充电就成了一个比较好的选择。</p>
<h2 id="4-架构师"><a href="#4-架构师" class="headerlink" title="4.架构师"></a>4.架构师</h2><p>现在还有个名词叫“T型人才”。T型人才是指按知识结构区分出来的一种新型人才类型。用字母“T”来表示他们的知识结构特点。“—”表示有广博的知识面，“|”表示知识的深度。两者的结合，既有较深的专业知识，又有广博的知识面，这类集深与博于一身的人才。这种人才结构不仅在纵向的专业知识上具有较深的理解能力和独到见解，而且在横向上具备比较广泛的一般性知识修养。<br>我理解，架构师就是属于这种人才。他们经过长时间的技术积累，在某个方向上已经具备了比较深厚的沉淀，同时在技术体系上也得到了逐步的完善，于是成为了上天入地无所不能的架构师。<br>一般来讲，要成为T型人才，最好是先成为那道“|”，再成为那到“——”，这样根基会比较扎实。<br>所以对于要立志成为架构师的同学来说，最好先做一个技术专家，在技术专家的基础上，再扩大知识面，最终成为架构师。</p>
<h2 id="5-CTO"><a href="#5-CTO" class="headerlink" title="5.CTO"></a>5.CTO</h2><p>CTO我还是不写了，仰望吧……</p>
<p>喷了这么多，最后简单梳理了各个方向的能力模型，希望抛砖引玉，引发你的思考。</p>
<p><img src="https://img.alicdn.com/imgextra/i3/2657627814/TB2r8UGmVXXXXXPXXXXXXXXXXXX_!!2657627814.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/04/11/浅谈软件工程师的职业发展方向/" data-id="cirkc45dh000cfgusus3l1s97" class="article-share-link" data-share="baidu" data-title="浅谈软件工程师的职业发展方向">分享到</a>
      

      
        <a href="http://fengfu.io/2016/04/11/浅谈软件工程师的职业发展方向/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂谈/">杂谈</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-技术栈选型原则" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/22/技术栈选型原则/" class="article-date">
  <time datetime="2016-03-22T06:55:20.000Z" itemprop="datePublished">2016-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/22/技术栈选型原则/">技术栈选型原则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>未完成</p>
<p>2个能力</p>
<ol>
<li>满足需求的能力：开源产品满足自身功能、性能的能力(开发效率？运行效率？)；需求，梳理自身的业务、技术需求；</li>
<li>自身技术团队维护开源产品的能力；学习曲线以及公司内部的技术支持；</li>
</ol>
<p>3个关注点</p>
<ol>
<li>社区成熟度（用户数、bug数）、活跃度（contributors、releases）、技术支持（论坛、文档等）；</li>
<li>成功案例；</li>
</ol>
<p>避免过度炫技<br>不要因为一个人的喜好而舍弃掉整个技术团队，在任何时候这都是非常愚蠢的事情</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/03/22/技术栈选型原则/" data-id="cirkc45dn000gfgus6kclylmt" class="article-share-link" data-share="baidu" data-title="技术栈选型原则">分享到</a>
      

      
        <a href="http://fengfu.io/2016/03/22/技术栈选型原则/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM触发FullGC的情况总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/08/JVM触发FullGC的情况总结/" class="article-date">
  <time datetime="2016-03-08T14:53:56.000Z" itemprop="datePublished">2016-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/08/JVM触发FullGC的情况总结/">JVM触发FullGC的情况总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>FullGC是Java应用中一个不容忽视的问题，因为FullGC会引起应用停顿，所以它对那些响应时间要求比较高的应用的影响还是非常大的。<br>当然，如果要解决FullGC的问题，我们首先需要知道在什么情况下会引起FullGC，这样才能对症下药，避免FullGC的出现。</p>
<p>下面的总结是针对于系统自动进行FullGC的情况分析，不包含System.gc操作。</p>
<h2 id="1-老年代空间不足"><a href="#1-老年代空间不足" class="headerlink" title="1. 老年代空间不足"></a>1. 老年代空间不足</h2><p>JVM中堆空间主要由新生代和老年代组成。新创建的对象大多在新生代中创建，当对象经过几次Minor GC依然存活，才有机会被转入老年代。这时问题就来了，如果此时老年代的空间不足以容纳从新生代转入的对象，那么JVM就会进行FullGC，以清理老年代的空间。如果进行FullGC后老年代依然无法容纳转入对象，那么系统就会抛出：java.lang.OutOfMemoryError: Java heap space的异常，相比大家都比较熟悉了。</p>
<h2 id="2-永久代空间不足"><a href="#2-永久代空间不足" class="headerlink" title="2. 永久代空间不足"></a>2. 永久代空间不足</h2><p>永久代(Permanent Generation)一般是用来存放类信息、字符串常量的地方，如果我们永久代设置的空间比较小无法容纳足够的类信息时，或者因为频繁热加载类信息，又或者存储了太多的字符串常量，那么系统就会触发FullGC，以清理永久代。如果FullGC之后永久代还无法容纳足够的信息，那么系统就会抛出：java.lang.OutOfMemoryError: PermGen space的异常，眼熟吧:)</p>
<h2 id="3-promotion-failed和concurrent-mode-failure"><a href="#3-promotion-failed和concurrent-mode-failure" class="headerlink" title="3. promotion failed和concurrent mode failure"></a>3. promotion failed和concurrent mode failure</h2><p>promotion failed是指在进行Minor GC时，新生代中的对象从Eden区往survivor区转移，但是survivor区放不下，只能放入老年代，但是悲催的是老年代也放不下，这时就会出现promotion failed的情况，系统会触发FullGC以清理空间。</p>
<p>concurrent mode failure是指在进行CMS GC的过程中有对象要放入老年代，但是老年代空间不够引起的。 </p>
<h2 id="4-统计得到的Minor-GC晋升到旧生代的平均大小大于旧生代的剩余空间"><a href="#4-统计得到的Minor-GC晋升到旧生代的平均大小大于旧生代的剩余空间" class="headerlink" title="4. 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间"></a>4. 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间</h2><p>这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。<br>例如程序第一次触发Minor GC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。<br>当新生代采用PS GC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。<br>除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java -Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</p>
<p>明确了FullGC出现的原理，我们就能根据JVM垃圾回收的情况来判断系统到底是因为什么原因出现了FullGC，也就能对症下药，避免FullGC的出现。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://fengfu.io/2016/03/08/JVM触发FullGC的情况总结/" data-id="cirkc45ef0010fgusmpuv0lgj" class="article-share-link" data-share="baidu" data-title="JVM触发FullGC的情况总结">分享到</a>
      

      
        <a href="http://fengfu.io/2016/03/08/JVM触发FullGC的情况总结/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/人生/">人生</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/商业/">商业</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂谈/">杂谈</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/人生/" style="font-size: 10px;">人生</a> <a href="/tags/商业/" style="font-size: 10px;">商业</a> <a href="/tags/微服务/" style="font-size: 10px;">微服务</a> <a href="/tags/杂谈/" style="font-size: 16.67px;">杂谈</a> <a href="/tags/架构/" style="font-size: 13.33px;">架构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">二月 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/08/07/关键业务系统的JVM启动参数推荐2-0版-转/">关键业务系统的JVM启动参数推荐2.0版[转]</a>
          </li>
        
          <li>
            <a href="/2016/07/30/读书笔记-微服务设计/">读书笔记:微服务设计-入门</a>
          </li>
        
          <li>
            <a href="/2016/06/30/CTO、技术总监、首席架构师的区别-转/">CTO、技术总监、首席架构师的区别(转)</a>
          </li>
        
          <li>
            <a href="/2016/06/21/JVM-垃圾回收器CMS之各阶段整理/">JVM 垃圾回收器CMS之各阶段总结</a>
          </li>
        
          <li>
            <a href="/2016/05/20/性能调优工具-Java-Mission-Control/">性能调优工具-Java Mission Control</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://coolshell.cn" target="_blank">酷壳</a>
          </li>
        
          <li>
            <a href="http://ifeve.com" target="_blank">并发编程网</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 宁静·致远<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"qufengfu"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
