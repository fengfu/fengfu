<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宁静·致远</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fengfu.io/"/>
  <updated>2016-08-07T02:25:15.901Z</updated>
  <id>http://fengfu.io/</id>
  
  <author>
    <name>宁静·致远</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关键业务系统的JVM启动参数推荐2.0版[转]</title>
    <link href="http://fengfu.io/2016/08/07/%E5%85%B3%E9%94%AE%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%9A%84JVM%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E6%8E%A8%E8%8D%902-0%E7%89%88-%E8%BD%AC/"/>
    <id>http://fengfu.io/2016/08/07/关键业务系统的JVM启动参数推荐2-0版-转/</id>
    <published>2016-08-07T02:20:22.000Z</published>
    <updated>2016-08-07T02:25:15.901Z</updated>
    
    <content type="html">&lt;p&gt;注：本文转自SpringSide的作者江南白衣的博客“&lt;a href=&quot;http://calvin1978.blogcn.com/articles/jvmoption-2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关键业务系统的JVM启动参数推荐 2.0版&lt;/a&gt;”，如需转载，请尊重作者权利，注明原文出处，谢谢。&lt;/p&gt;
&lt;p&gt;在关键的业务系统里，除了继续追求技术人员最爱的高吞吐与低延时之外，系统的稳定性与出现问题时排查的便捷性也很重要。&lt;/p&gt;
&lt;p&gt;这是本文的一个原则，后面也会一次又一次的强调，所以与网上其他的文章略有不同，请调优高手和运维老大们多指引。&lt;/p&gt;
&lt;p&gt;更新记录：&lt;/p&gt;
&lt;p&gt;2.0版，增加 -XX:+PerfDisableSharedMem，GC日志指向/dev/shm，避免IO造成的JVM停顿。&lt;/p&gt;
&lt;h1 id=&quot;前言1，资料&quot;&gt;&lt;a href=&quot;#前言1，资料&quot; class=&quot;headerlink&quot; title=&quot;前言1，资料&quot;&gt;&lt;/a&gt;前言1，资料&lt;/h1&gt;&lt;p&gt;学习开源项目的启动脚本是个不错的主意，比如&lt;a href=&quot;https://github.com/apache/cassandra/blob/trunk/conf/cassandra-env.sh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cassandra&lt;/a&gt;家的， 附送一篇&lt;a href=&quot;https://tobert.github.io/pages/als-cassandra-21-tuning-guide.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;解释它的文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://hllvm.group.iteye.com/group/topic/27945&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JVM调优的”标准参数”的各种陷阱&lt;/a&gt; R大的文章，在JDK6时写的，期待更新。&lt;/p&gt;
&lt;p&gt;偶然翻到Linkedin工程师的&lt;a href=&quot;http://www.importnew.com/11336.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;更偶然翻到的&lt;a href=&quot;http://www.techpaste.com/2012/02/java-command-line-options-jvm-performance-improvement/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一份不错的参数列表&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;前言2，-XX-PrintFlagsFinal打印参数值&quot;&gt;&lt;a href=&quot;#前言2，-XX-PrintFlagsFinal打印参数值&quot; class=&quot;headerlink&quot; title=&quot;前言2， -XX:+PrintFlagsFinal打印参数值&quot;&gt;&lt;/a&gt;前言2， -XX:+PrintFlagsFinal打印参数值&lt;/h1&gt;&lt;p&gt;当你在网上兴冲冲找到一个可优化的参数时，先用-XX: +PrintFlagsFinal看看，它可能已经默认打开了，再找到一个，还是默认打开了…&lt;/p&gt;
&lt;p&gt;JDK7与JDK8，甚至JDK7中的不同版本，有些参数值都不一样，所以不要轻信网上任何文章，一切以生产环境同版本的JDK打出来的为准。&lt;/p&gt;
&lt;p&gt;经常以类似下面的语句去查看参数，偷懒不起应用，用-version代替。有些参数设置后会影响其他参数，所以查看时也把它带上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -server -Xmx1024m -Xms1024m -XX:+UseConcMarkSweepGC -XX:+PrintFlagsFinal -version| grep ParallelGCThreads
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;前言3，关于默认值&quot;&gt;&lt;a href=&quot;#前言3，关于默认值&quot; class=&quot;headerlink&quot; title=&quot;前言3，关于默认值&quot;&gt;&lt;/a&gt;前言3，关于默认值&lt;/h1&gt;&lt;p&gt;JDK8会默认打开-XX:+TieredCompilation多层编译，而JDK7则不会。JDK7u40以后的版本会默认打开-XX:+OptimizeStringConcat优化字符串拼接，而之前的则不打开。&lt;/p&gt;
&lt;p&gt;对于这些参数，我的建议是顺势而为，JDK在那个版本默认打开不打开总有它的理由。安全第一，没有很好的因由，不要随便因为网上某篇文章的推荐(包括你现在在读的这篇)就去设置。&lt;/p&gt;
&lt;h1 id=&quot;1-性能篇&quot;&gt;&lt;a href=&quot;#1-性能篇&quot; class=&quot;headerlink&quot; title=&quot;1. 性能篇&quot;&gt;&lt;/a&gt;1. 性能篇&lt;/h1&gt;&lt;p&gt;先写一些不那么常见的，后面再来老生常谈。&lt;/p&gt;
&lt;h2 id=&quot;1-1-取消偏向锁-XX-UseBiasedLocking&quot;&gt;&lt;a href=&quot;#1-1-取消偏向锁-XX-UseBiasedLocking&quot; class=&quot;headerlink&quot; title=&quot;1.1 取消偏向锁 -XX:-UseBiasedLocking&quot;&gt;&lt;/a&gt;1.1 取消偏向锁 -XX:-UseBiasedLocking&lt;/h2&gt;&lt;p&gt;JDK1.6开始默认打开的偏向锁，在没有竞争的情况下，会取消线程同步的原语，比如那个所有方法都挂着synchronized关键字的StringBuffer，如果始终只有一条线程在访问它，就略过同步操作以获得性能提升。&lt;/p&gt;
&lt;p&gt;但一旦有第二条线程访问这把锁，JVM就要撤销偏向锁恢复到未锁定线程的状态，用”-XX:+PrintSafepointStatistics -XX :P rintSafepointStatisticsCount=1” 可以看到不少RevokeBiasd的纪录，像GC一样，会Stop The World的干活，虽然只是很短很短的停顿，但对于多线程并发的应用，取消掉它反而有性能的提升和延时的极微的缩短，所以Cassandra就取消了它。&lt;/p&gt;
&lt;h2 id=&quot;1-2-启动时访问并置零内存页面-XX-AlwaysPreTouch&quot;&gt;&lt;a href=&quot;#1-2-启动时访问并置零内存页面-XX-AlwaysPreTouch&quot; class=&quot;headerlink&quot; title=&quot;1.2 启动时访问并置零内存页面-XX:+AlwaysPreTouch&quot;&gt;&lt;/a&gt;1.2 启动时访问并置零内存页面-XX:+AlwaysPreTouch&lt;/h2&gt;&lt;p&gt;启动时就把参数里说好了的内存全部舔一遍，可能令得启动时慢上一点，但后面访问时会更流畅，比如页面会连续分配，比如不会在晋升新生代到老生代时才去申请页面使得GC停顿时间加长。不过这选项对32G之类的大堆才会更有感觉一点。&lt;/p&gt;
&lt;h2 id=&quot;1-3-Djava-security-egd-file-dev-urandom&quot;&gt;&lt;a href=&quot;#1-3-Djava-security-egd-file-dev-urandom&quot; class=&quot;headerlink&quot; title=&quot;1.3 -Djava.security.egd=file:/dev/./urandom&quot;&gt;&lt;/a&gt;1.3 -Djava.security.egd=file:/dev/./urandom&lt;/h2&gt;&lt;p&gt;UUID.randomUUID() 有时候会很慢，Thread Dump一看居然被锁住了，原因是里面用了SecureRandom，要等待机器产生新的噪音(比如机器里的某个文件发生了变化)才肯产生新的随机数。因此最好让熵池里没有新的噪音因子时重用当前的因子。详见 &lt;a href=&quot;http://blog.csdn.net/xiaoxinyu316/article/details/39064003&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JVM上的随机数与熵池策略&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-4-XX-AutoBoxCacheMax-20000&quot;&gt;&lt;a href=&quot;#1-4-XX-AutoBoxCacheMax-20000&quot; class=&quot;headerlink&quot; title=&quot;1.4 -XX:AutoBoxCacheMax=20000&quot;&gt;&lt;/a&gt;1.4 -XX:AutoBoxCacheMax=20000&lt;/h2&gt;&lt;p&gt;Integer i = 3;这语句有着 int自动装箱成Integer的过程，JDK默认只缓存 -128 ~ +127的int 和 long，超出范围的数字就要即时构建新的Integer对象。设为20000后，我们应用的QPS从48,000提升到50,000，足足4%的影响。详见&lt;a href=&quot;http://blog.csdn.net/chengzhezhijian/article/details/9628251&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java Integer(-128~127)值的==和equals比较产生的思考&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-5-XX-PerfDisableSharedMem&quot;&gt;&lt;a href=&quot;#1-5-XX-PerfDisableSharedMem&quot; class=&quot;headerlink&quot; title=&quot;1.5 -XX:+PerfDisableSharedMem&quot;&gt;&lt;/a&gt;1.5 -XX:+PerfDisableSharedMem&lt;/h2&gt;&lt;p&gt;Cassandra家的一个参数，一直没留意，直到发生高IO时的JVM停顿。原来每次进入安全点（比如GC）, JVM都会默默的在/tmp/hperf 目录写上一点statistics数据，如果刚好遇到PageCache刷盘，把文件阻塞了，就不能结束这个Stop the World的安全点了。用此参数可以禁止JVM写statistics数据，代价是VisualVM和jstat用不了，只能用JMX取数据，但在生产环境本来就不需要VisaulVM。详见&lt;a href=&quot;http://calvin1978.blogcn.com/articles/%20http://www.evanjones.ca/jvm-mmap-pause.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Four Month Bug: JVM statistics cause garbage collection pauses&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-6-不建议的参数&quot;&gt;&lt;a href=&quot;#1-6-不建议的参数&quot; class=&quot;headerlink&quot; title=&quot;1.6 不建议的参数&quot;&gt;&lt;/a&gt;1.6 不建议的参数&lt;/h2&gt;&lt;p&gt;-XX:+AggressiveOpts是一些还没默认打开的优化参数集合, -XX:AutoBoxCacheMax是其中的一项。但如前所述，关键系统里不建议打开。虽然通过-XX:+AggressiveOpts 与 -XX:-AggressiveOpts 的对比，目前才改变了三个参数，但为免以后某个版本的JDK里默默改变更多激进的配置，还是不要了。&lt;/p&gt;
&lt;p&gt;Linkined那种黑科技，先要解锁VMOptions才能配置的就更不用说了，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-XX:+UnlockDiagnosticVMOptions -XX: ParGCCardsPerStrideChunk=32768
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JIT Compile相关的参数，函数调用多少次之后开始编译的阀值，内联函数大小的阀值等等，不要乱改了。&lt;/p&gt;
&lt;p&gt;-XX:+UseFastAccessorMethods，据说在多层编译下还慢了，所以是默认关闭的。&lt;/p&gt;
&lt;h2 id=&quot;1-7-server&quot;&gt;&lt;a href=&quot;#1-7-server&quot; class=&quot;headerlink&quot; title=&quot;1.7 -server&quot;&gt;&lt;/a&gt;1.7 -server&lt;/h2&gt;&lt;p&gt;-server 与 -client的JVM默认参数完全不一样，虽然在Linux 64位JVM里默认会被认成server模式，但还是顺手写上吧。&lt;/p&gt;
&lt;h2 id=&quot;1-8-GC策略&quot;&gt;&lt;a href=&quot;#1-8-GC策略&quot; class=&quot;headerlink&quot; title=&quot;1.8 GC策略&quot;&gt;&lt;/a&gt;1.8 GC策略&lt;/h2&gt;&lt;p&gt;为了稳健，还是8G以下的堆还是CMS好了，G1的细节实现起来难度太大，从理论提出到现在都做了六七年了。&lt;/p&gt;
&lt;p&gt;CMS真正可设的东西也不多，详见&lt;a href=&quot;http://ifeve.com/useful-jvm-flags-part-7-cms-collector/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JVM实用参数（七）CMS收集器&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为我们的监控系统会通过JMX监控内存达到90%的状况（留点处理的时间），所以设置让它75%就开始跑了，早点开始也能避免Full GC等意外情况(概念重申，这种主动的CMS GC，和JVM的老生代、永久代、堆外内存完全不能分配内存了而强制Full GC是不同的概念)。为了让这个设置生效，还要设置-XX:+UseCMSInitiatingOccupancyOnly，否则75只被用来做开始的参考值，后面还是JVM自己算。&lt;/p&gt;
&lt;p&gt;-XX:MaxTenuringThreshold=2，这是GC里改动效果最明显的一个参数了。对象在Survivor区熬过多少次Young GC后晋升到年老代，JDK7里看起来默认是6，跑起来好像变成了15。&lt;/p&gt;
&lt;p&gt;Young GC是最大的应用停顿来源，而新生代里GC后存活对象的多少又直接影响停顿的时间，所以如果清楚Young GC的执行频率和应用里大部分临时对象的最长生命周期，可以把它设的更短一点，让其实不是临时对象的新生代长期对象赶紧晋升到年老代，别呆着。&lt;/p&gt;
&lt;p&gt;用-XX:+PrintTenuringDistribution观察下，如果后面几代都差不多，就可以设小，比如JMeter里是2。而我们的两个系统里一个设了2，一个设了6。&lt;/p&gt;
&lt;p&gt;-XX:+ExplicitGCInvokesConcurrent， 但不要-XX:+DisableExplicitGC， 比如&lt;a href=&quot;http://calvin1978.blogcn.com/articles/directbytebuffer.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Netty之堆外内存扫盲篇&lt;/a&gt;，可见禁了system.gc() 未必是好事，只要自己的代码里没有调它，也没用什么特别烂的类库，真有人调了总有调的原因。-XX+ExplicitGCInvokesConcurrent 则在full gc时，并不全程停顿，依然只在ygc和两个remark阶段停顿，详见&lt;a href=&quot;http://lovestblog.cn/blog/2015/05/07/system-gc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JVM源码分析之SystemGC完全解读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;-XX: ParallelRefProcEnabled , 默认为false，并行的处理Reference对象，如WeakReference，除非在GC log里出现Reference处理时间较长的日志，否则效果不会很明显，但我们总是要JVM尽量的并行，所以设了也就设了。&lt;/p&gt;
&lt;h2 id=&quot;1-9-GC里不建议设的参数&quot;&gt;&lt;a href=&quot;#1-9-GC里不建议设的参数&quot; class=&quot;headerlink&quot; title=&quot;1.9 GC里不建议设的参数&quot;&gt;&lt;/a&gt;1.9 GC里不建议设的参数&lt;/h2&gt;&lt;p&gt;-XX:+CMSClassUnloadingEnabled，在CMS中清理永久代中的过期的Class而不等到Full GC，JDK7默认关闭而JDK8打开。看自己情况，比如有没有运行动态语言脚本如Groovy产生大量的临时类。它会增加CMS remark的暂停时间，所以如果新类加载并不频繁，这个参数还是不开的好。&lt;/p&gt;
&lt;p&gt;用了CMS，新生代收集默认就是-XX:+UseParNewGC，不用自己设。&lt;/p&gt;
&lt;p&gt;并发收集线程数，ParallelGCThreads＝8+( Processor - 8 ) ( 5/8 )， ConcGCThreads = (ParallelGCThreads + 3)/4，比如双CPU，六核，超线程就是24个处理器，小于8个处理器时ParallelGCThreads按处理器数量，大于时按上述公式ParallelGCThreads＝18， ConcGCThreads＝5。这线程数调整了变化也不大，还是别乱动了。&lt;/p&gt;
&lt;p&gt;-XX:+CMSScavengeBeforeRemark，默认为关闭，在CMS remark前，先执行一次minor GC将新生代清掉，这样从老生代的对象引用到的新生代对象的个数就少了，停止全世界的CMS remark阶段就短一些。如果看到GC日志里remark阶段的时间超长，可以打开此项看看有没有效果，否则还是不要打开了，白白多了次GC。&lt;/p&gt;
&lt;p&gt;-XX:CMSFullGCsBeforeCompaction，默认为0，即每次full gc都对老生代进行碎片整理压缩。Full GC 不同于 前面设置的75%老生代时触发的CMS GC，只在System.gc()，老生代达到100%，老生代碎片过大无法分配空间给新晋升的大对象这些特殊情况里发生，所以设为每次都进行碎片整理是合适的，详见此贴里R大的解释。&lt;/p&gt;
&lt;h2 id=&quot;1-10-内存大小的设置&quot;&gt;&lt;a href=&quot;#1-10-内存大小的设置&quot; class=&quot;headerlink&quot; title=&quot;1.10 内存大小的设置&quot;&gt;&lt;/a&gt;1.10 内存大小的设置&lt;/h2&gt;&lt;p&gt;这些关于大小的参数，给人感觉是最踏实可控的。&lt;/p&gt;
&lt;p&gt;其实JVM除了显式设置的-Xmx堆内存，还有一堆其他占内存的地方(堆外内存，线程栈，永久代，二进制代码cache)，在容量规划的时候要留意。&lt;/p&gt;
&lt;p&gt;关键业务系统的服务器上内存一般都是够的，所以尽管设得宽松点。&lt;/p&gt;
&lt;p&gt;-Xmx, -Xms, 堆内存大小，2～4G均可，再大了GC时间会拖长。&lt;/p&gt;
&lt;p&gt;-Xmn or -XX:NewSize and -XX:MaxNewSize or -XX:NewRatio， JDK默认新生代占堆大小的1/3， 个人喜欢把对半分， 增大新生代的大小，能减少GC的频率（但也会加大每次GC的停顿时间），主要是看老生代里没多少长期对象的话，占2/3太多了。可以用-Xmn 直接赋值(等于-XX:NewSize and -XX:MaxNewSize同值的缩写)，或把NewRatio设为1来对半分(但如果想设置新生代比老生代大就只能用-Xmn)。&lt;/p&gt;
&lt;p&gt;-XX: PermSize=128m -XX:MaxPermSize=512m （JDK7）现在的应用有Hibernate/Spring这些闹腾的家伙AOP之后类都比较多，可以一开始就把初始值从64M设到128M，并设一个更大的Max值以求保险。&lt;/p&gt;
&lt;p&gt;-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m（JDK8），JDK8的永生代几乎可用完机器的所有内存，同样设一个128M的初始值，512M的最大值保护一下。&lt;/p&gt;
&lt;h2 id=&quot;1-11-其他内存大小等可选设置&quot;&gt;&lt;a href=&quot;#1-11-其他内存大小等可选设置&quot; class=&quot;headerlink&quot; title=&quot;1.11 其他内存大小等可选设置&quot;&gt;&lt;/a&gt;1.11 其他内存大小等可选设置&lt;/h2&gt;&lt;p&gt;-XX:SurvivorRatio 新生代中每个存活区的大小，默认为8，即1/10的新生代 1/(SurvivorRatio+2)，有人喜欢设小点省点给新生代，但要避免太小使得存活区放不下临时对象而要晋升到老生代，还是从GC Log里看实际情况了。&lt;/p&gt;
&lt;p&gt;-Xss 在堆之外，线程占用栈内存，默认每条线程为1M（以前是256K）。除了方法调用出参入参的栈，逃逸分析后也会把只在该线程里可见的对象直接分配在线程栈里，而不是公共的Heap里，也就减少了新生代的GC频率。有人喜欢设小点节约内存开更多线程，但反正内存够也就不必要设小，有人喜欢再设大点。&lt;/p&gt;
&lt;p&gt;-XX:MaxDirectMemorySize，堆外内存/直接内存的大小，默认为Heap区总内存减去一个Survivor区的大小，详见&lt;a href=&quot;http://calvin1978.blogcn.com/articles/directbytebuffer.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Netty之堆外内存扫盲篇&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;-XX:ReservedCodeCacheSize， JIT编译后二进制代码的存放区，满了之后就不再编译。JDK7默认不开多层编译48M，开了96M，而JDK8默认开多层编译256M。可以在JMX里看看CodeCache的大小，JDK7下的48M一般够了，也可以把它设大点，反正内存多。&lt;/p&gt;
&lt;h1 id=&quot;2-监控篇&quot;&gt;&lt;a href=&quot;#2-监控篇&quot; class=&quot;headerlink&quot; title=&quot;2. 监控篇&quot;&gt;&lt;/a&gt;2. 监控篇&lt;/h1&gt;&lt;p&gt;JVM输出的各种日志，如果未指定路径，通常会生成到运行应用的相同目录，为了避免有时候在不同的地方执行启动脚本，一般将日志路径集中设到一个固定的地方。&lt;/p&gt;
&lt;h2 id=&quot;2-1-XX-PrintCommandLineFlags&quot;&gt;&lt;a href=&quot;#2-1-XX-PrintCommandLineFlags&quot; class=&quot;headerlink&quot; title=&quot;2.1 -XX:+PrintCommandLineFlags&quot;&gt;&lt;/a&gt;2.1 -XX:+PrintCommandLineFlags&lt;/h2&gt;&lt;p&gt;运维有时会对启动参数做一些临时的更改，将每次启动的参数输出到stdout，将来有据可查。&lt;br&gt;打印出来的是命令行里设置了的参数以及因为这些参数隐式影响的参数，比如开了CMS后，-XX:+UseParNewGC也被自动打开。&lt;/p&gt;
&lt;h2 id=&quot;2-2-XX-OmitStackTraceInFastThrow&quot;&gt;&lt;a href=&quot;#2-2-XX-OmitStackTraceInFastThrow&quot; class=&quot;headerlink&quot; title=&quot;2.2 -XX:-OmitStackTraceInFastThrow&quot;&gt;&lt;/a&gt;2.2 -XX:-OmitStackTraceInFastThrow&lt;/h2&gt;&lt;p&gt;为异常设置StackTrace是个昂贵的操作，所以当应用在相同地方抛出相同的异常N次(两万?)之后，JVM会对某些特定异常如NPE，数组越界等进行优化，不再带上异常栈。此时，你可能会看到日志里一条条Null Point Exception，而真正输出完整栈的日志早被滚动到不知哪里去了，也就完全不知道这NPE发生在什么地方，欲哭无泪。 所以，将它禁止吧。&lt;/p&gt;
&lt;h2 id=&quot;2-3-coredump与-XX-ErrorFile&quot;&gt;&lt;a href=&quot;#2-3-coredump与-XX-ErrorFile&quot; class=&quot;headerlink&quot; title=&quot;2.3 coredump与 -XX:ErrorFile&quot;&gt;&lt;/a&gt;2.3 coredump与 -XX:ErrorFile&lt;/h2&gt;&lt;p&gt;JVM crash时，hotspot 会生成一个error文件，提供JVM状态信息的细节。如前所述，将其输出到固定目录，避免到时会到处找这文件。文件名中的%p会被自动替换为应用的PID&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-XX:ErrorFile=${MYLOGDIR}/hs_err_%p.log
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，更好的做法是生成coredump，从CoreDump能够转出Heap Dump 和 Thread Dump 还有crash的地方，非常实用。&lt;/p&gt;
&lt;p&gt;在启动脚本里加上 ulimit -c unlimited或其他的设置方式，如果有root权限，用一下一下输出目录更好&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;/{MYLOGDIR}/coredump.%p&amp;quot; &amp;gt; /proc/sys/kernel/core_pattern
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;什么？你不知道这东西什么用？看来你是没遇过JVM Segment Fault的幸福人。&lt;/p&gt;
&lt;h2 id=&quot;2-4-XX-HeapDumpOnOutOfMemoryError&quot;&gt;&lt;a href=&quot;#2-4-XX-HeapDumpOnOutOfMemoryError&quot; class=&quot;headerlink&quot; title=&quot;2.4 -XX:+HeapDumpOnOutOfMemoryError&quot;&gt;&lt;/a&gt;2.4 -XX:+HeapDumpOnOutOfMemoryError&lt;/h2&gt;&lt;p&gt;在Out Of Memory，JVM快死快死掉的时候，输出Heap Dump到指定文件。不然开发很多时候还真不知道怎么重现错误。&lt;/p&gt;
&lt;p&gt;路径只指向目录，JVM会保持文件名的唯一性，叫java_pid${pid}.hprof。如果指向文件，而文件已存在，反而不能写入。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${LOGDIR}/
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;2-5-GC日志&quot;&gt;&lt;a href=&quot;#2-5-GC日志&quot; class=&quot;headerlink&quot; title=&quot;2.5 GC日志&quot;&gt;&lt;/a&gt;2.5 GC日志&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;-Xloggc:/dev/shm/gc-myapplication.log -XX:+PrintGCDateStamps -XX:+PrintGCDetails
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;详见&lt;a href=&quot;http://ifeve.com/useful-jvm-flags-part-8-gc-logging/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JVM实用参数（八）GC日志&lt;/a&gt;，有人担心写GC日志会影响性能，但测试下来实在没什么影响，还是留一份用来排查好。&lt;/p&gt;
&lt;p&gt;到后来，又发现如果遇上高IO的情况，如果GC的时候，操作系统正在flush pageCache 到磁盘，也可能导致GC log文件被锁住，从而让GC结束不了。所以把它指向了/dev/shm 这种内存中数据库，避免这种停顿，详见&lt;a href=&quot;http://calvin1978.blogcn.com/articles/%E2%80%9Chttps://engineering.linkedin.com/blog/2016/02/eliminating-large-jvm-gc-pauses-caused-by-background-io-traffic%E2%80%9D&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Eliminating Large JVM GC Pauses Caused by Background IO Traffic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外还有一个-XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime，它的名字没起好，它除了打印清晰的GC停顿时间外，还可以打印其他的停顿时间，比如取消偏向锁，class 被agent redefine，code deoptimization等等，有助于发现一些原来没想到的问题，建议也加上。如果真的发现了一些不知什么的停顿，再加上”-XX:+PrintSafepointStatistics -XX: PrintSafepointStatisticsCount=1” 找原因。&lt;/p&gt;
&lt;p&gt;GC日志默认会在重启后清空，但有人担心长期运行不重启的应用会把文件弄得很大，有”-XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=1M”的参数可以让日志滚动起来。但重启后的文件名太混乱太让人头痛，所以还是不加。&lt;/p&gt;
&lt;h2 id=&quot;2-6-JMX&quot;&gt;&lt;a href=&quot;#2-6-JMX&quot; class=&quot;headerlink&quot; title=&quot;2.6 JMX&quot;&gt;&lt;/a&gt;2.6 JMX&lt;/h2&gt;&lt;p&gt; &lt;code&gt;-Dcom.sun.management.jmxremote.port=${MY_JMX_PORT} -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=127.0.0.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以上设置，只让本地的Zabbix之类监控软件通过JMX监控JVM，不允许远程访问。&lt;/p&gt;
&lt;p&gt;《关键业务系统的JVM启动参数推荐》，转载请保留链接。&lt;/p&gt;
&lt;p&gt;谢谢看到这里，还是贴个图吧。&lt;/p&gt;
&lt;p&gt;有关的…&lt;/p&gt;
&lt;p&gt;2016-07-30 – 从dstat理解Linux性能监控体系&lt;br&gt;2016-04-29 – Java应用调优之－目标与资料篇&lt;br&gt;2016-04-28 – 另一份Java应用调优指南之－工具篇&lt;br&gt;2016-01-01 – 另一份Java应用调优指南之－前菜&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;注：本文转自SpringSide的作者江南白衣的博客“&lt;a href=&quot;http://calvin1978.blogcn.com/articles/jvmoption-2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关键业务系统的JVM启动参数
    
    </summary>
    
    
      <category term="Java" scheme="http://fengfu.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记:微服务设计-入门</title>
    <link href="http://fengfu.io/2016/07/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>http://fengfu.io/2016/07/30/读书笔记-微服务设计/</id>
    <published>2016-07-30T03:11:37.000Z</published>
    <updated>2016-08-07T08:15:27.121Z</updated>
    
    <content type="html">&lt;h1 id=&quot;第一章-微服务&quot;&gt;&lt;a href=&quot;#第一章-微服务&quot; class=&quot;headerlink&quot; title=&quot;第一章 微服务&quot;&gt;&lt;/a&gt;第一章 微服务&lt;/h1&gt;&lt;h2 id=&quot;微服务的由来&quot;&gt;&lt;a href=&quot;#微服务的由来&quot; class=&quot;headerlink&quot; title=&quot;微服务的由来&quot;&gt;&lt;/a&gt;微服务的由来&lt;/h2&gt;&lt;p&gt;微服务不是发明出来的，而是随着领域驱动设计、持续交付、按需虚拟化、基础设施自动化、小型自治团队、大型集群系统这些实践的流行，从现实世界总结出来的。&lt;/p&gt;
&lt;p&gt;拓展知识点：Eric Evans的《&lt;a href=&quot;http://item.jd.com/11961038.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;领域驱动设计&lt;/a&gt;》、Alistair Cookburn的&lt;a href=&quot;http://alistair.cockburn.us/hexagonal+architecture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;六边形架构理论&lt;/a&gt;、Netflix的构建大型反脆弱系统&lt;/p&gt;
&lt;h2 id=&quot;什么是微服务&quot;&gt;&lt;a href=&quot;#什么是微服务&quot; class=&quot;headerlink&quot; title=&quot;什么是微服务&quot;&gt;&lt;/a&gt;什么是微服务&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;微服务很小&lt;br&gt;在考虑微服务时，内聚性这一原则很重要，具体可以联想到单一职责原则(Single Responsibility Principle)。&lt;br&gt;微服务的边界如何划分？答案是根据业务的边界来确定服务的边界。&lt;br&gt;至于很小，多小算是小？这个事情仁者见仁智者见智，有的人说花2周的时间能够构建完就可以，有的人说你认为已经够小了就行，我的理解是：只要边界小到能够提供独立的服务就行了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;微服务是自治的&lt;br&gt;一个微服务就是一个独立的实体，一个微服务的部署或修改应该尽量避免对消费方的修改，一个很典型的例子就是有人在设计接口返回值的时候用枚举，这其实很坑的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;微服务的好处&quot;&gt;&lt;a href=&quot;#微服务的好处&quot; class=&quot;headerlink&quot; title=&quot;微服务的好处&quot;&gt;&lt;/a&gt;微服务的好处&lt;/h2&gt;&lt;h3 id=&quot;1-技术异构性&quot;&gt;&lt;a href=&quot;#1-技术异构性&quot; class=&quot;headerlink&quot; title=&quot;1.技术异构性&quot;&gt;&lt;/a&gt;1.技术异构性&lt;/h3&gt;&lt;p&gt;  服务端和消费端可以采用不同的技术。如果把dubbo看做一个微服务框架，那么它在技术异构性方面做得并不好。当然也有人对dubbo进行了改良，比如当当的&lt;a href=&quot;https://github.com/dangdangdotcom/dubbox&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dubbox&lt;/a&gt;，它在dubbo协议基础上增加了REST接口，这样消费方就可以使用其他协议与dubbo进行交互了。&lt;/p&gt;
&lt;h3 id=&quot;2-弹性&quot;&gt;&lt;a href=&quot;#2-弹性&quot; class=&quot;headerlink&quot; title=&quot;2.弹性&quot;&gt;&lt;/a&gt;2.弹性&lt;/h3&gt;&lt;p&gt;  弹性工程学的一个关键概念就是“舱壁”，比如轮船的水密舱。当一个舱进水时，通过关闭该舱来确保其它舱不进水，进而保证整条船的安全。在微服务中，一个服务A可能会消费下游的很多服务，如果下游的某个服务有问题，那么它不能影响A服务自身的运行的。&lt;/p&gt;
&lt;h3 id=&quot;3-扩展&quot;&gt;&lt;a href=&quot;#3-扩展&quot; class=&quot;headerlink&quot; title=&quot;3.扩展&quot;&gt;&lt;/a&gt;3.扩展&lt;/h3&gt;&lt;p&gt;  对于单块服务来讲，即便是系统中某一个服务存在性能问题，那么也需要对整个系统进行扩展。如果使用较多的小服务，那么你只需要对存在性能问题的服务进行扩展就行了。&lt;/p&gt;
&lt;h3 id=&quot;4-简化部署&quot;&gt;&lt;a href=&quot;#4-简化部署&quot; class=&quot;headerlink&quot; title=&quot;4.简化部署&quot;&gt;&lt;/a&gt;4.简化部署&lt;/h3&gt;&lt;p&gt;  对于线上服务来说，相对于代码量巨大的单块系统，微服务具有灵活的部署优势和更小的部署风险。这里引申出一个比较重要的部署原则就是：每次部署应尽量少地修改代码，这样才能减少两次部署之间的差异。&lt;/p&gt;
&lt;h3 id=&quot;5-与组织机构更加匹配&quot;&gt;&lt;a href=&quot;#5-与组织机构更加匹配&quot; class=&quot;headerlink&quot; title=&quot;5.与组织机构更加匹配&quot;&gt;&lt;/a&gt;5.与组织机构更加匹配&lt;/h3&gt;&lt;p&gt;  说到系统与组织机构的关系，就不能不提康威定律。梅尔.康威在1968年4月的Datamation杂志上发表的一篇名为“How Do Committees Invent”的论文中提出：任何组织在设计一套系统时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。&lt;br&gt;  这里暂时不对康威定律做过多描述，但最起码有一点是肯定的，相比于单体应用，为服务能够更好地在团队之间交接，尤其那些业务、团队频繁变动的公司。&lt;/p&gt;
&lt;h3 id=&quot;6-可组合性&quot;&gt;&lt;a href=&quot;#6-可组合性&quot; class=&quot;headerlink&quot; title=&quot;6.可组合性&quot;&gt;&lt;/a&gt;6.可组合性&lt;/h3&gt;&lt;p&gt;  相比单体应用，为服务能够更方便地组合成新的微服务，这一点的思路跟乐高倒是有点相像。&lt;/p&gt;
&lt;h3 id=&quot;7-可替代性&quot;&gt;&lt;a href=&quot;#7-可替代性&quot; class=&quot;headerlink&quot; title=&quot;7.可替代性&quot;&gt;&lt;/a&gt;7.可替代性&lt;/h3&gt;&lt;p&gt;  一个规模比较大的单体应用，相信很少有人敢替代它。但对于一个规模比较小的微服务来讲，重新实现或者删除这个服务的可行性就大大增加了。&lt;/p&gt;
&lt;h2 id=&quot;微服务的不足&quot;&gt;&lt;a href=&quot;#微服务的不足&quot; class=&quot;headerlink&quot; title=&quot;微服务的不足&quot;&gt;&lt;/a&gt;微服务的不足&lt;/h2&gt;&lt;p&gt;  《微服务设计》这本书里面只是提到了微服务的好处，但是并没有提到微服务有哪些不足和挑战，这里自己做一些总结。&lt;/p&gt;
&lt;h3 id=&quot;1-维护压力&quot;&gt;&lt;a href=&quot;#1-维护压力&quot; class=&quot;headerlink&quot; title=&quot;1.维护压力&quot;&gt;&lt;/a&gt;1.维护压力&lt;/h3&gt;&lt;p&gt;  首先从服务部署的角度，无论是单机多服务，还是单机单服务，都会运维量的增加。单机多服务意味着服务维护复杂性的增加。比如服务器load高了，那到底是哪个服务引起的呢？单机单服务意味着服务器数量的增加。&lt;br&gt;  另外，微服务之间存在着很强的关联关系，当系统出现异常时，很有可能是因为下游的系统异常导致的，这就需要我们做好服务的监控和治理，甚至问题排查。因此，一旦你开始引入微服务，那么你就要在最开始的时候好好规划服务的治理。&lt;/p&gt;
&lt;h3 id=&quot;2-重复性劳动&quot;&gt;&lt;a href=&quot;#2-重复性劳动&quot; class=&quot;headerlink&quot; title=&quot;2.重复性劳动&quot;&gt;&lt;/a&gt;2.重复性劳动&lt;/h3&gt;&lt;p&gt;  重复性劳动是指你可能无法更多地像单体应用那样引用部分代码，毕竟服务之间是隔离的。当然你也可以通过抽取lib包这样的方式在微服务之间做到代码复用，但是那样就需要微服务的团队之间具有有效的沟通机制。&lt;/p&gt;
&lt;h3 id=&quot;3-系统运行效率&quot;&gt;&lt;a href=&quot;#3-系统运行效率&quot; class=&quot;headerlink&quot; title=&quot;3.系统运行效率&quot;&gt;&lt;/a&gt;3.系统运行效率&lt;/h3&gt;&lt;p&gt;  微服务之间的交互是通过网络进行的，因此网络的效率、稳定性就变得更加重要。在单体应用中，我们不必担心模块之间交互的数据量、效率，但是在微服务中，服务与服务之间的效率将至关重要。&lt;/p&gt;
&lt;h3 id=&quot;4-资源浪费&quot;&gt;&lt;a href=&quot;#4-资源浪费&quot; class=&quot;headerlink&quot; title=&quot;4.资源浪费&quot;&gt;&lt;/a&gt;4.资源浪费&lt;/h3&gt;&lt;p&gt;  一般来说，微服务推荐的部署方式是单机单服务，这也意味着更多的资源浪费。毕竟我们需要为操作系统、其他基础设施预留一些内存。在一个单体应用中，这些内存就可以共用。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一章-微服务&quot;&gt;&lt;a href=&quot;#第一章-微服务&quot; class=&quot;headerlink&quot; title=&quot;第一章 微服务&quot;&gt;&lt;/a&gt;第一章 微服务&lt;/h1&gt;&lt;h2 id=&quot;微服务的由来&quot;&gt;&lt;a href=&quot;#微服务的由来&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
    
      <category term="微服务" scheme="http://fengfu.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>CTO、技术总监、首席架构师的区别(转)</title>
    <link href="http://fengfu.io/2016/06/30/CTO%E3%80%81%E6%8A%80%E6%9C%AF%E6%80%BB%E7%9B%91%E3%80%81%E9%A6%96%E5%B8%AD%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%BD%AC/"/>
    <id>http://fengfu.io/2016/06/30/CTO、技术总监、首席架构师的区别-转/</id>
    <published>2016-06-30T10:15:38.000Z</published>
    <updated>2016-06-30T10:21:43.848Z</updated>
    
    <content type="html">&lt;p&gt;注:本文转自微信号erpweixin(简化ERP)，如转载请注明原文地址。原文地址请点 &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5Njk2Mzg0MQ==&amp;amp;mid=2651072525&amp;amp;idx=1&amp;amp;sn=4a5147a1fe70e3531891caf8fba29bb6&amp;amp;scene=24&amp;amp;srcid=0630cwnSLIEbtxEJQFdjTnWv#rd&quot; title=&quot;CTO、技术总监、首席架构师的区别&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;经常有创业公司老板来拜访我，常常会拜托给我一句话：帮我找一个CTO。&lt;/p&gt;
&lt;p&gt;我解释的多了，所以想把这个写下来，看看你到底需要的应该是啥。&lt;/p&gt;
&lt;h2 id=&quot;一、高级程序员&quot;&gt;&lt;a href=&quot;#一、高级程序员&quot; class=&quot;headerlink&quot; title=&quot;一、高级程序员&quot;&gt;&lt;/a&gt;一、高级程序员&lt;/h2&gt;&lt;p&gt;如果你是一个刚刚创业的公司，公司没有专职产品经理和项目经理，你就是公司的产品经理，你如果对你现在的开发员能力不满，那么你只需要的是一个高级程序员。&lt;/p&gt;
&lt;p&gt;你定义功能、你做计划推进和管理，他可以带1-2个副手把你规划的功能实现了，他是主力干活者，有技术难题也是他来亲自攻克解决。&lt;/p&gt;
&lt;p&gt;所以，一个高级程序员，他的职责很清晰：&lt;/p&gt;
&lt;p&gt;1、负责核心复杂功能的实现方案设计、编码实现&lt;br&gt;2、负责疑难BUG分析诊断、攻关解决&lt;/p&gt;
&lt;h2 id=&quot;二、研发Leader&quot;&gt;&lt;a href=&quot;#二、研发Leader&quot; class=&quot;headerlink&quot; title=&quot;二、研发Leader&quot;&gt;&lt;/a&gt;二、研发Leader&lt;/h2&gt;&lt;p&gt;公司再长大些。如果你就有一个研发团队（含产品/开发/测试），你就一套主产品，而且你的研发团队小于15人，那么你需要的就是一个研发Leader。&lt;/p&gt;
&lt;p&gt;因为你已经有了1-2个高级程序员，核心难题攻克和核心功能研发进度与质量保证，已经可以靠他们自身能力解决掉了。那么你需要研发Leader干什么。&lt;/p&gt;
&lt;p&gt;研发Leader的职责是：&lt;/p&gt;
&lt;p&gt;1、团队任务管理：开发工作量评估、开发任务分配&lt;/p&gt;
&lt;p&gt;2、团队生产质量提升：代码审核、开发风险识别/报告/协调解决&lt;/p&gt;
&lt;p&gt;3、团队生产力提升：代码模板研发与推广、最佳实践规范总结与推广、自动化研发生产工具研发与推广&lt;/p&gt;
&lt;p&gt;4、团队专业力提升：招聘面试、新人指导、领导复盘总结改进&lt;/p&gt;
&lt;h2 id=&quot;三、技术总监&quot;&gt;&lt;a href=&quot;#三、技术总监&quot; class=&quot;headerlink&quot; title=&quot;三、技术总监&quot;&gt;&lt;/a&gt;三、技术总监&lt;/h2&gt;&lt;p&gt;如果你的研发团队超过20人了，而且有多套主打产品线了，你可能已经有了多个研发Leader了，那么你需要一个技术总监。&lt;/p&gt;
&lt;p&gt;技术总监的职责：&lt;/p&gt;
&lt;p&gt;1、组建平台研发部，搭建公共技术平台，方便上面各条产品线开发。&lt;/p&gt;
&lt;p&gt;2、通过技术平台、通过高一层的职权，管理和协调各个产品线组。现在每个产品线都应该有合格的研发Leader和高级程序员了。&lt;/p&gt;
&lt;h2 id=&quot;四、首席架构师&quot;&gt;&lt;a href=&quot;#四、首席架构师&quot; class=&quot;headerlink&quot; title=&quot;四、首席架构师&quot;&gt;&lt;/a&gt;四、首席架构师&lt;/h2&gt;&lt;p&gt;因为你已经有了技术总监了，所以技术平台不错了。技术平台和各条产品线的协调互动，也是技术总监管着。&lt;/p&gt;
&lt;p&gt;因为你已经有了各个产品线的高级程序员，他们在靠个人能力维持着核心功能模块的开发进度和代码质量。&lt;/p&gt;
&lt;p&gt;因为你已经有了研发Leader，所以代码模板研发与推广、最佳实践规范总结与推广，这些事都已经在日常按份内职责开展了。&lt;/p&gt;
&lt;p&gt;那么，啥时候需要首席架构师啊。&lt;/p&gt;
&lt;p&gt;也就是说，需要分离管理族和专业族了。你会发现，这个阶段你的研发团队已经超过100来人了，需要有人专注来做架构规划、设计、日常维护。不能让研发总监和研发Leader又做管理又做技术一股脑都扔给他们，你就等着总结果产出。这是不对的。&lt;/p&gt;
&lt;p&gt;需要从技术总监和研发Leader身上剥离职责了。让技术总监和研发Leader偏项目管理（管理族），把各个模块之间的架构设计工作，独立出一个岗位，就是架构师，来负责。&lt;/p&gt;
&lt;p&gt;每个产品线都有架构师，在技术平台部门也有技术平台的架构师。那么，技术平台和业务产品线的架构互动，就是首席架构师在衔接了。让技术平台架构能够和产品业务系统的架构互相促进和支撑，就是首席架构师的份内之事。&lt;/p&gt;
&lt;p&gt;架构师的职责是：&lt;/p&gt;
&lt;p&gt;1、架构分析：从功能性需求中识别出需要增加的非功能性需求，好满足性能、可扩展、解耦/集成、安全、可运维、高可用、易部署、易更新。并且识别完非功能型需求，还要做技术选型、技术架构风险识别、技术实现工作量评估&lt;/p&gt;
&lt;p&gt;2、架构设计与实现：非功能性模块的架构设计、接口设计、代码实现。所以需要的是有代码实现能力还要有架构思维的工程师，不需要画PPT的工程师&lt;/p&gt;
&lt;p&gt;3、业务架构设计与实现：需要对跨系统的接口进行识别、实现、维护，需要对能写成公共代码类库的进行分析、识别、接口设计、实现、变更维护。&lt;/p&gt;
&lt;p&gt;4、重构：架构师需要经常做Bug分析、非模板性和公共类库代码检查，以发现代码腐烂程度，以发现还有哪些代码没有做很好的架构与精心的代码设计。所以重构是经常性维护发生的，不是攒到某一刻动大手术，甚至推翻重做，那就不叫重构了。&lt;/p&gt;
&lt;h2 id=&quot;五、CTO&quot;&gt;&lt;a href=&quot;#五、CTO&quot; class=&quot;headerlink&quot; title=&quot;五、CTO&quot;&gt;&lt;/a&gt;五、CTO&lt;/h2&gt;&lt;p&gt;你把架构师团队组织建立完成，再往大长，你才需要真正意义上的CTO了。否则你一开始就招真正的CTO，他也不满意，你的期望也不对。现在你的期望也对了，他的能力模型也正好和你的期望职能匹配了，你能给他的和他想要的也正好匹配了。&lt;/p&gt;
&lt;p&gt;有的公司有软件系统产品副总裁，也有软件系统技术副总裁，而且把软件系统技术副总裁叫CTO，软件系统产品副总裁叫产品VP。这就很怪异。&lt;/p&gt;
&lt;p&gt;真正的CTO，是软件产品和技术是统一管理的。&lt;/p&gt;
&lt;p&gt;他做的事情，是商业、产品、技术、管理、团队相平衡的综合统管。&lt;/p&gt;
&lt;p&gt;CTO的职责：&lt;/p&gt;
&lt;p&gt;1、业绩达成：洞察客户需求，捕捉商业机会，规划技术产品，通过技术产品领导业务增长，有清晰的战略规划、主攻方向，带领团队实现组织目标&lt;/p&gt;
&lt;p&gt;2、前沿与平台：到这个研发规模规模级别了，一定要有专门的团队做技术应用创新探索和前沿技术预研。而且要和技术平台团队、应用研发团队形成很好的联动作用，让创新原型试点能够很平滑的融入商业平台再让应用研发线规模化的使用起来。大量的前沿探索都死在了内部，做完试点就停滞了，这就需要CTO做好整体的衔接推动工作。&lt;/p&gt;
&lt;p&gt;3、研发过程管理：站在全局立场来端到端改进业务流程，为业务增长提供方便&lt;/p&gt;
&lt;p&gt;4、组织与人才建设：公司文化和价值观的传承；研发专业族团队梯队建制建设、研发管理族团队梯队建制建设；创建创新激发机制，激发研发人创新向前发展，激发黑马人脱颖而出&lt;/p&gt;
&lt;p&gt;阿朱出品必属精品，阿朱出品必属精品，阿朱出品必属精品，阿朱出品必属精品，唉，现在好文章，都需要重要的话说四遍了&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;注:本文转自微信号erpweixin(简化ERP)，如转载请注明原文地址。原文地址请点 &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5Njk2Mzg0MQ==&amp;amp;mid=2651072525&amp;amp;idx=1&amp;amp;sn
    
    </summary>
    
    
      <category term="杂谈" scheme="http://fengfu.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>JVM 垃圾回收器CMS之各阶段总结</title>
    <link href="http://fengfu.io/2016/06/21/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8CMS%E4%B9%8B%E5%90%84%E9%98%B6%E6%AE%B5%E6%95%B4%E7%90%86/"/>
    <id>http://fengfu.io/2016/06/21/JVM-垃圾回收器CMS之各阶段整理/</id>
    <published>2016-06-21T07:50:22.000Z</published>
    <updated>2016-06-22T07:26:56.848Z</updated>
    
    <content type="html">&lt;p&gt;先贴一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/2657627814/TB2HFD0qVXXXXblXpXXXXXXXXXX_!!2657627814.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-初始标记阶段-CMS-initial-mark&quot;&gt;&lt;a href=&quot;#1-初始标记阶段-CMS-initial-mark&quot; class=&quot;headerlink&quot; title=&quot;1.初始标记阶段(CMS-initial-mark)&quot;&gt;&lt;/a&gt;1.初始标记阶段(CMS-initial-mark)&lt;/h2&gt;&lt;p&gt;  这个阶段的主要任务是找到堆中所有的垃圾回收根节点对象，这个阶段会暂停所有的应用程序线程，即STW(Stop the world)。此阶段会打印1行日志，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[GC [1 CMS-initial-mark: 2905437K(4096000K)] 3134625K(5916480K), 0.2551680 secs] [Times: user=0.26 sys=0.00, real=0.25 secs]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中第一组数据，第一对数据标识老年代实际占用的空间大小和老年代分配的空间大小，第二对数据标识整个堆的实际使用情况和分配的堆的空间。&lt;br&gt;细心的人可能发现了CMS-initial-mark前面的数字“1”，这个标志代表了STW，在后面的“重新标记”阶段，你也会发现这个标志。这正好与上面图中说明的阶段是对应的。&lt;/p&gt;
&lt;h2 id=&quot;2-标记阶段-CMS-concurrent-mark&quot;&gt;&lt;a href=&quot;#2-标记阶段-CMS-concurrent-mark&quot; class=&quot;headerlink&quot; title=&quot;2.标记阶段(CMS-concurrent-mark)&quot;&gt;&lt;/a&gt;2.标记阶段(CMS-concurrent-mark)&lt;/h2&gt;&lt;p&gt;  这个阶段是和应用线程并发执行的，所谓并发收集器指的就是这个，主要作用是标记可达的对象。由于只是进行标记，所以不会对堆的占用产生实质的改变。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2016-06-21T16:38:53.911+0800: 367848.849: [CMS-concurrent-mark-start]
2016-06-21T16:38:57.241+0800: 367852.178: [CMS-concurrent-mark: 2.787/3.329 secs] [Times: user=12.12 sys=0.64, real=3.33 secs]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个阶段会打印2行日志，第一行CMS-concurrent-mark-start标识标记阶段开始。第二行中的“2.787/3.329 secs”表示标记阶段的耗时。后面的“user=12.12”表示占用的cpu时间(此JVM运行的服务器CPU为4核)。&lt;/p&gt;
&lt;h2 id=&quot;3-预清理阶段-CMS-concurrent-preclean&quot;&gt;&lt;a href=&quot;#3-预清理阶段-CMS-concurrent-preclean&quot; class=&quot;headerlink&quot; title=&quot;3.预清理阶段(CMS-concurrent-preclean)&quot;&gt;&lt;/a&gt;3.预清理阶段(CMS-concurrent-preclean)&lt;/h2&gt;&lt;p&gt;  在之前的标记阶段，标记和应用线程是并发执行的，因此有些对象的状态在标记后会发生改变。这个阶段只要是发现从新生代晋升的对象、新分配到老年代的对象以及在标记阶段被修改了的对象。&lt;br&gt;  这个阶段也会打印2行日志，跟标记阶段类似。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2016-06-21T16:38:57.241+0800: 367852.178: [CMS-concurrent-preclean-start]&amp;#10;2016-06-21T16:38:57.718+0800: 367852.655: [CMS-concurrent-preclean: 0.342/0.477 secs] [Times: user=1.79 sys=0.10, real=0.48 secs]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;4-重新标记阶段&quot;&gt;&lt;a href=&quot;#4-重新标记阶段&quot; class=&quot;headerlink&quot; title=&quot;4.重新标记阶段&quot;&gt;&lt;/a&gt;4.重新标记阶段&lt;/h2&gt;&lt;p&gt;  可中断预清理阶段是在JDK1.5中加入的。这个阶段是CMS中比较复杂的一个阶段，因为在这个阶段，JVM会执行很多操作。&lt;br&gt;  首先是CMS-concurrent-abortable-preclean，可中断的预清理。我们可能要问，既然再上一个阶段已经执行了预清理了，为什么还要再做一次？我们知道，CMS是以获取最短停顿时间为目的的GC，所以简单说进行可中断预清理的目的就是希望尽量缩短停顿的时间。&lt;br&gt;  可中断预清理涉及几个参数：&lt;br&gt;  -XX:CMSMaxAbortablePrecleanTime：当abortable-preclean阶段执行达到这个时间时才会结束&lt;br&gt;  -XX:CMSScheduleRemarkEdenSizeThreshold（默认2m）：控制abortable-preclean阶段什么时候开始执行，即当eden使用达到此值时，才会开始abortable-preclean阶段&lt;br&gt;  -XX:CMSScheduleRemarkEdenPenetratio（默认50%）：控制abortable-preclean阶段什么时候结束执行&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2016-06-21T16:38:57.718+0800: 367852.656: [CMS-concurrent-abortable-preclean-start]&amp;#10;2016-06-21T16:38:58.801+0800: 367853.738: [CMS-concurrent-abortable-preclean: 0.920/1.083 secs] [Times: user=4.06 sys=0.20, real=1.08 secs]&amp;#10;2016-06-21T16:38:58.808+0800: 367853.746: [GC[YG occupancy: 777901 K (1820480 K)]367853.746: [Rescan (parallel) , 0.1361120 secs]367853.882: [weak refs processing, 0.0005370 secs]367853.883: [scrub string table, 0.0044130 secs] [1 CMS-remark: 3034451K(4096000K)] 3812352K(5916480K), 0.1412750 secs] [Times: user=0.54 sys=0.00, real=0.14 secs]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  其次，是Rescan操作，此阶段暂停应用线程，对对象进行重新扫描并标记。通过上面的日志我们可以看到，在CMS-remark的时候有一次STW。另外，这个过程还会打印出弱引用处理、类卸载等过程的耗时。&lt;/p&gt;
&lt;h2 id=&quot;5-清除阶段-CMS-concurrent-sweep&quot;&gt;&lt;a href=&quot;#5-清除阶段-CMS-concurrent-sweep&quot; class=&quot;headerlink&quot; title=&quot;5.清除阶段(CMS-concurrent-sweep)&quot;&gt;&lt;/a&gt;5.清除阶段(CMS-concurrent-sweep)&lt;/h2&gt;&lt;p&gt;  这个阶段开始进行垃圾的清理工作，此时应用线程被重新激活，回收线程与应用线程并发运行，那些无效的对象被清理掉。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2016-06-21T16:38:58.950+0800: 367853.888: [CMS-concurrent-sweep-start]&amp;#10;2016-06-21T16:39:05.850+0800: 367860.788: [CMS-concurrent-sweep: 5.656/6.900 secs] [Times: user=25.88 sys=1.28, real=6.90 secs]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;6-初始标记阶段-CMS-concurrent-reset&quot;&gt;&lt;a href=&quot;#6-初始标记阶段-CMS-concurrent-reset&quot; class=&quot;headerlink&quot; title=&quot;6.初始标记阶段(CMS-concurrent-reset)&quot;&gt;&lt;/a&gt;6.初始标记阶段(CMS-concurrent-reset)&lt;/h2&gt;&lt;p&gt;  这是CMS一个回收周期的最后一个阶段，在这个阶段，CMS会清除内部状态，为下次回收做准备。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2016-06-21T16:39:05.850+0800: 367860.788: [CMS-concurrent-reset-start]&amp;#10;2016-06-21T16:39:05.860+0800: 367860.798: [CMS-concurrent-reset: 0.010/0.010 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  至此，一个CMS周期结束。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;先贴一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/2657627814/TB2HFD0qVXXXXblXpXXXXXXXXXX_!!2657627814.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1
    
    </summary>
    
    
      <category term="Java" scheme="http://fengfu.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>性能调优工具-Java Mission Control</title>
    <link href="http://fengfu.io/2016/05/20/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7-Java-Mission-Control/"/>
    <id>http://fengfu.io/2016/05/20/性能调优工具-Java-Mission-Control/</id>
    <published>2016-05-20T06:59:20.000Z</published>
    <updated>2016-05-20T11:13:12.941Z</updated>
    
    <content type="html">&lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1.引言&quot;&gt;&lt;/a&gt;1.引言&lt;/h2&gt;&lt;p&gt;最近1年多的时间，因为需要排查线上应用出现的性能问题，会借助一些工具如JProfiler、Yourkit，但是这些工具都具有商业性质，使用时难免受到限制。后来发现Oracle Jdk(version&amp;gt;=7u40)中自带了一个Java Mission Control(以下简称JMC)的应用，也可以实现JVM的监控。&lt;/p&gt;
&lt;p&gt;另外，与JProfiler等使用JVMPI/JVMTI方式实现的工具不同，JMC使用了JVM内部特定的基于事件的接口，几乎不会给应用造成额外的压力（默认设置下，对性能影响小于1%），因此可以用在负载很高的生产环境中。&lt;/p&gt;
&lt;p&gt;本文就来简单介绍一下使用JMC来监测JVM性能。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：需要下载Oracle Jdk 7u40以后的版本，OpenJdk无效，切记！&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-目标JVM配置&quot;&gt;&lt;a href=&quot;#2-目标JVM配置&quot; class=&quot;headerlink&quot; title=&quot;2.目标JVM配置&quot;&gt;&lt;/a&gt;2.目标JVM配置&lt;/h2&gt;&lt;p&gt;在被监控的JVM（目标JVM）上需要开启以下Java Options才能对其进行监控，对于Tomcat来说，在JAVA_OPTS或CATALINA_OPTS中加入以下代码即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-Dcom.sun.management.jmxremote.authenticate=false
-Dcom.sun.management.jmxremote.ssl=false
-Djava.rmi.server.hostname=192.168.32.11
-Dcom.sun.management.jmxremote.port=7777
-Dcom.sun.management.jmxremote
-XX:+UnlockCommercialFeatures
-XX:+FlightRecorder
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;java.rmi.server.hostname：如果要允许其它机器监控该程序，必须设定，否则就只能在本机监控该程序。&lt;br&gt;com.sun.management.jmxremote：启用JMX远程监控。&lt;br&gt;com.sun.management.jmxremote.port：JMX远程监控的端口。&lt;br&gt;com.sun.management.jmxremote.ssl：将此配置设置为 true 时，将使用服务器证书通过 SSL 来保护通信。&lt;br&gt;com.sun.management.jmxremote.authenticate：是否开启权限控制，如果设置为true，需要指定两个文件：jmxremote.password和jmxremote.access，password文件主要是配置用户名和密码，access主要是配置权限（可读或者读写）。&lt;br&gt;在Tomcat的bin目录下增加下面两个文件：jmxremote.password和jmxremote.access，格式如下：&lt;/p&gt;
&lt;p&gt;jmxremote.access：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;admin readwrite
monitor readonly
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;表示admin有操作权限（比如调用GC等操作），monitor只有查看权限，不能进行任何操作。&lt;br&gt;jmxremote.password：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;admin test
monitor test    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;表示有两个用户，admin和monitor，密码分别是test和test。&lt;/p&gt;
&lt;p&gt;-XX:+UnlockCommercialFeatures：开启商业特性，默认这个选项是关闭的。&lt;br&gt;-XX:+FlightRecorder：开启飞行记录器。&lt;/p&gt;
&lt;p&gt;上述参数配置完毕，重新启动tomcat即可。&lt;/p&gt;
&lt;h2 id=&quot;3-连接远程JVM&quot;&gt;&lt;a href=&quot;#3-连接远程JVM&quot; class=&quot;headerlink&quot; title=&quot;3.连接远程JVM&quot;&gt;&lt;/a&gt;3.连接远程JVM&lt;/h2&gt;&lt;p&gt;双击本地%JDK_HOME%\bin\jmc.exe，点击左侧“创建新定制JVM连接”图标， &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/2657627814/TB2L_MapXXXXXaGXFXXXXXXXXXX_!!2657627814.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/2657627814/TB2h8gqpXXXXXbUXXXXXXXXXXXX_!!2657627814.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在弹出的窗口中输入远程JVM的IP地址和端口号：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i2/2657627814/TB29LQKpXXXXXX3XXXXXXXXXXXX_!!2657627814.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择“启动JMX控制台”，点击“完成”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/2657627814/TB2hE_PpXXXXXcRXXXXXXXXXXXX_!!2657627814.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;进入JMC主界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i4/2657627814/TB2mAEGpXXXXXaHXXXXXXXXXXXX_!!2657627814.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在左侧飞行记录器的菜单上点击右键，选择“启动飞行记录”，进入到启动飞行记录的界面，在此界面设置飞行记录的文件路径、记录时长(固定时长或固定间隔)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/2657627814/TB2xSsHpXXXXXafXXXXXXXXXXXX_!!2657627814.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置监控的事件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i4/2657627814/TB2TJcEpXXXXXaKXXXXXXXXXXXX_!!2657627814.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在此界面可以设置监控的详细设置，并点击“完成”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i2/2657627814/TB2DiMkpXXXXXcsXpXXXXXXXXXX_!!2657627814.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在你可以愉快地使用JFR的强大功能了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1.引言&quot;&gt;&lt;/a&gt;1.引言&lt;/h2&gt;&lt;p&gt;最近1年多的时间，因为需要排查线上应用出现的性能问题，会借助一些工具如JProfiler、Yourkit，但是这些工具都具有
    
    </summary>
    
    
      <category term="Java" scheme="http://fengfu.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Instrumentation研究之动态植入</title>
    <link href="http://fengfu.io/2016/04/25/Java-Instrumentation%E7%A0%94%E7%A9%B6-2/"/>
    <id>http://fengfu.io/2016/04/25/Java-Instrumentation研究-2/</id>
    <published>2016-04-25T02:20:43.000Z</published>
    <updated>2016-05-20T06:54:50.378Z</updated>
    
    <content type="html">&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h2&gt;&lt;p&gt;前一篇文章我们提到：在Java SE5中，Instrument要求在运行前利用命令行参数或者系统参数来设置代理类，在实际的运行之中，虚拟机在初始化之时（在绝大多数的 Java 类库被载入之前），instrumentation的设置已经启动，并在虚拟机中设置了回调函数，检测特定类的加载情况，并完成实际工作。也就是说，在Java SE5中，我们只能使用premain的方式实现Instrumentation。但是在实际的很多的情况下，我们没有办法在虚拟机启动之时就为其设定代理，这样实际上限制了instrument的应用。而Java SE6的新特性改变了这种情况，通过agentmain和Java Tool API中的attach方式，我们可以很方便地在运行过程中动态地设置加载代理类，以达到instrumentation的目的。本文就是对Java动态Instrumentation的实现进行研究。&lt;/p&gt;
&lt;h2 id=&quot;2-关于agentmain&quot;&gt;&lt;a href=&quot;#2-关于agentmain&quot; class=&quot;headerlink&quot; title=&quot;2.关于agentmain&quot;&gt;&lt;/a&gt;2.关于agentmain&lt;/h2&gt;&lt;p&gt;在Java SE6的Instrumentation 当中，有一个跟 premain“并驾齐驱”的“agentmain”方法，可以在main函数开始运行之后再运行。&lt;br&gt;跟premain函数一样， 开发者可以编写一个含有“agentmain”函数的Java类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void agentmain(String agentArgs, Instrumentation inst);          [1] 
public static void agentmain(String agentArgs);              [2]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[1]的优先级比[2]高，将会被优先执行。&lt;/p&gt;
&lt;p&gt;跟前文提到的premain函数一样，我们可以在agentmain方法中对类进行各种操作。其中的agentArgs和Inst的用法跟premain相同。&lt;br&gt;与“Premain-Class”类似，我们必须在manifest文件里面设置“Agent-Class”来指定包含agentmain函数的类。&lt;br&gt;可是，跟premain不同的是，agentmain需要在main函数开始运行后才启动，这样的时机应该如何确定呢，这样的功能又如何实现呢？&lt;br&gt;在 Java SE6 文档当中，我们也许无法在java.lang.instrument包相关的文档部分看到明确的介绍，更加无法看到具体的应用agnetmain的例子。不过，在 Java SE6的新特性里面，有一个不太起眼的地方，揭示了agentmain的用法。这就是Java SE6当中提供的Attach API。&lt;/p&gt;
&lt;h2 id=&quot;3-关于Attach-API&quot;&gt;&lt;a href=&quot;#3-关于Attach-API&quot; class=&quot;headerlink&quot; title=&quot;3.关于Attach API&quot;&gt;&lt;/a&gt;3.关于Attach API&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/jdk/api/attach/spec/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Attach API&lt;/a&gt;不是Java的标准API，而是Sun公司提供的一套扩展API，用来向目标JVM“附着”（Attach）代理工具程序的。有了它，我们可以方便地监控一个JVM，运行一个外加的代理程序。&lt;br&gt;Attach API很简单，只有2个主要的类，都在com.sun.tools.attach包里面：VirtualMachine代表一个Java虚拟机，也就是程序需要监控的目标虚拟机，提供了JVM枚举，Attach动作和Detach动作（Attach 动作的相反行为，从JVM 上面解除一个代理）等等 ; VirtualMachineDescriptor则是一个描述虚拟机的容器类，配合VirtualMachine类完成各种功能。&lt;/p&gt;
&lt;h2 id=&quot;4-agentmain实现步骤&quot;&gt;&lt;a href=&quot;#4-agentmain实现步骤&quot; class=&quot;headerlink&quot; title=&quot;4.agentmain实现步骤&quot;&gt;&lt;/a&gt;4.agentmain实现步骤&lt;/h2&gt;&lt;p&gt;与Permain类似，agentmain方式同样需要提供一个agent jar，并且这个jar需要满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在manifest中指定Agent-Class属性，值为代理类全路径；&lt;/li&gt;
&lt;li&gt;代理类需要提供public static void agentmain(String args, Instrumentation inst)或public static void agentmain(String args)方法。并且再二者同时存在时以前者优先。args和inst和premain中的一致。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Attach API中的VirtualMachine代表一个运行中的VM，其提供了loadAgent()方法，可以在运行时动态加载一个代理jar，这样就可以实现类似premain的效果了。&lt;/p&gt;
&lt;h2 id=&quot;5-agentmain实例&quot;&gt;&lt;a href=&quot;#5-agentmain实例&quot; class=&quot;headerlink&quot; title=&quot;5.agentmain实例&quot;&gt;&lt;/a&gt;5.agentmain实例&lt;/h2&gt;&lt;p&gt;与上文一样，我们要通过Java Instrumentation实现对某个类中所有方法执行时间的统计，只不过不同的是：这次我们采用动态Instrumentation的方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写一个简单的测试类Test，以便于后面我们通过动态代理实现方法计时功能；&lt;/li&gt;
&lt;li&gt;编写Agent实现类SampleTransformer，实现ClassFileTransformer接口。代码同上篇文章一样，这里不再赘述。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编写Agent入口类DynamicAgent，实现agentmain方法：&lt;/p&gt;
&lt;p&gt; public static void agentmain(String args, Instrumentation inst)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编写Agent加载类AgentLoader，以通过Attach API中的VirtualMachine来动态加载我们编写的代理jar；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;编写一个测试入口类SampleApp，能够长时间驻留，便于我们测试动态植入功能；本例中我们通过键盘数据接收用户的输入数据。只要用户输入不为“bye”，那么就会执行Test类的test()方法；在系统刚刚启动的时候，我们没有利用动态植入实现对test()方法的计时；当执行动态植入后，再执行test()方法，我们就能看到屏幕除了输出原test()方法输出的“hello world”之外，还额外输出了test()方法的运行计时。这就能够证明植入代码生效了；&lt;/li&gt;
&lt;li&gt;设置MANIFEST.MF文件，指定Agent-Class、Can-Retransform-Classes、Can-Redefine-Classes等属性。在本实例所付的代码中，是通过maven配置的，具体请参考附件中的代码；&lt;/li&gt;
&lt;li&gt;打包得到DynamicAgent-1.0-SNAPSHOT.jar；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行SampleApp，启动应用：&lt;/p&gt;
&lt;p&gt; java -cp /home/fengfu/DynamicAgent/target/DynamicAgent-1.0-SNAPSHOT.jar;/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar io.fengfu.learning.instrument.SampleApp&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在交互窗口输入test，我们可以看到系统输出：Hello World!&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;得到SampleApp的进程id，比如1234；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行AgentLoader，启动动态代理：&lt;/p&gt;
&lt;p&gt; java -cp /home/fengfu/DynamicAgent/target/DynamicAgent-1.0-SNAPSHOT.jar;/usr/local/jdk1.7/lib/tools.jar;/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar  io.fengfu.learning.instrument.AgentLoader 1234&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在SampleApp的交互窗口再次输入test，我们可以看到系统输出：Hello World!，同时也输出：Call to method test took 3001 ms.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大功告成，一个简单的动态植入功能就实现了~&lt;br&gt;本实例的代码可以点 &lt;a href=&quot;(http://fengfu.io/attach/DynamicAgent.zip&quot;&gt;这里&lt;/a&gt;) 下载。&lt;/p&gt;
&lt;h2 id=&quot;6-说明&quot;&gt;&lt;a href=&quot;#6-说明&quot; class=&quot;headerlink&quot; title=&quot;6.说明&quot;&gt;&lt;/a&gt;6.说明&lt;/h2&gt;&lt;p&gt;实例虽然简单，但是在代码编写过程中还是遇到了几个坑，贴出来供大家参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果动态植入需要通过javassist去修改某些类，那么需要在MANIFEST.MF中设置Can-Retransform-Classes和Can-Redefine-Classes为true；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要动态修改的类Test不要跟测试入口类SampleApp放在一个类文件中，否则代理启动动态修改Class时会报如下异常：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java.lang.reflect.InvocationTargetException
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
at java.lang.reflect.Method.invoke(Unknown Source)
at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(Unknown Source)
at sun.instrument.InstrumentationImpl.loadClassAndCallAgentmain(Unknown Source)
Caused by: java.lang.UnsupportedOperationException: class redefinition failed: attempted to add a method
at sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
at sun.instrument.InstrumentationImpl.retransformClasses(Unknown Source)
at io.fengfu.learning.instrument.DynamicAgent.agentmain(DynamicAgent.java:14)
... 6 more
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分析原因，是因为SampleApp正在运行中，而JVM是不允许reload一个正在运行时的类的。一旦classloader加载了一个class，在运行时就不能重新加载这个class的另一个版本。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h2&gt;&lt;p&gt;前一篇文章我们提到：在Java SE5中，Instrument要求在运行前利用命令行参数或者系统参数来设置代理类，在实际的运
    
    </summary>
    
    
      <category term="Java" scheme="http://fengfu.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Instrumentation研究之premain</title>
    <link href="http://fengfu.io/2016/04/24/Java-Instrumentation%E7%A0%94%E7%A9%B6-1/"/>
    <id>http://fengfu.io/2016/04/24/Java-Instrumentation研究-1/</id>
    <published>2016-04-24T07:30:14.000Z</published>
    <updated>2016-04-26T10:19:46.770Z</updated>
    
    <content type="html">&lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1.引言&quot;&gt;&lt;/a&gt;1.引言&lt;/h2&gt;&lt;p&gt;作为一个软件工程师，你有没有遇到过以下场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了排查线上问题，非常迫切地想要知道系统中某个方法的运行数据，为此只能临时修改代码，打印日志；&lt;/li&gt;
&lt;li&gt;为了查找系统瓶颈，你需要知道某个方法的耗时，为此你只能在方法头尾处记录时间戳，并打印日志或者记录到监控中；&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了实现上述种种临时需求，你需要修改代码、发布、查看日志。或许，这些场景对于作为码农的你已经习以为常，但是世界是懒人创造的，那有没有一种方式能够避免我们这种重复又无任何积累的劳动呢？答案是有的。&lt;/p&gt;
&lt;p&gt;最近，公司的大神 &lt;a href=&quot;http://www.cnblogs.com/yuyijq/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;余昭辉&lt;/a&gt; 发布了一个新的应用QTracer watch，可以支持通过简单的配置，查看系统运行时的数据。而实现这一点，竟然不用像以前一样在系统中添加一行代码并发布。这种高大上的技术实现立马让我对神的仰慕之情增加了几分。但仰慕归仰慕，对于神作我们还是需要知道其原理的。&lt;/p&gt;
&lt;p&gt;通过了解，清楚了这高大上的技术实现来自于Java的Instrumentation(植入)。&lt;/p&gt;
&lt;h2 id=&quot;2-Java-Instrumentation简介&quot;&gt;&lt;a href=&quot;#2-Java-Instrumentation简介&quot; class=&quot;headerlink&quot; title=&quot;2.Java Instrumentation简介&quot;&gt;&lt;/a&gt;2.Java Instrumentation简介&lt;/h2&gt;&lt;p&gt;Instrumentation是Java SE5的新特性，它把Java的instrument功能从本地代码中解放出来，使之可以用Java代码的方式解决问题。使用Instrumentation，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在JVM上的程序，甚至能够替换和修改某些类的定义。有了这样的功能，我们就可以实现更为灵活的运行时虚拟机监控和Java类操作了，这样的特性实际上提供了一种虚拟机级别支持的AOP实现方式，使得我们无需对原有代码做任何升级和改动，就可以实现某些 AOP 的功能了。&lt;br&gt;在Java SE6里面，instrument包被赋予了更强大的功能：启动后的instrument、本地代码（native code）instrument，以及动态改变classpath等。这些改变意味着Java具有了更强的动态控制、解释能力，使得Java语言变得更加灵活多变。&lt;br&gt;在Java SE6里面，最大的改变是运行时的Instrumentation成为可能。在Java SE5中，Instrument要求在运行前利用命令行参数或者系统参数来设置代理类，在实际的运行之中，虚拟机在初始化之时（在绝大多数的 Java 类库被载入之前），instrumentation的设置已经启动，并在虚拟机中设置了回调函数，检测特定类的加载情况，并完成实际工作。但是在实际的很多的情况下，我们没有办法在虚拟机启动之时就为其设定代理，这样实际上限制了instrument的应用。而Java SE 6的新特性改变了这种情况，通过Java Tool API中的attach方式，我们可以很方便地在运行过程中动态地设置加载代理类，以达到 instrumentation的目的。&lt;br&gt;另外，对native的Instrumentation也是Java SE6的一个崭新的功能，这使以前无法完成的功能–对native接口的instrumentation。我们可以在Java SE6中，通过一个或者一系列的prefix添加而得以完成。&lt;br&gt;最后，Java SE6里的Instrumentation也增加了动态添加classpath的功能。所有这些新的功能，都使得instrument包的功能更加丰富，从而使Java语言本身更加强大。&lt;/p&gt;
&lt;h2 id=&quot;3-Java-Instrumentation原理&quot;&gt;&lt;a href=&quot;#3-Java-Instrumentation原理&quot; class=&quot;headerlink&quot; title=&quot;3.Java Instrumentation原理&quot;&gt;&lt;/a&gt;3.Java Instrumentation原理&lt;/h2&gt;&lt;p&gt;“java.lang.instrument”包的具体实现，依赖于JVMTI。JVMTI（Java Virtual Machine Tool Interface）是一套由 Java虚拟机提供的，为JVM相关的工具提供的本地编程接口集合。JVMTI是从Java SE5开始引入，整合和取代了以前使用的 Java Virtual Machine Profiler Interface (JVMPI) 和 the Java Virtual Machine Debug Interface (JVMDI)，而在Java SE6中，JVMPI和JVMDI已经消失了。JVMTI提供了一套“代理”程序机制，可以支持第三方工具程序以代理的方式连接和访问JVM，并利用JVMTI提供的丰富的编程接口，完成很多跟JVM相关的功能。事实上，java.lang.instrument包的实现，也就是基于这种机制的：在Instrumentation的实现当中，存在一个JVMTI的代理程序，通过调用JVMTI当中Java类相关的函数来完成Java类的动态操作。除开Instrumentation功能外，JVMTI还在虚拟机内存管理，线程控制，方法和变量操作等等方面提供了大量有价值的函数，具体可以参考&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JVMTI官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;4-Java-Instrumentation实现步骤&quot;&gt;&lt;a href=&quot;#4-Java-Instrumentation实现步骤&quot; class=&quot;headerlink&quot; title=&quot;4.Java Instrumentation实现步骤&quot;&gt;&lt;/a&gt;4.Java Instrumentation实现步骤&lt;/h2&gt;&lt;p&gt;在Java SE5时代，Instrument只提供了premain（命令行）一种方式，即在真正的应用程序（包含main方法的程序）main方法启动前启动一个代理程序。而在Java SE6中则包含两种应用Instrumentation的方式：premain（命令行）和agentmain（运行时）。在本文中，我们首先研究premain方式。&lt;br&gt;要实现premain方式，我们要遵循的步骤如下：&lt;br&gt;1）编写Agent实现类，实现ClassFileTransformer接口。ClassFileTransformer中声明了一个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public byte[] transform(
ClassLoader loader, 
String className, 
Class cBR, 
java.security.ProtectionDomain pD, 
byte[] classfileBuffer) throws IllegalClassFormatException
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过这个方法，代理可以得到虚拟机载入的类的字节码（通过 classfileBuffer 参数）。代理的各种功能一般是通过操作这一串字节码得以实现的。&lt;/p&gt;
&lt;p&gt;2）编写Agent入口类，实现premain方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void premain(String agentArgs, Instrumentation inst)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3）打包Agent：将上述步骤1中声明的Java类打包成一个jar文件，并在META-INF/MANIFEST.MF文件中加入“Premain-Class”来指定此Java类（注意此处需要声明全路径）；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Manifest-Version: 1.0
Premain-Class: io.fengfu.learning.instrument.SampleAgent
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最终我们打包得到SampleAgent.jar。&lt;/p&gt;
&lt;p&gt;4）执行命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -javaagent:SampleAgent-1.0-SNAPSHOT.jar -cp /home/fengfu/SampleAgent/SampleAgent-1.0-SNAPSHOT.jar;/home/fengfu/SampleAgent/lib/javassist-3.19.0-GA.jar io.fengfu.learning.instrument.SampleApp
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;java选项中有-javaagent:xx，xx就是你的agent jar，java通过此选项加载agent,由agent来监控classpath下的应用。&lt;br&gt;如果你的Agent类引入别的包，那么需要使用-cp参数指定包的路径，否则在执行java命令时，会报找不到类的错误。&lt;/p&gt;
&lt;h2 id=&quot;5-Java-Instrumentation实例-premain&quot;&gt;&lt;a href=&quot;#5-Java-Instrumentation实例-premain&quot; class=&quot;headerlink&quot; title=&quot;5.Java Instrumentation实例(premain)&quot;&gt;&lt;/a&gt;5.Java Instrumentation实例(premain)&lt;/h2&gt;&lt;p&gt;本实例基于javassist实现了对某个类中所有方法执行时间的统计，具体代码请点击 &lt;a href=&quot;http://fengfu.io/attach/SampleAgent.zip&quot;&gt;这里&lt;/a&gt; 下载。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1.引言&quot;&gt;&lt;/a&gt;1.引言&lt;/h2&gt;&lt;p&gt;作为一个软件工程师，你有没有遇到过以下场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了排查线上问题，非常迫切地想要知道系统中某个方法的
    
    </summary>
    
    
      <category term="Java" scheme="http://fengfu.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈软件工程师的职业发展方向</title>
    <link href="http://fengfu.io/2016/04/11/%E6%B5%85%E8%B0%88%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91/"/>
    <id>http://fengfu.io/2016/04/11/浅谈软件工程师的职业发展方向/</id>
    <published>2016-04-11T09:31:37.000Z</published>
    <updated>2016-04-12T10:47:23.882Z</updated>
    
    <content type="html">&lt;p&gt;今天在跟团队一个工作了2年多的同学做绩效面谈时，该同学问了我一个问题：自己现在比较迷茫，不知道该往哪个方向发展……&lt;/p&gt;
&lt;p&gt;相信这是很多有一定工作经验的同学都会有的困惑，很多人每隔几年(一般是3年)就会遇到瓶颈，也会面临着新的选择。这时候，他们都会看不清方向，感到迷茫。如果这个问题得不到解决，那么他的成长就会受到制约，甚至停滞不前。在工作中的表现就是比较沉默甚至消极，严重者则选择离职，寻求新的方向（其实是开始新的轮回……）。此时，如果有人能够根据他们的特点帮助他们选择适合他们的方向，或者给出建议，那么相信他会走出迷雾，豁然开朗，这样团队的稳定性会得到加强。&lt;/p&gt;
&lt;p&gt;所以今天简单总结一下软件工程师的职业发展方向，以帮助迷茫的同学早日走出混沌状态。&lt;/p&gt;
&lt;h2 id=&quot;1-技术专家&quot;&gt;&lt;a href=&quot;#1-技术专家&quot; class=&quot;headerlink&quot; title=&quot;1.技术专家&quot;&gt;&lt;/a&gt;1.技术专家&lt;/h2&gt;&lt;p&gt;技术专家这个方向对于软件工程师来讲应该是比较容易实现的一个目标，因为这是外在因素影响最小的一个，我们所需要的就是专注和毅力。&lt;br&gt;在技术发展百花齐放、日新月异的今天，我们工作中可能会用到很多的技术，但是很多人只是把自己局限在“用”的层面上，并没有继续去深入研究和改进，更有人只是“知其然不知其所以然”，这样就失去了进一步积累的机会。&lt;br&gt;作家格拉德威尔在《异数》一书中指出：”人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。1万小时的锤炼是任何人从平凡变成超凡的必要条件”。我们做个简单的算术题：如果每天工作八个小时，一周工作五天，那么成为一个领域的专家至少需要五年。&lt;br&gt;5年，看起来貌似时间很长，但是试想一下，如果我们借着工作的机会深入研究某个技术栈的原理，并在此基础上加以实践，那么我们只要不断地积累，最终是有机会成为这方面的专家的。在我身边就有这样的例子：以前我的团队中有个非常内向的小伙子（就叫他HX吧），刚来公司的时候各方面资质很平庸，平时寡言少语，也缺乏自信。在做一个项目时，我们采用了hbase作为系统存储。因为之前对hbase缺乏了解，所以项目过程中踩了很多的坑，于是HX同学就不停地填坑，甚至工作之外的时间都贡献了出去。2年过去了，虽然我们的项目早已结束，但是HX却从未放弃对hbase的研究，相反他经常翻看hbase的代码，并经常去hbase社区查看别人的讨论。现在HX已经成为了公司中对hbase最熟悉的人，并开始往hbase社区提交代码。在公司中他也已经小有名气，其他事业部的开发遇到hbase相关的问题也会来找他了解。虽然他现在还算不是hbase的专家，但是很明显，他现在已经度过了最难熬的时间，已经进入了收获期，只要他继续坚持下去，相信会取得更大的成绩。&lt;br&gt;这是身边真真切切的例子，虽然每个人的情况不完全一样，但是很多时候，我们是可以从别人的故事中找到自己的期待。&lt;/p&gt;
&lt;h2 id=&quot;2-业务专家&quot;&gt;&lt;a href=&quot;#2-业务专家&quot; class=&quot;headerlink&quot; title=&quot;2.业务专家&quot;&gt;&lt;/a&gt;2.业务专家&lt;/h2&gt;&lt;p&gt;业务专家这个方向也比较好理解，我们长时间接触某一块业务，耳濡目染，久而久之也就会对这个业务比较熟悉甚至精通了。这个方向，其实我们仔细观察一下，身边也能找出很多的例子。我有一个认识了十几年的前同事，他从毕业开始就在做银行的信贷系统，现在还在做。目前他自己拥有一个几十人的开发团队，在国家开发银行驻场帮国开行做信贷系统，小日子过得很滋润。再回想自己曾经做过银行的外汇系统，最开始跟着中国银行学习业务，边学习边做系统，2年之后系统成熟了，业务熟悉了，就开始给建行做系统。但建行做外汇业务起步比较晚，于是我一个开发给银行的人讲业务，那种成就感你自己可以设想一下。&lt;br&gt;当然，这个方向也需要保持专注，跟上面讲的技术专家是一样的，你需要不断的积累。现在很多同学总是不停地在各个公司跳来跳去，薪水是涨上去了，但是在行业领域却没有太多的积累，从个人发展来讲，这迟早会成为一个限制因素。&lt;/p&gt;
&lt;h2 id=&quot;3-技术经理&quot;&gt;&lt;a href=&quot;#3-技术经理&quot; class=&quot;headerlink&quot; title=&quot;3.技术经理&quot;&gt;&lt;/a&gt;3.技术经理&lt;/h2&gt;&lt;p&gt;我们身边有这么一类人，各方面能力都比较均衡，比如技术、沟通能力、组织能力。这样的人经过一段时间的锻炼后，可能会被任命为小组长，承担一些管理性的工作。再经过一段时间的历练，有些人可能不太适合这个方向，于是转向其他方向，剩下的做的还不错的人则继续升级，管理更大的团队，于是就成了技术经理。&lt;br&gt;技术经理的要求不同于前面的2个职位，保持专注就可以；而技术经理的要求就比较广泛，因为你管理的是技术团队，所以技术你不能扔；同时你管的是人，所以人际关系的相关技能你也要提升，比如沟通能力、组织能力，甚至你还要了解心理学、组织行为学等内容。这时候，全方位地充电就成了一个比较好的选择。&lt;/p&gt;
&lt;h2 id=&quot;4-架构师&quot;&gt;&lt;a href=&quot;#4-架构师&quot; class=&quot;headerlink&quot; title=&quot;4.架构师&quot;&gt;&lt;/a&gt;4.架构师&lt;/h2&gt;&lt;p&gt;现在还有个名词叫“T型人才”。T型人才是指按知识结构区分出来的一种新型人才类型。用字母“T”来表示他们的知识结构特点。“—”表示有广博的知识面，“|”表示知识的深度。两者的结合，既有较深的专业知识，又有广博的知识面，这类集深与博于一身的人才。这种人才结构不仅在纵向的专业知识上具有较深的理解能力和独到见解，而且在横向上具备比较广泛的一般性知识修养。&lt;br&gt;我理解，架构师就是属于这种人才。他们经过长时间的技术积累，在某个方向上已经具备了比较深厚的沉淀，同时在技术体系上也得到了逐步的完善，于是成为了上天入地无所不能的架构师。&lt;br&gt;一般来讲，要成为T型人才，最好是先成为那道“|”，再成为那到“——”，这样根基会比较扎实。&lt;br&gt;所以对于要立志成为架构师的同学来说，最好先做一个技术专家，在技术专家的基础上，再扩大知识面，最终成为架构师。&lt;/p&gt;
&lt;h2 id=&quot;5-CTO&quot;&gt;&lt;a href=&quot;#5-CTO&quot; class=&quot;headerlink&quot; title=&quot;5.CTO&quot;&gt;&lt;/a&gt;5.CTO&lt;/h2&gt;&lt;p&gt;CTO我还是不写了，仰望吧……&lt;/p&gt;
&lt;p&gt;喷了这么多，最后简单梳理了各个方向的能力模型，希望抛砖引玉，引发你的思考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/2657627814/TB2r8UGmVXXXXXPXXXXXXXXXXXX_!!2657627814.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天在跟团队一个工作了2年多的同学做绩效面谈时，该同学问了我一个问题：自己现在比较迷茫，不知道该往哪个方向发展……&lt;/p&gt;
&lt;p&gt;相信这是很多有一定工作经验的同学都会有的困惑，很多人每隔几年(一般是3年)就会遇到瓶颈，也会面临着新的选择。这时候，他们都会看不清方向，感到迷茫
    
    </summary>
    
    
      <category term="杂谈" scheme="http://fengfu.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>技术栈选型原则</title>
    <link href="http://fengfu.io/2016/03/22/%E6%8A%80%E6%9C%AF%E6%A0%88%E9%80%89%E5%9E%8B%E5%8E%9F%E5%88%99/"/>
    <id>http://fengfu.io/2016/03/22/技术栈选型原则/</id>
    <published>2016-03-22T06:55:20.000Z</published>
    <updated>2016-04-12T10:42:04.242Z</updated>
    
    <content type="html">&lt;p&gt;未完成&lt;/p&gt;
&lt;p&gt;2个能力&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;满足需求的能力：开源产品满足自身功能、性能的能力(开发效率？运行效率？)；需求，梳理自身的业务、技术需求；&lt;/li&gt;
&lt;li&gt;自身技术团队维护开源产品的能力；学习曲线以及公司内部的技术支持；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3个关注点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;社区成熟度（用户数、bug数）、活跃度（contributors、releases）、技术支持（论坛、文档等）；&lt;/li&gt;
&lt;li&gt;成功案例；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;避免过度炫技&lt;br&gt;不要因为一个人的喜好而舍弃掉整个技术团队，在任何时候这都是非常愚蠢的事情&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;未完成&lt;/p&gt;
&lt;p&gt;2个能力&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;满足需求的能力：开源产品满足自身功能、性能的能力(开发效率？运行效率？)；需求，梳理自身的业务、技术需求；&lt;/li&gt;
&lt;li&gt;自身技术团队维护开源产品的能力；学习曲线以及公司内部的技术支持；&lt;/li&gt;
&lt;/ol&gt;
&lt;
    
    </summary>
    
    
      <category term="架构" scheme="http://fengfu.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JVM触发FullGC的情况总结</title>
    <link href="http://fengfu.io/2016/03/08/JVM%E8%A7%A6%E5%8F%91FullGC%E7%9A%84%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://fengfu.io/2016/03/08/JVM触发FullGC的情况总结/</id>
    <published>2016-03-08T14:53:56.000Z</published>
    <updated>2016-03-11T04:00:03.198Z</updated>
    
    <content type="html">&lt;p&gt;FullGC是Java应用中一个不容忽视的问题，因为FullGC会引起应用停顿，所以它对那些响应时间要求比较高的应用的影响还是非常大的。&lt;br&gt;当然，如果要解决FullGC的问题，我们首先需要知道在什么情况下会引起FullGC，这样才能对症下药，避免FullGC的出现。&lt;/p&gt;
&lt;p&gt;下面的总结是针对于系统自动进行FullGC的情况分析，不包含System.gc操作。&lt;/p&gt;
&lt;h2 id=&quot;1-老年代空间不足&quot;&gt;&lt;a href=&quot;#1-老年代空间不足&quot; class=&quot;headerlink&quot; title=&quot;1. 老年代空间不足&quot;&gt;&lt;/a&gt;1. 老年代空间不足&lt;/h2&gt;&lt;p&gt;JVM中堆空间主要由新生代和老年代组成。新创建的对象大多在新生代中创建，当对象经过几次Minor GC依然存活，才有机会被转入老年代。这时问题就来了，如果此时老年代的空间不足以容纳从新生代转入的对象，那么JVM就会进行FullGC，以清理老年代的空间。如果进行FullGC后老年代依然无法容纳转入对象，那么系统就会抛出：java.lang.OutOfMemoryError: Java heap space的异常，相比大家都比较熟悉了。&lt;/p&gt;
&lt;h2 id=&quot;2-永久代空间不足&quot;&gt;&lt;a href=&quot;#2-永久代空间不足&quot; class=&quot;headerlink&quot; title=&quot;2. 永久代空间不足&quot;&gt;&lt;/a&gt;2. 永久代空间不足&lt;/h2&gt;&lt;p&gt;永久代(Permanent Generation)一般是用来存放类信息、字符串常量的地方，如果我们永久代设置的空间比较小无法容纳足够的类信息时，或者因为频繁热加载类信息，又或者存储了太多的字符串常量，那么系统就会触发FullGC，以清理永久代。如果FullGC之后永久代还无法容纳足够的信息，那么系统就会抛出：java.lang.OutOfMemoryError: PermGen space的异常，眼熟吧:)&lt;/p&gt;
&lt;h2 id=&quot;3-promotion-failed和concurrent-mode-failure&quot;&gt;&lt;a href=&quot;#3-promotion-failed和concurrent-mode-failure&quot; class=&quot;headerlink&quot; title=&quot;3. promotion failed和concurrent mode failure&quot;&gt;&lt;/a&gt;3. promotion failed和concurrent mode failure&lt;/h2&gt;&lt;p&gt;promotion failed是指在进行Minor GC时，新生代中的对象从Eden区往survivor区转移，但是survivor区放不下，只能放入老年代，但是悲催的是老年代也放不下，这时就会出现promotion failed的情况，系统会触发FullGC以清理空间。&lt;/p&gt;
&lt;p&gt;concurrent mode failure是指在进行CMS GC的过程中有对象要放入老年代，但是老年代空间不够引起的。 &lt;/p&gt;
&lt;h2 id=&quot;4-统计得到的Minor-GC晋升到旧生代的平均大小大于旧生代的剩余空间&quot;&gt;&lt;a href=&quot;#4-统计得到的Minor-GC晋升到旧生代的平均大小大于旧生代的剩余空间&quot; class=&quot;headerlink&quot; title=&quot;4. 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间&quot;&gt;&lt;/a&gt;4. 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间&lt;/h2&gt;&lt;p&gt;这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。&lt;br&gt;例如程序第一次触发Minor GC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。&lt;br&gt;当新生代采用PS GC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。&lt;br&gt;除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java -Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。&lt;/p&gt;
&lt;p&gt;明确了FullGC出现的原理，我们就能根据JVM垃圾回收的情况来判断系统到底是因为什么原因出现了FullGC，也就能对症下药，避免FullGC的出现。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;FullGC是Java应用中一个不容忽视的问题，因为FullGC会引起应用停顿，所以它对那些响应时间要求比较高的应用的影响还是非常大的。&lt;br&gt;当然，如果要解决FullGC的问题，我们首先需要知道在什么情况下会引起FullGC，这样才能对症下药，避免FullGC的出现。&lt;/
    
    </summary>
    
    
      <category term="Java" scheme="http://fengfu.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>你若懂我，该有多好</title>
    <link href="http://fengfu.io/2016/02/28/%E4%BD%A0%E8%8B%A5%E6%87%82%E6%88%91%E8%AF%A5%E6%9C%89%E5%A4%9A%E5%A5%BD/"/>
    <id>http://fengfu.io/2016/02/28/你若懂我该有多好/</id>
    <published>2016-02-27T23:38:00.000Z</published>
    <updated>2016-02-27T13:48:38.573Z</updated>
    
    <content type="html">&lt;p&gt;每个人都有一个死角，&lt;br&gt;自己走不出来，&lt;br&gt;别人也闯不进去。&lt;br&gt;我把最深沉的秘密放在那里，&lt;br&gt;你不懂我，我不怪你。&lt;/p&gt;
&lt;p&gt;每个人都有一道伤口，&lt;br&gt;或深或浅，&lt;br&gt;盖上布，&lt;br&gt;以为不存在。&lt;br&gt;我把最殷红的血涂在那里，&lt;br&gt;你不懂我，我不怪你。&lt;/p&gt;
&lt;p&gt;每个人都有一场爱恋，&lt;br&gt;用心，用情，用力，&lt;br&gt;感动也感伤。&lt;br&gt;我把最炙热的心情藏在那里，&lt;br&gt;你不懂我，我不怪你。&lt;/p&gt;
&lt;p&gt;每个人都有一行泪，&lt;br&gt;喝下冰冷的水，&lt;br&gt;酝酿成的热泪。&lt;br&gt;我把最辛酸的委屈汇在那里，&lt;br&gt;你不懂我，我不怪你。&lt;/p&gt;
&lt;p&gt;每个人都有一段告白，&lt;br&gt;忐忑，不安，&lt;br&gt;却包含真心和勇气。&lt;br&gt;我把最抒情的语言用在那里，&lt;br&gt;你不懂我，我不怪你。&lt;/p&gt;
&lt;p&gt;你永远也看不见我最爱你的时候，&lt;br&gt;因为我只有在看不见你的时候，&lt;br&gt;才最爱你。&lt;/p&gt;
&lt;p&gt;同样，你永远也看不见我最寂寞的时候，&lt;br&gt;因为我只有在你看不见我的时候，&lt;br&gt;才最寂寞。&lt;/p&gt;
&lt;p&gt;也许，我太会隐藏自己的悲伤，&lt;br&gt;也许，我太会安慰自己的伤痕。&lt;br&gt;从阴雨走到艳阳，&lt;br&gt;我路过泥泞，路过风。&lt;/p&gt;
&lt;p&gt;一路走来，&lt;br&gt;你若懂我，&lt;br&gt;该有多好。&lt;/p&gt;
&lt;p&gt;(作者：莫言)&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;每个人都有一个死角，&lt;br&gt;自己走不出来，&lt;br&gt;别人也闯不进去。&lt;br&gt;我把最深沉的秘密放在那里，&lt;br&gt;你不懂我，我不怪你。&lt;/p&gt;
&lt;p&gt;每个人都有一道伤口，&lt;br&gt;或深或浅，&lt;br&gt;盖上布，&lt;br&gt;以为不存在。&lt;br&gt;我把最殷红的血涂在那里，&lt;br&gt;你不懂我，我不怪
    
    </summary>
    
    
      <category term="人生" scheme="http://fengfu.io/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>ATPCO项目总结-管理篇</title>
    <link href="http://fengfu.io/2015/12/29/ATPCO%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E7%AE%A1%E7%90%86%E7%AF%87/"/>
    <id>http://fengfu.io/2015/12/29/ATPCO项目总结-管理篇/</id>
    <published>2015-12-29T12:41:09.000Z</published>
    <updated>2016-02-27T13:50:58.409Z</updated>
    
    <content type="html">&lt;p&gt;ATPCO项目从1月初开始投入人力进行研究，4月份进入封闭状态，7月初上线第一版，到现在已经8个月的时间了。在这段时间里，公布运价出票量由最初的10提升到了30%，目前日出票量已经达到了4000+，较好地提升了qunar国际机票的竞争力。&lt;/p&gt;
&lt;p&gt;ATPCO项目经历的这接近1年的时间里，有很多的感触，写出来做个总结吧。今天写的是管理方面。&lt;/p&gt;
&lt;h2 id=&quot;1-反应速度&quot;&gt;&lt;a href=&quot;#1-反应速度&quot; class=&quot;headerlink&quot; title=&quot;1. 反应速度&quot;&gt;&lt;/a&gt;1. 反应速度&lt;/h2&gt;&lt;p&gt;项目启动最初，由于与ATPCO的商务合同没有签订，项目只投入了一个人进行研究，推动缓慢。加之团队对公布运价业务不熟悉，给了其他团队切入的机会，并最终导致了2个团队持续竞争的局面。虽然从公司的角度，一个重要的项目由2个团队做是降低风险的举措，但是由此带来的内部消耗也是比较大的，这也导致了后面的核心员工离职。&lt;br&gt;从这件事情来讲，对于任何事情，都要保持足够的敏感度和反应速度。互联网行业竞争激烈，需要快速反应。qunar内部的狼性文化也要求团队能够快速响应、灵活机动，这样才能更快地响应形势的变化。&lt;/p&gt;
&lt;h2 id=&quot;2-团队组建&quot;&gt;&lt;a href=&quot;#2-团队组建&quot; class=&quot;headerlink&quot; title=&quot;2. 团队组建&quot;&gt;&lt;/a&gt;2. 团队组建&lt;/h2&gt;&lt;p&gt;从团队组建上，有2点做得比较好，1点做得不好。&lt;br&gt;先说说做得好的地方：&lt;br&gt;1)在项目初期就把产品经理、技术拉到一个会议室封闭，这样带来的好处是沟通效率很高，项目有问题的时候大家在屋里吼一嗓子就能很快解决问题。当然弊端是十几个人在一个屋子里面，有的时候3、4组人一起说话的时候，那感觉就跟菜市场一样了。&lt;br&gt;2)投入精兵强将。项目开始封闭时，项目人员短缺，无奈之下，把部门里面6个TL中的4个拉了进来。此举起到了很好的效果，不仅解决了人力的问题，而且每个人都在自己负责的事情上做出了很好的成绩。这也应了那句话：兵不在多，在于精。&lt;br&gt;再说说做得不好的地方：&lt;br&gt;1)添油战术不可取：ATPCO项目专业性很强，新人的学习门槛很高，所以在往团队增加人手的时候，最好一次性给够。添油战术对这个项目最大的弊端就是新人需要花很久去学习（最少1个月时间入门），如果每个新来的人都要经历一个学习过程，那么所带来的成本和消耗就比较大了。&lt;/p&gt;
&lt;h2 id=&quot;3-沟通&quot;&gt;&lt;a href=&quot;#3-沟通&quot; class=&quot;headerlink&quot; title=&quot;3. 沟通&quot;&gt;&lt;/a&gt;3. 沟通&lt;/h2&gt;&lt;p&gt;再来说说沟通，沟通一直是管理工作中非常重要的一环，沟通做不好，工作难以开展不说，也会造成人员流失。&lt;br&gt;1）内部沟通&lt;br&gt;先说说内部沟通。&lt;br&gt;团队中每一个人都是一个独立的个体，具备不同的性格和不同的处事方式，每个人的诉求也是不一样的，所以对待每个人的方式也应该因人而异。但是，无论对谁，首先应该了解他的诉求。每个人来到公司都是有自己的诉求的，比如有的人比较关心技术积累、有的人关心成长空间、有的人关心薪水、有的人关心关系简单……如果不了解每个人的需求，那么可能就无法投其所好，给其所要。久而久之，如果这个人不主动跟你沟通，你又不能及时发现问题，那么久而久之，欲求不满的他可能就会闪人了。&lt;br&gt;2）外部沟通&lt;br&gt;下面的这些话不展开了说，说得太明白没意思。&lt;br&gt;有人的地方就有江湖，&lt;br&gt;有人的地方就有利益，&lt;br&gt;看不明白的就看利益。&lt;/p&gt;
&lt;p&gt;你不可能只靠自己和团队，还需要外围的资源的支持，讲利益互换。你对别人有利，你才有机会，此处省略一万字……&lt;/p&gt;
&lt;p&gt;公司大了，就像一个社会，你会遇到形形色色的人，你喜欢的，你讨厌的；你佩服的，你无视的……无论遇到什么样的人，都应该平和对待。一花一世界，一叶一菩提，每个人都值得尊重。&lt;/p&gt;
&lt;h2 id=&quot;4-用人&quot;&gt;&lt;a href=&quot;#4-用人&quot; class=&quot;headerlink&quot; title=&quot;4. 用人&quot;&gt;&lt;/a&gt;4. 用人&lt;/h2&gt;&lt;p&gt;管理就是把合适的人用在合适的位置上，不合适的人要尽快替换，让合适的人顶上去。&lt;br&gt;这里要说的是招聘，不同的项目，对人的要求是不一样的。针对项目的招聘工作，一定要清楚需要什么样的人，严格按照要求招聘。如果招到的人不合适，不仅浪费时间浪费资源，对项目、对应聘者都会产生不利影响。ATPCO是一个专业性很强的项目，学习门槛很高，对人的学习、理解、沟通能力要求都很高，甚至心理素质。项目组成立半年多以来，项目组成员几进几出。有的人适应不了环境自己离职，有的人则是胜任不了被淘汰，这其实都是损失。&lt;/p&gt;
&lt;h2 id=&quot;5-分工&quot;&gt;&lt;a href=&quot;#5-分工&quot; class=&quot;headerlink&quot; title=&quot;5. 分工&quot;&gt;&lt;/a&gt;5. 分工&lt;/h2&gt;&lt;p&gt;首先是将系统拆分，每个人负责独立的事情。在系统建设初期，可以采用服务化的方式将功能拆分，以加快开发速度。但是到了项目后期，系统稳定后，可以再把服务聚合起来。&lt;/p&gt;
&lt;p&gt;其次是要把合适的人放在合适的位置上。那怎么知道这个人适合这个位置呢？前面说到我们已经做了系统拆分，那么根据拆分后的系统来分析各系统需要什么样的能力？比如航路引擎需要对算法比较熟悉，规则系统需要很强的学习能力和技术功底，搜索引擎需要对分布式和性能优化比较熟悉。明确了各个位置需要的能力后，就可以去找相应的人了。&lt;/p&gt;
&lt;p&gt;第三是要能够做好backup，如果你不希望在关键时刻因为关键人物不在而导致业务受影响，那么就尽量避免出现单点。如果人手短缺万不得已，那么TL可以加强团队代码review，熟悉每个子系统的逻辑，这样能够确保在关键时刻其他人能够顶上，同时也能够帮助团队提升技术能力。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;ATPCO项目从1月初开始投入人力进行研究，4月份进入封闭状态，7月初上线第一版，到现在已经8个月的时间了。在这段时间里，公布运价出票量由最初的10提升到了30%，目前日出票量已经达到了4000+，较好地提升了qunar国际机票的竞争力。&lt;/p&gt;
&lt;p&gt;ATPCO项目经历的
    
    </summary>
    
    
      <category term="杂谈" scheme="http://fengfu.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>ATPCO项目总结-技术篇</title>
    <link href="http://fengfu.io/2015/12/28/ATPCO%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93--%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    <id>http://fengfu.io/2015/12/28/ATPCO项目总结--技术篇/</id>
    <published>2015-12-28T12:41:09.000Z</published>
    <updated>2016-02-27T13:50:52.397Z</updated>
    
    <content type="html">&lt;p&gt;接着上篇写，这一篇从技术方面来总结一下ATPCO项目。&lt;/p&gt;
&lt;h1 id=&quot;1-项目特点&quot;&gt;&lt;a href=&quot;#1-项目特点&quot; class=&quot;headerlink&quot; title=&quot;1.项目特点&quot;&gt;&lt;/a&gt;1.项目特点&lt;/h1&gt;&lt;p&gt;ATPCO是一个业务性非常强的项目，主要体现在以下几点：&lt;/p&gt;
&lt;h2 id=&quot;1）规则复杂&quot;&gt;&lt;a href=&quot;#1）规则复杂&quot; class=&quot;headerlink&quot; title=&quot;1）规则复杂&quot;&gt;&lt;/a&gt;1）规则复杂&lt;/h2&gt;&lt;p&gt;ATPCO提供的数据主要分为：Fares、Rules、Routings三类数据。其中Fare与Rules、Routings存在强关联。Rules中包含了8类Record数据，即Record1-Record8。其中Record3中又划分成35项Category。每一个Category分别表示一类运价规则，如Cat1表示乘客类型的规则，Cat2表示适用航班的规则，Cat3表示淡旺季规则……&lt;/p&gt;
&lt;h2 id=&quot;2）计算量大&quot;&gt;&lt;a href=&quot;#2）计算量大&quot; class=&quot;headerlink&quot; title=&quot;2）计算量大&quot;&gt;&lt;/a&gt;2）计算量大&lt;/h2&gt;&lt;p&gt;ATPCO中公布运价数据有9000万条，Rules数据有1亿多条，每个Fare平均关联20多条Rules数据。Fare不仅需要与Rules、Routings进行匹配，还需要与Av（此AV指航班可用座位，不是那个AV）进行匹配。用户一次搜索可能会引起几十万的计算量，如果在短时间内快速计算出结果？可以肯定的一点是：普通的单机计算是行不通的。&lt;/p&gt;
&lt;h2 id=&quot;3）算法复杂&quot;&gt;&lt;a href=&quot;#3）算法复杂&quot; class=&quot;headerlink&quot; title=&quot;3）算法复杂&quot;&gt;&lt;/a&gt;3）算法复杂&lt;/h2&gt;&lt;p&gt;这里说的算法复杂主要集中在航路规划方面。目前全球有4000多城市，5000多机场。理论上两个机场都是可以到达的。那么我们可以想象从一个城市到另外一个城市的路径图就是这个样子了：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/SweamdD.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;是不是很晕？晕就对了，我们在这个坑里面已经1年了，估计航信、携程的同学更能感同身受吧。&lt;/p&gt;
&lt;h1 id=&quot;2-业务抽象&quot;&gt;&lt;a href=&quot;#2-业务抽象&quot; class=&quot;headerlink&quot; title=&quot;2.业务抽象&quot;&gt;&lt;/a&gt;2.业务抽象&lt;/h1&gt;&lt;p&gt;上面已经提到，ATPCO的规则比较复杂，那么相应的转换到技术层面，其业务抽象也会比较有挑战。好在我们有Carl de Marcken（ITA创始人，后被Google收购）这位大牛，他写的几篇专利文章为我们提供了极大的帮助，在此再度膜拜一下。参考Carl的专利，我们抽象出了Itinerary、Journey、Pricing Unit、Fare Component几个关键模型，并根据这些模型搭建了整个系统的框架和接口。&lt;br&gt;在其他方面的抽象，我们做得其实不太好。比如搜索条件，我们的业务抽象并不能适应所有的场景，比如多程、缺口程。一方面是我们对业务的理解不够深入，另外一方面也是在设计方面，我们做得还不够好。有时间需要补一下DDD(领域驱动设计)的知识并加以实践了。&lt;/p&gt;
&lt;h1 id=&quot;3-技术框架&quot;&gt;&lt;a href=&quot;#3-技术框架&quot; class=&quot;headerlink&quot; title=&quot;3.技术框架&quot;&gt;&lt;/a&gt;3.技术框架&lt;/h1&gt;&lt;h2 id=&quot;空间换时间之殇&quot;&gt;&lt;a href=&quot;#空间换时间之殇&quot; class=&quot;headerlink&quot; title=&quot;空间换时间之殇&quot;&gt;&lt;/a&gt;空间换时间之殇&lt;/h2&gt;&lt;p&gt;从技术框架的层面，应该是这篇总结里面需要长篇叙述的了，因为这个层面踩过的坑还是很多的。&lt;br&gt;在项目初期，考虑到ATPCO涉及的数据量和计算量比较大，我们决定采用空间换时间的方式，即事先把数据组装好，在搜索的时候直接使用事先计算好的数据以减少响应时间。这种方式后来被证明是错误的，因为事先组装数据的方式意味着一旦数据有变化，事先生成的数据就需要重新生成，而在我们对ATPCO规则理解不断深入的情况下，这种情况是非常频繁的。另一方面，如果需要调整计算模型，或者系统有bug，那么所有数据就需要重跑。在这种机制下，整个系统好比一艘航空母舰，庞大、笨重，如果需要转身，我们只能默默地等待……&lt;/p&gt;
&lt;h2 id=&quot;简单为美&quot;&gt;&lt;a href=&quot;#简单为美&quot; class=&quot;headerlink&quot; title=&quot;简单为美&quot;&gt;&lt;/a&gt;简单为美&lt;/h2&gt;&lt;p&gt;因为历史原因，我们在接手ATPCO的同事，还负责维护另外一个比较老的公布运价系统。为了兼容老的系统，我们在收到用户请求后，分别调用老系统、新系统，收到结果后进行合并，并返回给调用端。这样的好处是能够保证新、老系统互不影响，一个系统出问题的时候，另外一个系统依然能够提供服务。但是这样的设计也有弊端，因为增加了请求分发、数据合并的环节，中间环节变多，势必导致复杂性升高，同时效率降低，势必也会导致响应时间变长。&lt;/p&gt;
&lt;p&gt;很多时候，简单跟高效是成正比的。就像AK47一样，因为设计简单，其结果就是很少出故障，而且维护简单。比如在越战时期，很多美军士兵宁可使用捡到的AK47步枪，也不愿使用自己的M16，因为M16结构复杂而且容易卡壳，在战场上枪支卡壳那可是丢性命的事情……&lt;/p&gt;
&lt;p&gt;由此引申出来的问题就是，不管是做系统架构设计、还是模块设计，都应该遵循简单为美的原则。只有简单，系统才容易理解，才容易维护，才会高效运转。所以当我们头脑中有方案的时候，要多问问自己，这是否已经是最简单高效的方案了。&lt;/p&gt;
&lt;h2 id=&quot;优雅的服务化&quot;&gt;&lt;a href=&quot;#优雅的服务化&quot; class=&quot;headerlink&quot; title=&quot;优雅的服务化&quot;&gt;&lt;/a&gt;优雅的服务化&lt;/h2&gt;&lt;p&gt;在构建一个复杂系统的时候，如果系统内部功能彼此独立，那么可以考虑采用服务化的方式：即各子系统之间协商好服务接口，彼此通过服务的方式进行调用。这样的好处是各系统之间互相独立，互不影响。这样能够提高系统自身的扩展性、可维护性，并降低系统间的耦合性。ATPCO系统按照功能特点，划分成了Processor、Planner、Searcher、Engine四个子系统，系统与系统之间通过dubbo的方式进行调用。这种方式使得开发人员只关注自己的业务逻辑实现即可，因此能够提升自身的开发效率。当然这种方式的弊端就是服务之间调用时的沟通、联调、排错成本相对较高，但是相比因此带来的整体效率提升，这点成本还是可以接受的。&lt;/p&gt;
&lt;p&gt;目前在互联网行业，服务化的理念已经深入人心，包括现在逐渐流行的微服务。在此借鉴著名SOA专家Thomas Erl的归纳的服务设计原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标准化的服务契约 Standardized service contract&lt;/li&gt;
&lt;li&gt;服务的松耦合 Service loose coupling&lt;/li&gt;
&lt;li&gt;服务的抽象 Service abstraction&lt;/li&gt;
&lt;li&gt;服务的可重用性 Service reusability&lt;/li&gt;
&lt;li&gt;服务的自治性 Service autonomy&lt;/li&gt;
&lt;li&gt;服务的无状态性 Service statelessness&lt;/li&gt;
&lt;li&gt;服务的可发现性 Service discoverability&lt;/li&gt;
&lt;li&gt;服务的可组合性 Service composability&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然如果如果一个系统中有很多同质化的服务或子系统，那么在系统稳定后，可以考虑将这些服务合并，以降低维护成本。我曾经听一个同事讲过他维护的一个与外部航司交互的接口群，每个接口都是一个子系统，一共有20多个子系统。这种系统维护的时候就比较麻烦，因为某些业务策略的修改可能要修改所有的子系统，这种情况下就可以考虑将服务合并，以降低维护的成本。&lt;/p&gt;
&lt;h2 id=&quot;分布式的挑战&quot;&gt;&lt;a href=&quot;#分布式的挑战&quot; class=&quot;headerlink&quot; title=&quot;分布式的挑战&quot;&gt;&lt;/a&gt;分布式的挑战&lt;/h2&gt;&lt;p&gt;ATPCO系统是一个计算密集型的系统，一个用户请求可能会产生几十万次的计算。在这种情况下，单机的计算能力将会成为整个系统的瓶颈，因此必须采用分布式计算的方式将巨大的计算量拆分到不同的机器上进行处理，最终将结果合并。这里所说的分布式计算有2种方式：一种是采用MapReduce的方式，即将数据分发到不同的机器上进行处理；另外一种方式就是RDD(Resilient Distributed Dataset)的方式，即将算法分发到不同的机器上，由各自己自行读取数据进行处理。&lt;/p&gt;
&lt;p&gt;在ATPCO系统中，我们计划采用第二种方式实现分布式计算。之所以说计划，是因为目前只是制定了方案，但并没有投入应用，相信这不会太久。&lt;/p&gt;
&lt;p&gt;分布式的另外一个应用方向就是对于ATPCO文件的处理。ATPCO每个小时都会给我们推送新的数据，如果我们的系统有问题的时候，很有可能需要从最初的文件重新处理。如果堆积了几个月的文件需要重跑，那么这将是一个灾难。于是我们采用了分布式处理的方式，即由多台机器按发布航司分别处理数据，这样系统的处理能力可以成倍增加，比如我用10台机器重新处理数据，那么其速度将是以前单机处理时的10倍。这样的话，我们就再也不用担心重跑数据了，O(∩_∩)O哈哈~&lt;/p&gt;
&lt;h2 id=&quot;4-技术管理&quot;&gt;&lt;a href=&quot;#4-技术管理&quot; class=&quot;headerlink&quot; title=&quot;4.技术管理&quot;&gt;&lt;/a&gt;4.技术管理&lt;/h2&gt;&lt;p&gt;技术管理这个事情可以新开一篇blog来总结了，在此只说关键的几点吧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;招聘，人才是最重要的，创意人才(来自谷歌的《重新定义公司》一书)更重要！&lt;/li&gt;
&lt;li&gt;技术路线/框架制定，并根据反馈适时调整&lt;/li&gt;
&lt;li&gt;参与关键技术问题的攻克&lt;/li&gt;
&lt;li&gt;代码review，这一点很重要，但是也很容易忽略&lt;/li&gt;
&lt;li&gt;团队激励，将团队捏合成一个整体，团队协同，群策群力才能成功&lt;/li&gt;
&lt;li&gt;技术创新，科技是第一生产力&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;接着上篇写，这一篇从技术方面来总结一下ATPCO项目。&lt;/p&gt;
&lt;h1 id=&quot;1-项目特点&quot;&gt;&lt;a href=&quot;#1-项目特点&quot; class=&quot;headerlink&quot; title=&quot;1.项目特点&quot;&gt;&lt;/a&gt;1.项目特点&lt;/h1&gt;&lt;p&gt;ATPCO是一个业务性非常强的项目，主
    
    </summary>
    
    
      <category term="杂谈" scheme="http://fengfu.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>【转】Java 编程中关于异常处理的 10 个最佳实践</title>
    <link href="http://fengfu.io/2015/04/02/Java-%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84-10-%E4%B8%AA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://fengfu.io/2015/04/02/Java-编程中关于异常处理的-10-个最佳实践/</id>
    <published>2015-04-02T06:39:39.000Z</published>
    <updated>2016-03-22T06:55:44.816Z</updated>
    
    <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://javarevisited.blogspot.in/2013/03/0-exception-handling-best-practices-in-Java-Programming.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;10 Exception handling Best Practices in Java Programming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;异常处理在编写健壮的Java应用的过程中，扮演着一个重要的角色。它并不是应用的功能需求，且需要优雅的处理任何错误情况，例如资源不可用，错误的输入，null输入等等。Java提供几个异常处理功能，并通过try, catch 和  finally关键字内嵌在语言的本身。Java编程语言同样允许创建新的异常和使用  throw 和 throws 抛出该异常。在实践中，异常处理不单单是知道语法这么简单。编写健壮的代码是更像是一门艺术，在本文中，将讨论Java异常处理最佳实践。这些 Java最佳实践遵循标准的JDK库，和几个处理错误和异常的开源代码。这还是一个提供给java程序员编写健壮代码的便利手册。&lt;/p&gt;
&lt;p&gt;这里是我收集的10个Java编程中进行异常处理的10最佳实践。在Java编程中对于检查异常有褒有贬，强制处理异常是一门语言的功能。在本文中，我们将尽量减少使用检查型异常，同时学会在Java编程中使用检查型VS非检查型异常。&lt;/p&gt;
&lt;h2 id=&quot;1-为可恢复的错误使用检查型异常，为编程错误使用非检查型错误&quot;&gt;&lt;a href=&quot;#1-为可恢复的错误使用检查型异常，为编程错误使用非检查型错误&quot; class=&quot;headerlink&quot; title=&quot;1. 为可恢复的错误使用检查型异常，为编程错误使用非检查型错误&quot;&gt;&lt;/a&gt;1. 为可恢复的错误使用检查型异常，为编程错误使用非检查型错误&lt;/h2&gt;&lt;p&gt;选择检查型还是非检查型异常，对于Java编程人员来说，总是让人感到困惑。检查型异常保证你对错误条件提供异常处理代码，这是一种从语言到强制你编写健壮的代码的一种方式，但同时会引入大量杂乱的代码并导致其不可读。当然，如果你有替代品和恢复策略的话，捕捉异常并做些什么看起来似乎也在理。在Java编程中选择检查型异常还是运行时异常，更多信息参考 &lt;a href=&quot;http://javarevisited.blogspot.com/2011/12/checked-vs-unchecked-exception-in-java.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;checked vs unchecked exceptions&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;2-在finally程序块中关闭或者释放资源&quot;&gt;&lt;a href=&quot;#2-在finally程序块中关闭或者释放资源&quot; class=&quot;headerlink&quot; title=&quot;2. 在finally程序块中关闭或者释放资源&quot;&gt;&lt;/a&gt;2. 在finally程序块中关闭或者释放资源&lt;/h2&gt;&lt;p&gt;这在Java编程中，是一个广为人知的最佳实践，在处理网络和IO类的时候，相当于一个标准。在finally块中关闭资源， 在正常和异常执行的情况下，保证之前和稀缺资源的合理释放，这由y finally块保证。从Java7开始，该语言有了一项更有趣的功能：&lt;a href=&quot;http://javarevisited.blogspot.com/2011/09/arm-automatic-resource-management-in.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;资源管理自动化或者ARM块&lt;/a&gt;能实现这一功能。尽管如此，我们仍然要记住在finally块中关闭资源，这是对于释放像FileDescriptors这类，应用在socket和文件编程的情况下的有限资源很重要的。&lt;/p&gt;
&lt;h2 id=&quot;3-在堆栈跟踪中包含引起异常的原因&quot;&gt;&lt;a href=&quot;#3-在堆栈跟踪中包含引起异常的原因&quot; class=&quot;headerlink&quot; title=&quot;3. 在堆栈跟踪中包含引起异常的原因&quot;&gt;&lt;/a&gt;3. 在堆栈跟踪中包含引起异常的原因&lt;/h2&gt;&lt;p&gt;很多时候，当一个由另一个异常导致的异常被抛出的时候，Java库和开放源代码会将一种异常包装成另一种异常。日志记录和打印根异常就变得非常重要。Java异常类提供了 getCause()方法来检索导致异常的原因，这些（原因）可以对异常的根层次的原因提供更多的信息。该Java实践对在进行调试或排除故障大有帮助。时刻记住，如果你将一个异常包装成另一种异常时，构造一个新异常要传递源异常。&lt;/p&gt;
&lt;h2 id=&quot;4-始终提供关于异常的有意义的完整的信息&quot;&gt;&lt;a href=&quot;#4-始终提供关于异常的有意义的完整的信息&quot; class=&quot;headerlink&quot; title=&quot;4. 始终提供关于异常的有意义的完整的信息&quot;&gt;&lt;/a&gt;4. 始终提供关于异常的有意义的完整的信息&lt;/h2&gt;&lt;p&gt;异常信息是最重要的地方，因为这是程序员首先看到的第一个地方，这里你能找到问题产生的根本原因。这里始终提供精确的真实的信息。例如，对比IllegalArgumentException 异常的两条异常信息：&lt;br&gt;消息 1: “Incorrect argument for method”&lt;br&gt;消息 2: “Illegal value for ${argument}: ${value}&lt;br&gt;第一条消息仅说明了参数是非法的或者不正确，但第二条消息包括了参数名和非法值，而这对于找到错误的原因是很重要的。在用Java编程中编写异常处理代码的时候，始终遵循该Java最佳实践。&lt;/p&gt;
&lt;h2 id=&quot;5-避免过度使用检查型异常&quot;&gt;&lt;a href=&quot;#5-避免过度使用检查型异常&quot; class=&quot;headerlink&quot; title=&quot;5. 避免过度使用检查型异常&quot;&gt;&lt;/a&gt;5. 避免过度使用检查型异常&lt;/h2&gt;&lt;p&gt;检查型异常在强制执行方面有一定的优势，但同时它也破坏了代码，通过掩盖业务逻辑使代码可读性降低。只要你不过度使用检查型异常，你可以最大限度的减少这类情况，这样做的结果是你会得到更清洁的代码。你同样可以使用Java7的新功能，像&lt;a href=&quot;http://javarevisited.blogspot.com/2011/07/jdk7-multi-cache-block-example-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;one catch block for multiple exceptions 和 automatic resource management&lt;/a&gt;以移除重复项。&lt;/p&gt;
&lt;h2 id=&quot;6-将检查型异常转为运行时异常&quot;&gt;&lt;a href=&quot;#6-将检查型异常转为运行时异常&quot; class=&quot;headerlink&quot; title=&quot;6. 将检查型异常转为运行时异常&quot;&gt;&lt;/a&gt;6. 将检查型异常转为运行时异常&lt;/h2&gt;&lt;p&gt;这是在像Spring之类的多数框架中用来限制使用检查型异常的技术之一，大部分出自于JDBC的检查型异常，都被包装进DataAccessException中，而（DataAccessException）异常是一种非检查型异常。这是Java最佳实践带来的好处，特定的异常限制到特定的模块，像 SQLException 放到DAO层，将意思明确的运行时异常抛到客户层。&lt;/p&gt;
&lt;h2 id=&quot;7-记住对性能而言，异常代价高昂&quot;&gt;&lt;a href=&quot;#7-记住对性能而言，异常代价高昂&quot; class=&quot;headerlink&quot; title=&quot;7. 记住对性能而言，异常代价高昂&quot;&gt;&lt;/a&gt;7. 记住对性能而言，异常代价高昂&lt;/h2&gt;&lt;p&gt;需要记住的一件事是异常代价高昂，同时让你的代码运行缓慢。假如你有方法从ResultSet（结果集）中进行读取，这时常会抛出SQLException异常而不会移到下一元素，这将会比不抛出异常的正常代码执行的慢的多。因此最大限度的减少不必要的异常捕捉和移动，那里没有什么固定的原因。不要仅仅是抛出和捕捉异常，如果你能使用boolean变量去表示执行结果，可能会得到更整洁，更高性能的解决方案。修正错误的根源，避免不必须要的异常捕捉。&lt;/p&gt;
&lt;h2 id=&quot;8-避免catch块为空&quot;&gt;&lt;a href=&quot;#8-避免catch块为空&quot; class=&quot;headerlink&quot; title=&quot;8. 避免catch块为空&quot;&gt;&lt;/a&gt;8. 避免catch块为空&lt;/h2&gt;&lt;p&gt;没有什么比空的catch块更糟糕的了，因为它不仅隐藏了错误和异常，同时可能导致你的对象处于不可使用或者脏的状态。空的catch块只能变得无意义，如果你非常肯定异常不会继续以任何方式影响对象状态，但在程序执行期间，用日志记录错误依然是最好的（方法）。对于在Java编程中编写异常处理代码，这不仅仅是一个Java最佳实践，而是一个最通用的实践。&lt;/p&gt;
&lt;h2 id=&quot;9-使用标准异常&quot;&gt;&lt;a href=&quot;#9-使用标准异常&quot; class=&quot;headerlink&quot; title=&quot;9. 使用标准异常&quot;&gt;&lt;/a&gt;9. 使用标准异常&lt;/h2&gt;&lt;p&gt;我们的第九条最佳实践建议使用标准和内置的Java异常。使用标准异常而不是每次创建我们自己的异常，对于维护性和一致性，不管是现在还是以后，都是最好的选择。重用标准异常使代码更具可读性，因为大部分Java开发人员对标准的像源自于JDK的RuntimeException 异常，IllegalStateException 异常，IllegalArgumentException 异常或者 NullPointerException异常，（开发者）他们能一眼就知道每种异常的目的，而不是在代码里查找或者在文档里查找用户定义的异常的目的。&lt;/p&gt;
&lt;h2 id=&quot;10-记录任何方法抛出的异常&quot;&gt;&lt;a href=&quot;#10-记录任何方法抛出的异常&quot; class=&quot;headerlink&quot; title=&quot;10. 记录任何方法抛出的异常&quot;&gt;&lt;/a&gt;10. 记录任何方法抛出的异常&lt;/h2&gt;&lt;p&gt;Java提供了throw和throws关键字来抛出异常，在javadoc中用@throw记录任何方法可能会抛出的异常。如果你编写API或者公共接口，这就变得非常重要。任何方法抛出的异常都有相应的文档记录，这样你就能下意识的提醒任何使用（该方法）的人。&lt;/p&gt;
&lt;p&gt;这些就是所有在Java编程中在处理异常的时候需要遵循的最佳实践。让我们知道了什么是在Java编程中编写异常处理代码时需要遵循的实践。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;英文原文：&lt;a href=&quot;http://javarevisited.blogspot.in/2013/03/0-exception-handling-best-practices-in-Java-Programming.html&quot; target=&quot;_blank&quot; rel=
    
    </summary>
    
    
      <category term="Java" scheme="http://fengfu.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式</title>
    <link href="http://fengfu.io/2015/03/08/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://fengfu.io/2015/03/08/23种设计模式/</id>
    <published>2015-03-08T12:41:09.000Z</published>
    <updated>2016-02-27T13:51:07.274Z</updated>
    
    <content type="html">&lt;p&gt;设计模式分为3大类（创建型、结构型、行为型），共23种。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建型模式：单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行为型模式：模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式分为3大类（创建型、结构型、行为型），共23种。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建型模式：单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模
    
    </summary>
    
    
      <category term="架构" scheme="http://fengfu.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Intellij Idea快捷键大全</title>
    <link href="http://fengfu.io/2015/02/21/Intellij%20Idea%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/"/>
    <id>http://fengfu.io/2015/02/21/Intellij Idea快捷键大全/</id>
    <published>2015-02-21T11:41:09.000Z</published>
    <updated>2016-02-27T13:50:26.468Z</updated>
    
    <content type="html">&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;IntelliJ IDEA 的便捷操作性，快捷键的功劳占了一大半，对于各个快捷键组合请认真对待。IntelliJ IDEA 本身的设计思维是提倡键盘优先于鼠标的，所以各种快捷键组合层出不穷，对于快捷键设置也有各种支持，对于其他 IDE 的快捷键组合也有预设模板进行支持。&lt;/p&gt;
&lt;p&gt;关于各个快捷键的频率分类上可能每个人都有各自的看法，下面的整理也只是已我个人的使用习惯来划分的，而我应该是可以代表某一部分小众人员。但是我个人还是建议你可以在我的基础上整理一份属于的快捷键目录，本篇文章也只是起到一个工具和引子的作用。&lt;/p&gt;
&lt;p&gt;对于下面各个快捷键的使介绍描述也许用我个人语言翻译起来不够准确或是不全面，且在不同的文件类型上按出来的效果也可能结果不太一样,所以 &lt;strong&gt;强烈建议&lt;/strong&gt; 你自己把各个快捷键都亲自操作下体会下各个快捷键的实际用法。&lt;/p&gt;
&lt;h2 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h2&gt;&lt;p&gt;由于文化的不同，我们使用的电脑必备一个软件就是中文输入法，而目前大多数人都使用搜狗拼音输入法或是其他类似的。而这些输入法跟 IntelliJ IDEA 有一个万恶的冲突永恒不变：快捷键冲突。所以为了配合 IntelliJ IDEA，我们要去掉这些输入法下的所有快捷键。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/xxvii-c-keymap-premise-1.jpg&quot; alt=&quot;前提&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如上图红色圈住内容所示，默认是 &lt;code&gt;逗号&lt;/code&gt; 我改为了 ESC 键下的 &lt;code&gt;波浪号&lt;/code&gt;，&lt;code&gt;Ctrl + 逗号&lt;/code&gt; 这个快捷键适合做智能提示用，下面的快捷键列表会讲。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;images/xxvii-c-keymap-premise-2.jpg&quot; alt=&quot;前提&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如上图红色圈住内容所示，这些快捷键很容易跟 IntelliJ IDEA 快捷键冲突，需要全部去掉。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;images/xxvii-c-keymap-premise-3.jpg&quot; alt=&quot;前提&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如上图红色圈住内容所示，QQ 这些快捷键也很容易跟 IntelliJ IDEA 快捷键冲突，需要全部去掉，最多保持一个截图功能即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;可能还有其他一些软件，比如网易云音乐、有道词典等等这些软件都可能存在快捷键冲突，所以为了 IntelliJ IDEA 这些软件的快捷键都是值得舍弃的，如果你在开发的时候。&lt;/p&gt;
&lt;h2 id=&quot;Ctrl&quot;&gt;&lt;a href=&quot;#Ctrl&quot; class=&quot;headerlink&quot; title=&quot;Ctrl&quot;&gt;&lt;/a&gt;Ctrl&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;快捷键&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + F&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在当前文件进行文本查找 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + R&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在当前文件进行文本替换 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Z&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;撤销 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;删除光标所在行 或 删除选中的行 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + X&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;剪切光标所在行 或 剪切选择内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + C&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;复制光标所在行 或 复制选择内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + D&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + W&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + E&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;显示最近打开的文件记录列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + N&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;根据输入的 &lt;strong&gt;类名&lt;/strong&gt; 查找类文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + G&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在当前文件跳转到指定行处&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + J&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;插入自定义动态代码模板&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + P&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;方法参数提示显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Q&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + U&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;前往当前光标所在的方法的父类的方法 / 接口定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + B&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;进入光标所在的方法/变量的接口或是定义出，等效于 &lt;code&gt;Ctrl + 左键单击&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + K&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;版本控制提交项目，需要此项目有加入到版本控制才可用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + T&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;版本控制更新项目，需要此项目有加入到版本控制才可用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + H&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;显示当前类的层次结构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + O&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;选择可重写的方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + I&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;选择可继承的方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + +&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;展开代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + -&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;折叠代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + /&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + [&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;移动光标到当前所在代码的花括号开始位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + ]&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;移动光标到当前所在代码的花括号结束位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + F1&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在光标所在的错误代码出显示错误信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + F3&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;调转到所选中的词的下一个引用位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + F4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;关闭当前编辑文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + F8&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + F9&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;执行 Make Project 操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + F11&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;选中文件 / 文件夹，使用助记符设定 / 取消书签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + F12&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Tab&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Enter&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;智能分隔行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + End&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;跳到文件尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Home&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;跳到文件头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Space&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 &lt;code&gt;Ctrl + 逗号&lt;/code&gt; &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Delete&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;删除光标后面的单词或是中文句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + BackSpace&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;删除光标前面的单词或是中文句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + 1,2,3…9&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;定位到对应数值的书签位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + 左键单击&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在打开的文件标题上，弹出该文件路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + 光标定位&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;按 Ctrl 不要松开，会显示光标所在的类信息摘要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + 左方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;光标跳转到当前单词 / 中文句的左侧开头位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + 右方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;光标跳转到当前单词 / 中文句的右侧开头位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + 前方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;等效于鼠标滚轮向前效果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + 后方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;等效于鼠标滚轮向后效果&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;Alt&quot;&gt;&lt;a href=&quot;#Alt&quot; class=&quot;headerlink&quot; title=&quot;Alt&quot;&gt;&lt;/a&gt;Alt&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;快捷键&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + `&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;显示版本控制常用操作菜单弹出层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Q&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;弹出一个提示，显示当前类的声明 / 上下文信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + F1&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + F2&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;对于前面页面，显示各类浏览器打开目标选择弹出层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + F3&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;选中文本，逐个往下查找相同文本，并高亮显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + F7&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;查找光标所在的方法 / 变量 / 类被调用的地方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + F8&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Home&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;定位 / 显示到当前文件的 &lt;code&gt;Navigation Bar&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Enter&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Insert&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + 左方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;按左方向切换当前已打开的文件视图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + 右方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;按右方向切换当前已打开的文件视图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + 前方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;当前光标跳转到当前文件的前一个方法名位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + 后方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;当前光标跳转到当前文件的后一个方法名位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + 1,2,3…9&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;显示对应数值的选项卡，其中 1 是 Project 用得最多&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;Shift&quot;&gt;&lt;a href=&quot;#Shift&quot; class=&quot;headerlink&quot; title=&quot;Shift&quot;&gt;&lt;/a&gt;Shift&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;快捷键&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + F1&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;如果有外部文档可以连接外部文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + F2&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;跳转到上一个高亮错误 或 警告位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + F3&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在查找模式下，查找匹配上一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + F4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;对当前打开的文件，使用新Windows窗口打开，旧窗口保留&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + F6&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;对文件 / 文件夹 重命名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + F7&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + F8&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在 Debug 模式下，跳出，表现出来的效果跟 &lt;code&gt;F9&lt;/code&gt; 一样&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + F9&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;等效于点击工具栏的 &lt;code&gt;Debug&lt;/code&gt; 按钮&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + F10&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;等效于点击工具栏的 &lt;code&gt;Run&lt;/code&gt; 按钮&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + F11&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;弹出书签显示层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + Tab&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;取消缩进&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + ESC&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;隐藏当前 或 最后一个激活的工具窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + End&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;选中光标到当前行尾位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + Home&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;选中光标到当前行头位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + Enter&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;开始新一行。光标所在行下空出一行，光标定位到新行位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + 左键单击&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在打开的文件名上按此快捷键，可以关闭当前打开文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Shift + 滚轮前后滚动&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;当前文件的横向滚动轴滚动&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;Ctrl-Alt&quot;&gt;&lt;a href=&quot;#Ctrl-Alt&quot; class=&quot;headerlink&quot; title=&quot;Ctrl + Alt&quot;&gt;&lt;/a&gt;Ctrl + Alt&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;快捷键&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + L&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;格式化代码，可以对当前文件和整个包目录使用 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + O&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;优化导入的类，可以对当前文件和整个包目录使用 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + I&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;光标所在行 或 选中部分进行自动代码缩进，有点类似格式化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + T&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;对选中的代码弹出环绕选项弹出层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + J&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;弹出模板选择窗口，讲选定的代码加入动态模板中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + H&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;调用层次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + B&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + V&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;快速引进变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;同步、刷新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + S&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;打开 IntelliJ IDEA 系统设置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + F7&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + F11&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;切换全屏模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + Enter&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;光标所在行上空出一行，光标定位到新行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + Home&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;弹出跟当前文件有关联的文件弹出层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + Space&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;类名自动完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + 左方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;退回到上一个操作的地方 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + 右方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;前进到上一个操作的地方 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + 前方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在查找模式下，跳到上个查找的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Alt + 后方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在查找模式下，跳到下个查找的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;Ctrl-Shift&quot;&gt;&lt;a href=&quot;#Ctrl-Shift&quot; class=&quot;headerlink&quot; title=&quot;Ctrl + Shift&quot;&gt;&lt;/a&gt;Ctrl + Shift&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;快捷键&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + F&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;根据输入内容查找整个项目 或 指定目录内文件 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + R&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + J&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;自动将下一行合并到当前行末尾 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + Z&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;取消撤销 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + W&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + N&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + U&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;对选中的代码进行大 / 小写轮流转换 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + T&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + C&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;复制当前文件磁盘路径到剪贴板&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + V&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;弹出缓存的最近拷贝的内容管理器弹出层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + E&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;显示最近修改的文件列表的弹出层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + H&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;显示方法层次结构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + B&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;跳转到类型声明处&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + I&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;快速查看光标所在的方法 或 类的定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + A&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;查找动作 / 设置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + /&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;代码块注释 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + [&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;选中从光标所在位置到它的顶部中括号位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + ]&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;选中从光标所在位置到它的底部中括号位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + +&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;展开所有代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + -&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;折叠所有代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + F7&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;高亮显示所有该选中文本，按Esc高亮消失&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + F8&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在 Debug 模式下，指定断点进入条件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + F9&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;编译选中的文件 / 包 / Module&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + F12&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;编辑器最大化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + Space&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;智能代码提示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + Enter&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;自动结束代码，行末自动添加分号 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + Backspace&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;退回到上次修改的地方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + 1,2,3…9&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;快速添加指定数值的书签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + 左方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + 右方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + 左方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在光标焦点是在工具选项卡上，缩小选项卡区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + 右方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在光标焦点是在工具选项卡上，扩大选项卡区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + 前方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;光标放在方法名上，将方法移动到上一个方法前面，调整方法排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + 后方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;光标放在方法名上，将方法移动到下一个方法前面，调整方法排序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;Alt-Shift&quot;&gt;&lt;a href=&quot;#Alt-Shift&quot; class=&quot;headerlink&quot; title=&quot;Alt + Shift&quot;&gt;&lt;/a&gt;Alt + Shift&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;快捷键&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Shift + N&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;选择 / 添加 task&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Shift + F&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;显示添加到收藏夹弹出层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Shift + C&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;查看最近操作项目的变化情况列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Shift + F&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;添加到收藏夹&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Shift + I&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;查看项目当前文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Shift + F7&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Shift + F9&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;弹出 &lt;code&gt;Debug&lt;/code&gt;  的可选择菜单&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Shift + F10&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;弹出 &lt;code&gt;Run&lt;/code&gt;  的可选择菜单&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Shift + 左键双击&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Shift + 前方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;移动光标所在行向上移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Alt + Shift + 后方向键&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;移动光标所在行向下移动&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;Ctrl-Shift-Alt&quot;&gt;&lt;a href=&quot;#Ctrl-Shift-Alt&quot; class=&quot;headerlink&quot; title=&quot;Ctrl + Shift + Alt&quot;&gt;&lt;/a&gt;Ctrl + Shift + Alt&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;快捷键&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + Alt + V&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;无格式黏贴&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + Alt + N&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;前往指定的变量 / 方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + Alt + S&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;打开当前项目设置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Ctrl + Shift + Alt + C&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;复制参考信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;快捷键&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;F2&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;跳转到下一个高亮错误 或 警告位置 &lt;code&gt;（必备）&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;F3&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在查找模式下，定位到下一个匹配处&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;F4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;编辑源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;F7&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;F8&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;F9&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;F11&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;添加书签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;F12&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;回到前一个工具窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Tab&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;缩进&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;ESC&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;从工具窗口进入代码文件窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;连按两次Shift&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;弹出 &lt;code&gt;Search Everywhere&lt;/code&gt; 弹出层&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;官网快捷键资料&quot;&gt;&lt;a href=&quot;#官网快捷键资料&quot; class=&quot;headerlink&quot; title=&quot;官网快捷键资料&quot;&gt;&lt;/a&gt;官网快捷键资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Windows / Linux：&lt;a href=&quot;https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mac OS X：&lt;a href=&quot;https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard_Mac.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard_Mac.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第三方快捷键资料&quot;&gt;&lt;a href=&quot;#第三方快捷键资料&quot; class=&quot;headerlink&quot; title=&quot;第三方快捷键资料&quot;&gt;&lt;/a&gt;第三方快捷键资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;来自 eta02913：&lt;a href=&quot;http://xinyuwu.iteye.com/blog/1005454&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://xinyuwu.iteye.com/blog/1005454&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;快捷键修改&quot;&gt;&lt;a href=&quot;#快捷键修改&quot; class=&quot;headerlink&quot; title=&quot;快捷键修改&quot;&gt;&lt;/a&gt;快捷键修改&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;images/xxvii-a-keymap-setting-1.jpg&quot; alt=&quot;修改快捷键&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;按 &lt;code&gt;Ctrl + Alt + S&lt;/code&gt; 弹出 IDE 设置，如上图选择左侧的 &lt;code&gt;Keymap&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;IntelliJ IDEA 支持两种方式来筛选我们要找的快捷键，一种是上图标注 1 所示的，通过输入快捷键描述内容；一种是上图标注 2 所示的，通过 &lt;strong&gt;按&lt;/strong&gt; 指定快捷键快捷键，这里需要再次强调的是，这个输入框是自动监听你当前按下的按键，而不是用来输入的。&lt;/li&gt;
&lt;li&gt;上图标注 3 所示，初安装的 IntelliJ IDEA 使用的是 &lt;code&gt;Default&lt;/code&gt; 的快捷键模板，IntelliJ IDEA 默认的快捷键模板都是不可修改的。如果你直接修改，当前这个位置 IntelliJ IDEA 会自动变成 &lt;code&gt;Default Copy&lt;/code&gt;，建议你养成习惯，修改之前先点击 &lt;code&gt;Copy&lt;/code&gt;，拷贝一套快捷键模板，然后输入自己的命名。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;images/xxvii-a-keymap-setting-2.jpg&quot; alt=&quot;修改快捷键&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;IntelliJ IDEA 是支持一个操作命令同时设置多个快捷键组合，就如上图的 &lt;code&gt;Backspace&lt;/code&gt;，同时支持 &lt;code&gt;Backspace&lt;/code&gt; 和 &lt;code&gt;Shift + Backspace&lt;/code&gt; 两组快捷键。&lt;/li&gt;
&lt;li&gt;要修改某个快捷键，选中快捷键介绍内容，右键，就会弹出如上图标注 1 所示操作选择。&lt;/li&gt;
&lt;li&gt;命令 &lt;code&gt;Add Keyboard Shortcut&lt;/code&gt; 用来添加新纯键盘快捷键组合。&lt;/li&gt;
&lt;li&gt;命令 &lt;code&gt;Add Mouse Shortcut&lt;/code&gt; 用来添加新 &lt;code&gt;键盘 + 鼠标&lt;/code&gt; 快捷键组合，比如设置 &lt;code&gt;Ctrl + 左键单击&lt;/code&gt; 这类快捷组合。其中在弹出的添加面板中 &lt;code&gt;Click Pad&lt;/code&gt; 是用来监听当前鼠标是左键单击还是右键单击。&lt;/li&gt;
&lt;li&gt;命令 &lt;code&gt;Add Abbreviation&lt;/code&gt; 根据 IntelliJ IDEA 的版本文档解释，添加简称主要是为了方便 &lt;code&gt;Search Everywhere&lt;/code&gt; 中使用，但是我尝试之后发现没办法根据我设置的简称搜索，暂时无法了解其作用。 &lt;/li&gt;
&lt;li&gt;命令 &lt;code&gt;Remove 快捷键&lt;/code&gt; 移出当前操作命令已设置的快捷键组合，由于 IntelliJ IDEA 默认就占用了很多快捷键组合，所以如果你要修改某个快捷键，建议还是删除掉旧的。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;images/xxvii-a-keymap-setting-3.jpg&quot; alt=&quot;修改快捷键&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;IntelliJ IDEA 对其他 IDE 用户很友好，比如如上图对于其他主流的 IDE，快捷键上已经默认了有其过度快捷键模板了，但是我还是建议你专心使用 IntelliJ IDEA 的默认。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;其他-1&quot;&gt;&lt;a href=&quot;#其他-1&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;images/xxvii-b-ideavim-1.jpg&quot; alt=&quot;vim插件推荐&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果你是一个 Vim 粉，IntelliJ IDEA 也为你准备了一个方案：如上图安装 IdeaVim 插件即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;IntelliJ IDEA 的便捷操作性，快捷键的功劳占了一大半，对于各个快捷键组合请认真对待。IntelliJ IDEA 本身的设计思维是
    
    </summary>
    
    
      <category term="Java" scheme="http://fengfu.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java的SPI机制</title>
    <link href="http://fengfu.io/2015/02/21/Java%E7%9A%84SPI%E6%9C%BA%E5%88%B6/"/>
    <id>http://fengfu.io/2015/02/21/Java的SPI机制/</id>
    <published>2015-02-21T11:35:09.000Z</published>
    <updated>2016-02-27T13:50:17.243Z</updated>
    
    <content type="html">&lt;h2 id=&quot;什么是SPI&quot;&gt;&lt;a href=&quot;#什么是SPI&quot; class=&quot;headerlink&quot; title=&quot;什么是SPI&quot;&gt;&lt;/a&gt;什么是SPI&lt;/h2&gt;&lt;p&gt;SPI是Service Provider Interface（服务提供者接口）的缩写，从字面意思也能看出，SPI是面向服务提供者的。也就是说，有人定义了接口，那么围绕该接口提供服务的第三方则针对接口提供自己的服务。说到这里，最典型的应该是我们常用的日志框架，比如common-logging、jdbc Driver。&lt;/p&gt;
&lt;h2 id=&quot;SPI的优点&quot;&gt;&lt;a href=&quot;#SPI的优点&quot; class=&quot;headerlink&quot; title=&quot;SPI的优点&quot;&gt;&lt;/a&gt;SPI的优点&lt;/h2&gt;&lt;p&gt;基于SPI机制，我们可以很方便地构建出易于扩展的应用。我们使用的很多应用框架，比如dubbo，其中的extension就是基于SPI构建的。&lt;/p&gt;
&lt;h2 id=&quot;Java-SPI规范&quot;&gt;&lt;a href=&quot;#Java-SPI规范&quot; class=&quot;headerlink&quot; title=&quot;Java SPI规范&quot;&gt;&lt;/a&gt;Java SPI规范&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在META-INF/services/目录下创建以接口全名命名的文件,该文件内容为接口具体实现类的全名;如我有一个实现类io.fengfu.learning.spi.HelloWorldServiceBB8Impl，实现了io.fengfu.learning.spi.HelloWorldService接口，那么就需要在META-INF/services目录下创建一个名称为io.fengfu.learning.spi.HelloWorldService的文件，文件的内容为io.fengfu.learning.spi.HelloWorldServiceBB8Impl。如果我有很多个实现类，那么只需要将实现类全名按行编写即可;&lt;/li&gt;
&lt;li&gt;接口具体实现类必须有一个不带参数的构造方法;&lt;/li&gt;
&lt;li&gt;使用ServiceLoader类动态加载META-INF中的实现类;&lt;/li&gt;
&lt;li&gt;如SPI的实现类为Jar则需要放在主程序classPath中;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;SPI示例&quot;&gt;&lt;a href=&quot;#SPI示例&quot; class=&quot;headerlink&quot; title=&quot;SPI示例&quot;&gt;&lt;/a&gt;SPI示例&lt;/h2&gt;&lt;p&gt;1,定义一个接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package io.fengfu.learning.spi;

/**
 * Created by fengfu.qu on 2014/2/4.
 */
public interface HelloService {
    public String sayHello(String name);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2, 实现之：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package io.fengfu.learning.spi;

/**
 * Created by fengfu.qu on 2014/2/4.
 */
public class HelloServiceR2D2Impl implements HelloService {
    public String sayHello(String name) {
        return &amp;quot;Hello, &amp;quot; + name + &amp;quot;, I&amp;apos;m R2D2.&amp;quot;;
    }
}

package io.fengfu.learning.spi;

/**
 * Created by fengfu.qu on 2014/2/4.
 */
public class HelloServiceC3poImpl implements HelloService {
    public String sayHello(String name) {
        return &amp;quot;Hello, &amp;quot; + name + &amp;quot;, I&amp;apos;m C3po.&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3, 在META-INF/services目录下创建io.fengfu.learning.spi.HelloService文件，在文件中添加以下内容:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;io.fengfu.learning.spi.HelloServiceR2D2Impl
io.fengfu.learning.spi.HelloServiceBB8Impl
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4, 创建测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package io.fengfu.learning.spi;

import java.util.Iterator;
import java.util.ServiceLoader;

/**
 * Created by fengfu.qu on 2014/2/4.
 */
public class SPITest {
    public static void main(String[] args) {
        ServiceLoader&amp;lt;HelloService&amp;gt; loader = ServiceLoader.load(HelloService.class);
        Iterator&amp;lt;HelloService&amp;gt; it = loader.iterator();
        while(it.hasNext()){
            HelloService helloSPI = it.next();
            System.out.println(helloSPI.sayHello(&amp;quot;Fengfu&amp;quot;));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5, 运行，结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hello, Fengfu, I&amp;apos;m R2D2.
Hello, Fengfu, I&amp;apos;m C3po.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由此看出，2个是实现类都被运行了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是SPI&quot;&gt;&lt;a href=&quot;#什么是SPI&quot; class=&quot;headerlink&quot; title=&quot;什么是SPI&quot;&gt;&lt;/a&gt;什么是SPI&lt;/h2&gt;&lt;p&gt;SPI是Service Provider Interface（服务提供者接口）的缩写，从字面意思也能看出，S
    
    </summary>
    
    
      <category term="Java" scheme="http://fengfu.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>利特尔法则</title>
    <link href="http://fengfu.io/2015/02/14/%E5%88%A9%E7%89%B9%E5%B0%94%E6%B3%95%E5%88%99/"/>
    <id>http://fengfu.io/2015/02/14/利特尔法则/</id>
    <published>2015-02-14T12:41:09.000Z</published>
    <updated>2016-02-27T13:49:48.590Z</updated>
    
    <content type="html">&lt;p&gt;##概念##&lt;/p&gt;
&lt;p&gt;利特尔法则由麻省理工大学斯隆商学院（MIT Sloan School of Management）的教授John Little﹐于1961年所提出与证明。其英文名称为：Little’s Law。&lt;br&gt;利特尔法则是一个有关提前期与在制品关系的简单数学公式，这一法则为精益生产的改善方向指明了道路。 如何有效地缩短生产周期呢？利特尔法则已经很明显地指出了方向：一个方向是提高产能，从而降低生产节拍；另一个方向就是压缩存货数量。然而，提高产能往往意味着增加很大的投入。另外，生产能力的提升虽然可以缩短生产周期，但是生产能力的提升总有个限度，我们无法容忍生产能力远远超过市场的需求。一般来说，每个公司在一定时期内的生产能力是大致不变的，而从长期来看，各公司也会力图使自己公司的产能与市场需求相吻合。因此，最有效地缩短生产周期的方法就是压缩在制品数量。&lt;br&gt;利特尔法则不仅适用于整个系统，而且也适用于系统的任何一部分。&lt;/p&gt;
&lt;p&gt;##公式##&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.lieyunwang.com/wp-content/uploads/2014/11/0e1490aebb8c1b4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;L=系统中的平均项目数量；&lt;/p&gt;
&lt;p&gt;W=一个项目在系统中所需等待的平均时间；&lt;/p&gt;
&lt;p&gt;λ=单位时间内项目到达的平均数量；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在一个稳定的系统中，长时间观察到的平均顾客数量L，等于，长时间观察到的有效到达速率λ与平均每个顾客在系统中花费的时间W之乘积。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;##举例##&lt;/p&gt;
&lt;p&gt;比如我们要去一个快餐店吃饭，这个快餐店平均每分钟有2个人进入，每个人平均用餐时间是0.5小时，那么算一下这个饭店当前有多少人在用餐？&lt;br&gt;答案：2 &lt;em&gt; 0.5 &lt;/em&gt; 60 = 60人&lt;br&gt;其中2为速率λ，0.5为花费时间W，60为小时换算成与速率一致的单位的系数。&lt;/p&gt;
&lt;p&gt;再举一个估算系统QPS的例子：&lt;br&gt;假如我们有个系统，每天的访问量是200万次，系统处理每次请求平均花费的时间是3秒，那么系统能够支撑的QPS是多少？&lt;br&gt;QPS = 2000000/24/3600/3 = 7.7&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##概念##&lt;/p&gt;
&lt;p&gt;利特尔法则由麻省理工大学斯隆商学院（MIT Sloan School of Management）的教授John Little﹐于1961年所提出与证明。其英文名称为：Little’s Law。&lt;br&gt;利特尔法则是一个有关提前期与在制品关系的简单
    
    </summary>
    
    
      <category term="商业" scheme="http://fengfu.io/tags/%E5%95%86%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>线程初始化参数</title>
    <link href="http://fengfu.io/2015/02/08/%E7%BA%BF%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0/"/>
    <id>http://fengfu.io/2015/02/08/线程初始化参数/</id>
    <published>2015-02-08T12:41:09.000Z</published>
    <updated>2016-02-27T13:49:32.173Z</updated>
    
    <content type="html">&lt;p&gt;线程池创建时，有3个参数比较关键，分别是：corePoolSize、maximumPoolSize，还有一个queueSize。&lt;/p&gt;
&lt;p&gt;corePoolSize&lt;/p&gt;
&lt;p&gt;线程池基本大小，即在任务没有需要执行的时候线程池的大小。在刚刚创建了ThreadPoolExecutor的时候，线程并不会立即启动，只有在有任务提交的时候才会启动；除非你调用了prestartCoreThread/prestartAllCoreThreads。&lt;/p&gt;
&lt;p&gt;maximumPoolSize&lt;/p&gt;
&lt;p&gt;线程池中允许的最大线程数，即线程池中运行的线程不可能超过这个数量。&lt;/p&gt;
&lt;p&gt;queueSize&lt;/p&gt;
&lt;p&gt;线程池队列大小，即排队的队列容量。&lt;/p&gt;
&lt;p&gt;如果线程池中线程已达到corePoolSize，并且还有新的任务提交，那么线程池首先将任务存到队列中排队。如果队列也满了，那么线程池将继续在增加 线程，直到达到maximumPoolSize。到这里细心的同学可能会问了：如果队列没设置大小呢？那么我只能告诉你：看运气吧，如果任务少，你的队列 顶多长一些；如果任务很多，那么很可能你要oom了O(∩_∩)O&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;线程池创建时，有3个参数比较关键，分别是：corePoolSize、maximumPoolSize，还有一个queueSize。&lt;/p&gt;
&lt;p&gt;corePoolSize&lt;/p&gt;
&lt;p&gt;线程池基本大小，即在任务没有需要执行的时候线程池的大小。在刚刚创建了ThreadPoolE
    
    </summary>
    
    
      <category term="Java" scheme="http://fengfu.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>架构设计原则</title>
    <link href="http://fengfu.io/2015/02/03/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://fengfu.io/2015/02/03/架构设计原则/</id>
    <published>2015-02-03T11:48:09.000Z</published>
    <updated>2016-05-20T06:51:25.323Z</updated>
    
    <content type="html">&lt;h2 id=&quot;1-单一职责原则-Single-Responsibility-Principle&quot;&gt;&lt;a href=&quot;#1-单一职责原则-Single-Responsibility-Principle&quot; class=&quot;headerlink&quot; title=&quot;1. 单一职责原则(Single Responsibility Principle)&quot;&gt;&lt;/a&gt;1. 单一职责原则(Single Responsibility Principle)&lt;/h2&gt;&lt;p&gt;简而言之，就是一个类只负责一个职责。则样做的好处就是类的职责比较单一，可以降低类的复杂度，简单为美。代码的可读性提高了，维护的复杂性降低了。&lt;/p&gt;
&lt;h2 id=&quot;2-里氏替换原则-Liskov-Substitution-Principle&quot;&gt;&lt;a href=&quot;#2-里氏替换原则-Liskov-Substitution-Principle&quot; class=&quot;headerlink&quot; title=&quot;2. 里氏替换原则(Liskov Substitution Principle)&quot;&gt;&lt;/a&gt;2. 里氏替换原则(Liskov Substitution Principle)&lt;/h2&gt;&lt;p&gt;原则：子类可以扩展父类的功能，但不能改变父类原有的功能。具体总结为以下2点：&lt;/p&gt;
&lt;p&gt;1) 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。&lt;br&gt;2) 子类中可以增加自己特有的方法。&lt;/p&gt;
&lt;p&gt;例如，当类B继承类A时，除添加新的方法完成新增功能外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。&lt;/p&gt;
&lt;h2 id=&quot;3-依赖倒置原则-Dependency-Inversion-Principle&quot;&gt;&lt;a href=&quot;#3-依赖倒置原则-Dependency-Inversion-Principle&quot; class=&quot;headerlink&quot; title=&quot;3. 依赖倒置原则(Dependency Inversion Principle)&quot;&gt;&lt;/a&gt;3. 依赖倒置原则(Dependency Inversion Principle)&lt;/h2&gt;&lt;p&gt;DIP(Dependency Inversion Priciple)，如果你觉得陌生的话，那么IOC(Inversion of Control，控制反转)你一定不会陌生，Spring的核心思想啊。一句话：面向接口编程。&lt;/p&gt;
&lt;p&gt;1) 底层模块尽量都要有抽象类或接口，或者两者都有;&lt;br&gt;2) 变量的声明类型尽量是抽象类或接口;&lt;br&gt;3) 使用继承时遵循里氏替换原则。&lt;/p&gt;
&lt;h2 id=&quot;4-接口隔离原则-Interface-Segregation-Principle&quot;&gt;&lt;a href=&quot;#4-接口隔离原则-Interface-Segregation-Principle&quot; class=&quot;headerlink&quot; title=&quot;4. 接口隔离原则(Interface Segregation Principle)&quot;&gt;&lt;/a&gt;4. 接口隔离原则(Interface Segregation Principle)&lt;/h2&gt;&lt;p&gt;不要创建过大的接口类，即接口中的方法不要过多。本着高内聚的原则，将接口中的方法归类，拆分为几个独立的接口。&lt;/p&gt;
&lt;h2 id=&quot;5-迪米特法则&quot;&gt;&lt;a href=&quot;#5-迪米特法则&quot; class=&quot;headerlink&quot; title=&quot;5. 迪米特法则&quot;&gt;&lt;/a&gt;5. 迪米特法则&lt;/h2&gt;&lt;p&gt;也叫最少知道原则，原则是一个对象应该对其他对象保持最少的了解，出发点是降低类与类之间的耦合度。&lt;/p&gt;
&lt;h2 id=&quot;6-开闭原则-Open-Closed-Principle&quot;&gt;&lt;a href=&quot;#6-开闭原则-Open-Closed-Principle&quot; class=&quot;headerlink&quot; title=&quot;6. 开闭原则(Open Closed Principle)&quot;&gt;&lt;/a&gt;6. 开闭原则(Open Closed Principle)&lt;/h2&gt;&lt;p&gt;对扩展开放，对修改关闭。这个原则很虚，虚得感觉跟没说一样，索性总结一句：遵循前面5条原则，就相当于遵循了开闭原则O(∩_∩)O&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-单一职责原则-Single-Responsibility-Principle&quot;&gt;&lt;a href=&quot;#1-单一职责原则-Single-Responsibility-Principle&quot; class=&quot;headerlink&quot; title=&quot;1. 单一职责原则(Si
    
    </summary>
    
    
      <category term="架构" scheme="http://fengfu.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
